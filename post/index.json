[{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-7.10/","title":"Mattermost 7.10の新機能","section":"post","date":"2023.04.22","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2023/04/14 に Mattermost のアップデートとなる v7.10.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n (今回のリリースに関する公式ブログでの紹介記事は無いそうです) Mattermost self-hosted changelog   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Free版も利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard) Calls: Mattermost上で音声通話と画面共有を行うことができるプラグイン Platform: 上記機能を含むMattermost全体  (Channels) 投稿のリマインド Mattermost上の投稿を一定期間後にリマインドする機能が追加されました。\nメッセージの内容を忘れずに後で確認したい時や、土日を挟んだ翌月曜向けのタスクを設定しておくことなどができます。\nリマインドを設定するには、リマインドしたい投稿のメニューにある Remind からリマインドしたい時刻を選択します。\nリマインド時刻を指定すると、以下のような予告投稿が行われます。\n指定した時刻になると、system-botという名前のBotからのダイレクトメッセージとして以下のようなリマインドが送信されます。\nリマインド時刻は 30分後、1時間後、2時間後、明日、カスタムから選択することができ、カスタムを選択すると、30分単位の任意の日時を指定することができます。\n(Calls) 通話画面を別ウィンドウで開けるように (Desktop) 2023/03/30にリリースされたMattermost Desktop App v5.3から、Calls画面を別ウィンドウとして開くことができるようになりました。\nこれによりCalls画面を開きながら、いつも通りMattermostでチャットができるようになります。\nその他のトピック Mattermostリポジトリのモノレポ化 Mattermostのソースコードはサーバーサイドのmattermost-serverとフロントエンドのmattermost-webappに分かれて管理されていましたが、次回のv7.11リリースからmattermost-serverに集約され、モノレポ管理となります。\nまた、Playbooks機能とBoards機能も、今まではMattermost Pluginとして開発されていましたが、これらもmattermost-serverに集約され、Mattermostのコア機能の一つとして開発が進められることになりました。\nMattermostのコア機能関係のリポジトリがモノレポされたことで、ソースコードからMattermostを起動する際の開発者向けセットアップが変更されています。\nDeveloper setup\nChatGPT Bot 話題のChatGPTをMattermostから使う方法について、Mattermost公式ブログで紹介がありました。\nCommunity Spotlight: Mattermost ChatGPT bot by Sebastian Müller\nこれはコミュニティメンバによって作られたツールで、Mattermostのメッセージを受け取ってOpenAI APIとやり取りをして、結果をMattermostに投稿するBotサーバーを構築するものです。\nyGuy/chatgpt-mattermost-bot: A very simple implementation of a service for a mattermost bot that uses ChatGPT in the backend.\nこの他にも、MattermostとChatGPTを連携したという記事がいくつも公開されています。\n お手軽！ Mattermost に ChatGPT Bot を実装してみた！ - ディーメイクブログ ChatGPTにRedmineの起票を任せてみた - Qiita  おわりに 次のv7.11のリリースは 2023/05/16(Tue)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-7.9/","title":"Mattermost 7.9の新機能","section":"post","date":"2023.03.17","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2023/03/16 に Mattermost のアップデートとなる v7.9.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v7.9 is now available - Mattermost Mattermost self-hosted changelog   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Free版も利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard) Calls: Mattermost上で音声通話と画面共有を行うことができるプラグイン Platform: 上記機能を含むMattermost全体  (Boards) システム管理者/チーム管理者がBoardsにアクセス可能に Mattermostインスタンスのシステム管理者とチーム管理者は、Boardの作成者が招待しなくとも、作成されたBoardにアクセスできるようになりました。\nこれにより、使われなくなったBoardの削除等、Boardsの管理作業を行いやすくなります。\nシステム管理者/チーム管理者は、公開BoardにBoardを探すメニューから、もしくはBoardのURLへの直接アクセスにより、そのBoardに参加することができます。非公開Boardには、BoardのURLに直接アクセスすると、Boardに参加するかどうかを確認するダイアログが表示されます。\n まず、ユーザーがBoard作成を行うと、非公開Boardとして作成されます。\n作成されたBoardの共有メニューより、チームの全員に対する権限を設定することで、そのBoardは公開Boardとなります。\nMattermostのシステム管理者、もしくは作成されたBoardが属するチームのチーム管理者は、Boardを探すメニューから公開Boardを検索できるようになります。\n検索されたBoardにアクセスすると、そのBoardの管理者として自動的に参加することができます。また、公開Boardには、BoardのURLを直接指定して参加することもできます。\n非公開のBoardの場合、システム管理者であってもBoardを探すからは検索できず、BoardのURLから直接アクセスする必要があります。非公開のBoardにURLから直接アクセスすると、以下のようなダイアログが表示されます。\nここで、Joinを選択すると、非公開BoardにそのBoardの管理者として参加することができます。\n(Channels) メッセージの編集履歴が確認可能に 投稿済みのメッセージを後から編集した場合、編集済の表示をクリックすることで、投稿者がメッセージの修正履歴を確認できるようになりました。ある特定のバージョンのメッセージを復元することもできます。\nアップグレード時の注意事項 アップグレード時の注意事項について、詳しくは公式ドキュメントを確認ください。　Important Upgrade Notes\n新たなインデックス作成によるアップグレード時のDBテーブルのロック 今回のアップグレードで、DBの新たなインデックスとして Posts(OriginalId) が追加されます。\n1000万以上の投稿を持つMySQLを利用したMattermostサーバーの場合、i7-11800H(8コア/16スレッド)、32GBメモリの環境でインデックス作成に約100秒かかるそうです。\nアップグレード時のテーブルロックを避けたい場合は、Important Upgrade Notesを確認ください。\nおわりに 次のv7.10のリリースは 2023/04/14(Fri)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/tech/chainguard-publications/","title":"Chainguard社の気になる記事メモ","section":"post","date":"2023.02.21","body":"はじめに 昨今、ソフトウェアサプライチェーンの問題に対処するため、SBOMを用いたソフトウェアサプライチェーンの管理に関する議論が活発。SBOMに関しては、2021年のサイバーセキュリティ関する米国大統領令で触れられたことをはじめ、日本の経済産業省でもSBOM活用に関する議論が続けられている。\nサイバー・フィジカル・セキュリティ確保に向けたソフトウェア管理手法等検討タスクフォース （METI/経済産業省）\nここ最近、Chainguard社がSBOM関連の興味深い記事をいくつか出しているので、備忘録がてらメモする。\n(2022/11/09) Software Dark Matter is the Enemy of Software Transparency 宇宙の27%は観測不可能なdark matterで構成されているが、数百のポピュラーなOSSのコンテナを調べたところ、ソフトウェアにもパッケージマネージャーやSBOMなどで捕捉されないパッケージなどの ソフトウェアダークマター が32%ほど含まれていたという話。ソフトウェアダークマター は、記事内ではOSのパッケージマネージャー (apt や apk)で管理されていないファイルとして定義されている。\nソフトウェアダークマター の現実世界での問題点として、ソフトウェア解析ツールがソフトウェアコンポーネントを正しく特定できないためにセキュリティスキャナーが検出できない脆弱性があることや、SBOMによる情報管理が不完全になる点などを挙げている。\n筆者は、350のポピュラーなOSSのコンテナ内のファイルの内、どの程度の割合が ソフトウェアダークマター なのかを自作ツール (chainguard-dev/darkfiles) で調査している。結果は、平均32%のファイルが ソフトウェアダークマター であり、調査対象のコンテナ内に含まれるファイル数で重みづけを行うと、その割合は 63% まで上昇した。また、調査したコンテナの約30%は ソフトウェアダークマター が1%未満であったため、ソフトウェアダークマターを少なくすることもできること示している。\n(実際に計測を行っているのは以下のファイルの処理だと思うが、少し大味な測定方法な気もする (ちゃんと読めてないだけかもしれないが))\nhttps://github.com/chainguard-dev/darkfiles/blob/main/pkg/distro/distro.go\n 調査結果のソフトウェアダークマターのパーセンテージは少し誇張されている気もするが、ソフトウェアダークマターという言葉はキャッチーであるし、現実に問題となる可能性の高い事象であるため、言語化されたことで改善が進んでいくと良いなと思った。\n(2022/12/21) Are SBOMs Any Good? Preliminary Measurement of the Quality of Open Source Project SBOMs SBOMの質が悪いとSBOMの情報を利用するツールの結果も悪化するという問題意識から、OSSプロジェクトの公開されているSBOMの質的調査を実施したという記事。収集したSBOMは、GitHub (chainguard-dev/bom-shelter) で公開している。\n収集したSBOMは、Sourcegraph を使ってある特定の名前 (例: spdx.json)のファイルを検索して見つけたもの。SBOMの質的評価は eBay/sbom-scorecard と spdx/ntia-conformance-checker を使用して行っている。\n結果としては、調査したSBOMの内、80% はライセンスに関する情報が欠落しており、40% はパッケージのバージョン情報が欠落していた。また、SPDXコミュニティのNTIA最小要素チェックツール (spdx/ntia-conformance-checker) の結果より、今回収集したSBOMには、NTIA最小要素に適合するSBOMが無いことがわかった。(NTIA最小要素に関する言及としては、次に紹介する記事でより詳細に調査をしている)\n SBOMに書かれている情報が、本当に対象のソフトウェアのすべての構成物を表しているかは保証がなく、この調査では実際に不完全なSBOMファイルがSBOMとして公開されていることを示している。ただ、個人的な考えだが、SBOMファイルがリポジトリにコミットして管理されるというのはあまり正しい管理方法だとは思えず、その視点で見ると今回の収集方法で集めたSBOMファイルはそもそも管理方法自体に問題がある気がするので、低い品質のSBOMを集めたことがこの結果につながったのでは無いかという疑念が残る。(ただ、次の記事でより範囲の広い詳細な調査を行なっているため、この疑念は今では晴れている)\n(2023/01/19) Are SBOMs Good Enough for Government Work? 一つ前で紹介した記事と同様、SBOMの質を評価する記事。\nDockerHubで公開されているPopularなコンテナイメージからSBOMを生成し、生成された約3,000のSBOMファイルが、NTIAの最小要素 を満たしているかを検証している。NTIA最小要素への適合は、SPDXコミュニティにより開発が行われている spdx/ntia-conformance-checker を使用。\n対象となるSBOMは、Docker Hubで公開されている1,000個のコンテナイメージから、様々なSBOM生成ツール (syft, bom, Trivy, Tern) を使用して生成したもの。(調査用のコードは GitHub で公開されている)\n結果としては、調査したSBOMの内、NTIA最小要素を完全に満たすSBOMはたったの1%だった。ただ、この結果は、Supplierに関する項目がすべてのコンポーネントにおいて満たされていたSBOMが1%しかなかったということに影響を大きく受けているため、Supplierに関する項目を除外すれば数値はもっと上がるものと思われる。SBOM生成ツールごとに比較では、syftのみがNTIA最小要素準拠のSBOMを生成できていた。また、bomもAuthor、Supplier以外の項目では高い適合率のSBOMを生成できていた。\n Supplierという項目は、対象がOSSであると考えるとパッケージマネージャーの情報が入ることが多いと思うが、ビルド後の成果物からは取得先の情報は失われていることが多いと考えられるため、確かにこの項目の扱いは難しいように感じた。\n(2023/01/26) Make SBOMs, not GuessBOMs: Why we need to shift left on SBOM generation SBOMは、ビルド後の後処理としてSCAツールを実行することで生成する手法が主流だが、その方法では問題がある。\n一つ目に挙げられている問題は、例えば、Golangのコンテナイメージから生成されたSBOMにはGolang自体が含まれていないというように、SCAツールでは自分自身のことを認識できない場合がある。(記事から参照されている以下のTweetではPythonイメージの話をしているが)\nA few more examples of this:\n* scanners can find python in the python image (because it\u0026#39;s installed with a .deb), but not go in the golang image!\n* scanners can find nginx, mysql, and postgres in the respective images, but not redis or cassandra!\n* they can\u0026#39;t find wordpress! https://t.co/gMJ92k9tgj\n\u0026mdash; Dan Lorenc (@lorenc_dan) August 28, 2022  その他にも、解析対象の中にはSCAツールでは発見できない資産 (Software dark matter) が30~60%の割合で存在しているという問題もある。これらの問題を含むSBOMは、疑わしい情報である GuessBOM なのでは? という記事。\nこれを解決する方法として、NTIAも推奨しているように、ビルド後の後処理としてSCAツールを実行するのではなく、ビルド時の動作をキャプチャしながらSBOMに含める情報を集めるのが良いのではないかと提言している。ビルド時であれば、ビルド後の資産からは消えてしまう可能性のあるソースコードなどの元の情報にアクセスすることもできる。\nしかし、現時点ではビルド時の情報を集めてSBOM を生成するツールはあまりなく、それが実現できるツールとしてChainguard社が開発している apko を紹介している。 apko ではコンテナイメージのビルドを実行することで同時にSBOMファイルを生成することができ、さらに生成されたSBOMに対するSigstoreによる署名を行うこともできるらしい。\nGuessBOMである可能性の高い成果物スキャンにより生成されたSBOMではなく、生成物に含まれる署名付きのSBOMを利用することで、SBOM内の情報の信頼性が高まるという話。\n apkoの宣伝エントリという感じもするが、語られている問題意識としては非常に納得できるものだった。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-7.8/","title":"Mattermost 7.8の新機能","section":"post","date":"2023.02.19","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2023/02/16 に Mattermost のアップデートとなる v7.8.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v7.8 is now available - Mattermost Mattermost self-hosted changelog   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Free版も利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard) Calls: Mattermost上で音声通話と画面共有を行うことができるプラグイン Platform: 上記機能を含むMattermost全体  Extended support release (ESR) 今回リリースされたMattermost v7.８は、Extended Support Release (ESR)として2023/11/15までサポートされる予定です。\nMattermosthは毎月16日に新しいバージョンがリリースされていますが、次のバージョンがリリースされた後でも、リリースから3ヶ月間はバグ修正やセキュリティ修正がおこなわれます。Extended Support Release (ESR)に設定されたバージョンは、このサポート期間が3ヶ月から9ヶ月に延長されたバージョンになります。毎月バージョンアップを行うだけの時間が割けない場合は、半年ごとにリリースされるExtended Support Release (ESR)ごとにアップデートをかけることをお勧めします。\nExtended Support Release\nBoards: 人物または日付によるカードのフィルタ 日付(Date)、人物(Person)、または複数人(Multi Person)のプロパティタイプによるフィルタリングを行えるようになりました。\n例えば、あるボード内のカードにプロパティタイプ複数人(Multi Person)の関係者という属性を追加し、自分を設定したとします。\nすると、Boardのフィルターメニューからプロパティタイプ複数人(Multi Person)で作成したプロパティを選択してカードをフィルタすることができるようになります。\n同様に、プロパティタイプ 日付(Date)、人物(Person)で作成したプロパティもフィルターの項目として選択できるようになります。\nBoards: 人物によるカードのグループ化 プロパティタイプ 人物(Person) によるカードのグループ化を行うことができるようになりました。\nこれにより、担当ごとのタスク一覧等を確認しやすくなります。\nアップグレード時の注意事項 アップグレード時の注意事項について、詳しくは公式ドキュメントを確認ください。　Important Upgrade Notes\nメッセージの優先度設定と既読確認機能がデフォルトで有効に Mattermost v7.7で追加されたメッセージの優先度設定と既読確認機能がデフォルトで有効になりました。システムコンソールから無効化することもできます。\nアップグレード中、Boardがロックされないようにする 新しいバージョンのBoardsを起動する際に、DBのfocalboard_category_boardsテーブルに重複するデータが存在する場合、Boards起動中にユーザーがBoardsを利用できなくなることがあるようです。アップグレードを行う前に、当該テーブルに重複がないか確認し、重複データが存在する場合は事前に削除することが推奨されています。\n重複データの確認・削除のクエリは、以下のドキュメントで公開されています。\nImportant Upgrade Notes — Mattermost documentation\nおわりに 次のv7.9のリリースは 2023/03/16(Thu)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-7.7/","title":"Mattermost 7.7の新機能","section":"post","date":"2023.01.20","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2023/01/16 に Mattermost のアップデートとなる v7.7.0 がリリースされました。\nまた、2023/01/20にv7.7.1がリリースされています。v7.7.1では、v7.7.0からMattermost使い始めた場合に最初のシステム管理者のユーザーアカウントを作成できない問題や、インサイト機能でトップチャンネルの結果が表示されない問題に対応されています。\n2022/12/16にリリース予定だったv7.6.0は、パフォーマンスに関する問題を理由にリリースが中止されていたため、2ヶ月ぶりのリリースになります。\n The Mattermost v7.6 release has been cancelled as we are working on investigating performance issues. The next scheduled release is v7.7 in January 16th, 2023.\n 本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v7.7 is now available - Upgrade today Mattermost self-hosted changelog   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Free版も利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard) Calls: Mattermost上で音声通話と画面共有を行うことができるプラグイン Platform: 上記機能を含むMattermost全体  Calls: General Availability 2022/06にリリースされたMattermost v7.0でベータ版として追加されたCalls機能がGeneral Availabilityとなりました。\n先々月のリリースからのアップデートとして、通話中にリアクションを送ることができるようになりました。　通話画面でリアクションを選択すると、選択したリアクションがユーザー名と共に画面左に表示されます。このリアクションは一定時間経過すると消えていきます。\nまた、Mattermost Enterpriseプラン限定の機能ですが、通話の記録を動画ファイルとして残す機能も追加されています。\nRecord calls\nMattermost Cloudを使えばすぐにCalls機能を利用することができますが、Cloud Freeプランでは参加者の上限が8名に制限されています。 Cloud Professional/Enterpriseプランでは200名が上限です。\nChannels: Mattermost モバイルアプリ v2 Mattermostのモバイルアプリのメジャーバージョンアップである v2.0 がリリースされました。\nこのリリースには、モバイルアプリに対して最も要望の多かった複数サーバーの管理機能が追加されています。\nYouTubeで新しいモバイルアプリの紹介動画が公開されています。\n  Mattermost Mobile v2.0にアップデートする場合、接続するMattermost Serverのバージョンはv7.1以降である必要があるため、事前にMattermost Serverのバージョンを確認することをお勧めします。\nPreparing for Mobile v2.0 - Mattermost\n What server versions are supported by v2.0?\nMattermost Server v7.1+ is required.\n Channels： メッセージの優先度設定と既読確認 Mattermostにメッセージを投稿する際、そのメッセージの優先度を設定できるようになりました。この機能は、システムコンソール \u0026gt; サイト設定 \u0026gt; 投稿 \u0026gt; メッセージの優先度から有効にすることができます。\nメッセージの優先度機能を有効にすると、メッセージ入力欄の左部に優先度を設定するためのアイコンが表示されます。\n設定できる優先度は、標準(Standard)、重要(Important)、緊急(Urgent)の3種類です。(優先度を設定しない通常のメッセージは標準(Standard)になります)\n標準以外の優先度を設定して投稿すると、メッセージの上部に選択した優先度が色付きで表示されるため、重要なメッセージを一目で認識することができるようになります。\nまた、Professionalプランでは、メッセージに対する確認を要求することもできます。\n確認を要求するをONにしてメッセージを投稿すると、他のユーザーには　確認 ボタンが表示されるようになります。\n確認 ボタンを押すと、確認済みのユーザー数がカウントアップされます。マウスを当てると、誰が確認済みかを表示することができます。\nPlaybooks: 既存チャンネルでのPlaybookの実行 今までのバージョンでは、Playbookを実行すると新しいチャンネルが自動で作成されていましたが、今回のバージョンから既存のチャンネル内でPlaybookを実行できるようになりました。\nまず、チャンネル右部に表示されているPlaybooksのアイコンをクリックすると、現在、このチャンネルで実行中のPlaybookを確認することができます。(システムコンソール \u0026gt; 実験的機能 \u0026gt; 機能 \u0026gt; App Barを有効にするが無効になっている場合、チャンネル右部にPlaybooksのメニューは表示されず、チャンネルヘッダ部分にPlaybooksアイコンが表示されているはずです)\nここで、右サイドバー上部に表示されている 実行開始 ボタンをクリックすると、Playbookを開始することができます。\n開始したいPlaybookを選択すると、次に実行の詳細を入力する画面が表示されます。\nこの時、既存のチャンネルとリンクするを選択し、Playbookを実行したいチャンネルを選択してから 実行開始 を押すことで、新規にチャンネルを作成することなく既存のチャンネル内でPlaybookを開始することができます。\n既存のチャンネル内にPlaybookの実行が追加され、このチャンネルの中で実行の状況を追跡することができます。\nPlaybooks: タスクリスト Playbooks画面の右上にあるタスクアイコンをクリックすることで、自分が関係しているタスクの一覧を確認することができるようになりました。\nフィルターメニューから、以下のタスクの表示/非表示を切り替えることができます。\n 所有する実行からすべてのタスクを表示する: 自分がオーナーとして参加しているPlaybook実行のすべてのタスクを表示する チェック済みのタスクを表示する: 完了としてチェック済みのタスクも表示する  Boards: ファイル添付 Cardにファイルを添付することができるようになりました。\nCard画面の上部に表示されている Attach メニューからファイルを選択することで添付を行うことができます。\nアプロードされたファイルは、Card内のAttachmentセクションに表示され、ここからダウンロードや削除を行うことができます。\nIntegrations: ServiceNow Channel integrations, GitLab Playbooks integration 今回のリリースブログでは、ServiceNow連携機能とGitLab連携機能の紹介が行われています。\nServiceNowr連携機能では、ServiceNowのITSM機能と連携し、特定のイベントが発生した際にMattermostに通知したり、MattermostからITSMレコードへのコメント追加等を行うことができるようです。また、MattermostのPlaybooks機能と連携することで、インシデント対応時のコミュニケーションを円滑に行うことができます。\nまた、ServiceNow Virtual Agentを使うことで、ServiceNowのAIチャットボット機能であるVirtual AgentをMattermostに組み込むことができます。\nServiceNow連携についてはYouTubeで紹介動画が公開されています。\n  GitLab Pluginは、最新バージョン(v1.6)でGitLab Pipelineとの連携が強化され、MattermostのPlaybooksk機能と連携することで、プロダクトのリリース管理をより効率的に行うことができるようになったようです。\nGitLab Plugin - Mattermost\nその他の変更 下書きの保存 編集途中のメッセージを管理する 下書き 機能が追加されました。下書きは、チームごとに管理されます。\nシステムコンソール \u0026gt; サイト設定 \u0026gt; 投稿 \u0026gt; 下書きのサーバーへの同期を有効にするを有効にすることで、下書きの情報をサーバーに保管できるようになり、編集を開始した端末とは別の端末からでも下書きにアクセスできるようになります。(ただし、モバイルアプリでは下書き機能自体がないようです)\nシステムコンソールでこの設定を有効にした場合でも、設定 \u0026gt; 詳細 \u0026gt; メッセージの下書きをサーバーと同期するからユーザーごとにOn/Offを切り替えることができます。\nフリープランでもMy Insightが利用可能に 今までは有償版でのみ利用可能であったインサイト機能のうち、自分のアクティビティに関係する 私のインサイト 機能がフリープラン(無償版)でも利用可能になりました。\n自分がよく活動するチャンネルやPlaybook、よく使うリアクション、また、活動の少ないチャンネル等を確認することができます。\nアップグレード時の注意事項 アップグレード時の注意事項について、詳しくは公式ドキュメントを確認ください。　Important Upgrade Notes\nWebappコンポーネントを含むPlugin 今回のリリースから依存するReactのバージョンがReact 17になった影響で、もしPluginがReact 16を使用してビルドされている場合、バージョン不整合によりMattermostがクラッシュする恐れがあります。Mattermost公式のPluginテンプレートであるmattermost/mattermost-plugin-starter-templateを利用している場合、この問題の影響を受ける可能性があります。\n回避策としては、このPRを参考に修正を行なって再度Pluginをビルドし直すか、一時的な回避策としてシステムコンソール \u0026gt; 実験的機能 \u0026gt; 機能 \u0026gt; プラグインが使用するReact DOMにパッチを当てるを有効にすることで回避することができます。\nCalls機能の最低動作バージョン Calls機能専用サーバーであるrtcdを利用してCalls機能を動作させている場合、今回のリリースからrtcdの最低動作バージョンが設定されるようになりました。Mattermost v7.7に組み込まれているCalls機能ではrctd v0.8.0を要求し、これ以下のバージョンで動作している場合はCalls機能が動作しません。\nMySQLでのシステムタイムゾーン設定時の問題 Mattermostが利用しているMySQLがシステムのタイムゾーンを参照しており、かつ、システム側で設定されているタイムゾーンがMySQLでサポートされていなかった場合、エラーが発生する可能性があります。この問題はタイムゾーンテーブルを入力することで回避することができます。\nThreadsテーブルの非正規化 ThreadsテーブルにTeamIdが追加され、非正規化されることになりました。これによるデメリットは無いとされています。\nその他のトピック Roadmap Mattermostの各機能のRoadmapは、下記の公式チャットで毎月共有されています。\nhttps://community.mattermost.com/core/channels/roadmap\nMattermostのチャット機能では、再来月(2023/03)リリース予定のv7.9で、メッセージに対する確認を定期的に要求する機能が追加されるようです。\nこの機能は今回リリースされたメッセージへの確認要求に付随する機能になるため、Professionalプラン以上で利用可能になるようです。\nChannels: January 2023 Roadmap Update\nMattermost関連の記事紹介  Zapierを使ってQiitaに投稿したらMattermostに通知を飛ばす - Qiita  MattermostのOAuth 2.0アプリケーション機能を使った連携方法の紹介です   ansibleでディスク使用率監視とMattermostへの通知 - Qiita  MattermostのWebHookを使った連携方法の紹介です   Growiの更新をIFTTTを使ってMattermostに通知する - Qiita  MattermostのWebHookを使った連携方法の紹介です    おわりに 次のv7.8のリリースは 2023/02/16(Thu)を予定しています。\n元々、今回のv7.7がESR(Extended Suport Release)となる予定でしたが、v7.6のリリースがスキップされた影響で多くの機能がv7.7でリリースされることになったため、次のESRはv7.8とするよう決定されました。\n"},{"ref":"https://blog.kaakaa.dev/post/tech/git-fetch-specific-commit-depth-1/","title":"go-gitで特定のコミットをDepth=1でCloneする","section":"post","date":"2023.01.05","body":"背景 大きなGitリポジトリをCloneする際に --depth \u0026lt;depth\u0026gt; オプションを使用すると、指定した数だけの履歴を持つShallow Copyを取得するようになり、Cloneにかかる時間を短縮することができる。\nしかし、 HEAD ではないある特定のコミット時点のリポジトリを取得したい場合、 git clone コマンドにはCommit Hashを指定してリポジトリを取得するオプションがないため、結局 git clone の --depth オプションは使用できず、全ての履歴を取得した上で git checkout \u0026lt;sha1\u0026gt; などでリポジトリの履歴を戻す必要がある。(例えば、リポジトリマイニング的な事をするためにGitHub APIでリポジトリの各Release時点のコミットIDは分かっている、という状況を想定)\n解決方法 手順は増えるが、 git fetch ならば --depth を使用でき、かつCommit Hashを指定して特定のコミット時点のリポジトリの情報を取得できるため、やりたい事を実現することができる。\n$ git init $ git remote add origin https://github.com/$OWNER/$NAME $ git fetch --depth 1 origin $SHA1 $ git checkout FETCH_HEAD 参考: 20211018: git - commit hash 値で shallow clone - PIB\ngo-gitを利用したコード go-git を使用してこれを実現しようとする場合、 git fetch に直接Commit Hashだけを指定することはできない(?)ため、Refspecを指定する形に変更する必要があった。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/go-git/go-git/v5\u0026#34; \u0026#34;github.com/go-git/go-git/v5/config\u0026#34; \u0026#34;github.com/go-git/go-git/v5/plumbing\u0026#34; ) const ( url = \u0026#34;https://github.com/matterpoll/matterpoll\u0026#34; sha string = \u0026#34;a62dbe0410aa0836cd4b26e75f9319a952ff153d\u0026#34; ) func main() { // git init  repo, _ := git.PlainInit(\u0026#34;work\u0026#34;, false) // git remote add origin https://github.com/owner/name  remote, _ := repo.CreateRemote(\u0026amp;config.RemoteConfig{ Name: \u0026#34;origin\u0026#34;, URLs: []string{url}, }) // git fetch --depth 1 origin $SHA1:refs/heads/target  var target = plumbing.NewBranchReferenceName(\u0026#34;target\u0026#34;) _ = remote.Fetch(\u0026amp;git.FetchOptions{ RemoteName: \u0026#34;origin\u0026#34;, RefSpecs: []config.RefSpec{ config.RefSpec(plumbing.ReferenceName(sha) + \u0026#34;:\u0026#34; + target), }, Depth: 1, }) // git checkout target  tree, _ := repo.Worktree() _ = tree.Checkout(\u0026amp;git.CheckoutOptions{Branch: target}) } 上記のGoコードを実行すると、1コミットのみを持つGitリポジトリが取得できている。(go.mod 等の記述は割愛)\n$ go run main.go $ cd work $ git log commit a62dbe0410aa0836cd4b26e75f9319a952ff153d (grafted, HEAD -\u0026gt; target) Author: Yusuke Nemoto \u0026lt;kaakaa@users.noreply.github.com\u0026gt; Date: Mon Apr 29 05:31:07 2019 +0900 Release 1.1.0 (#150) $ "},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-7.5/","title":"Mattermost 7.5の新機能","section":"post","date":"2022.11.19","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2022/11/16 に Mattermost のアップデートとなる v7.5.0 がリリースされました。 また、同日にUbuntu 18.04環境でアップグレード時に発生する問題の修正を含む v7.5.1がリリースされています。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v7.5 is now available - Upgrade your deployment today Mattermost self-hosted changelog   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Free版も利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard) Platform: 上記機能を含むMattermost全体  Calls: メッセージスレッド Calls機能を利用中に、スレッド形式でメッセージをやり取りできるようになりました。\nCallsのメッセージスレッドでは、通常のメッセージスレッドと同様に絵文字リアクションや@メンションを利用することができます。\nメッセージスレッドを利用するには、Callへ参加し、Windowsモードにし、コメントアイコンをクリックすることで、メッセージスレッドを開くことができます。\nこのスレッドでのやり取りは、通常のメッセージスレッドと同様、チャンネルに残ります。\n Mattermost Cloudの方でCallsプラグインを v0.10.0にアップデートしたところ、Webブラウザ/Decksopアプリからはコメントアイコンが表示されず、モバイルアプリ v2 (Beta)の方では チャットスレッド のメニューが表示されるという状態でした。\n一方、公式のCommunity向けMattermostの方で試したみたところ、Webブラウザ/Desktopアプリではコメントアイコンが表示され、モバイルアプリの方では チャットスレッド のメニューが現れないという状態でした。\n一応ブラウザのキャッシュ削除等は試してみたのですが解消せず、ちょっと原因がわかりませんでした。\nBoards: ボードテンプレートの追加 ボードを新規に作成する際に選択できるテンプレートに、新たに以下の6つが追加されました。\nCompany goals \u0026amp; OKRs\n組織のゴールや、OKRの管理を行うためのテンプレートです。\nObjective(目標)ごとにタスク(カード)を作成し、Target/Actual/Competion等のプロパティで達成度合いを管理することができます。また、QuarterやDepartment(部署)ごとにタスクを一覧化できるビューもデフォルトで作成されます。\nCompetitive analysis\n競合分析用のテンプレートです。\n競合企業の情報 (Website, Location, Revenue,\u0026hellip;) や各企業のMarket Positionなどを一覧化することができます。Market Positionごとにカードを並べたビューもデフォルトで作成されます。\nSales pipeline CRM\nセールスの状況を管理するためのテンプレートです。\n各顧客に関する情報や商談の状況などを一覧化することができます。商談の状況(Open Deals)や商談フェーズ(Pipeline Tracker)ごとにタスクを一覧化できるビューもデフォルトで作成されます。\nSprint planner\nスプリント計画やリリースに向けたタスク管理を行うためのテンプレートです。\nスプリントごとのタスク一覧を管理することができます。タスクの状況(Status)やタスクの種別(Type)ごとにタスクを一覧化できるビューもデフォルトで作成されます。\nTeam retrospective\nうまく行ったことや改善点など、将来に向けた振り返りを行うためのテンプレートです。\nUser research sessions\nユーザーリサーチの状況を管理するためのテンプレートです。\nユーザーへのインタビュー状況を一覧で管理することができます。インタビュー予定(Date)や状況(Status)ごとにタスクを一覧化するビューもデフォルトで作成されます。\nBoards: テキストプロパティでのフィルタリング ボード内のカードをフィルタリングをする際に、以下のプロパティの値でフィルタリングできるようになりました。\n Text Email Phone URL  Boards: ボードの統計情報 システムコンソール \u0026gt; サイトの使用統計に、ボードに関する統計情報が表示されるようになりました。ボード数とカード数が表示されるようになります。\nMattermost CloudのFreeプランではカード数の上限が 10,000 までに設定されているため、Freeプランの上限を超えないためにカード数の総数を把握しやすくなったのは良いことだと思います。\nChannels: 最終活動日時の表示 ユーザープロフィールを表示するポップアップに、そのユーザーが最後に活動した時間が表示されるようになりました。 ステータスがアクティブでないユーザーのみ表示されます。\nこの機能は システムコンソール \u0026gt; サイト設定 \u0026gt; ユーザーとチーム \u0026gt; 最終活動日時を有効にする から無効化することもできます。\nまた、設定 \u0026gt; 表示 \u0026gt; 最終活動日時を共有するから、ユーザーごとにこの情報を表示しないよう設定することもできます。\nPlatform: Desktop v5.2 Mattermost Desktopアプリv5.2 がリリースされました。\nファイルダウンロード状況の表示 ファイルダウンロードの状況を表示するダイアログが追加されています。\nメッセージの翻訳 デスクトップアプリのメニュー等がローカライズされるようになりました。日本語にも対応しています。\nPlatform: Mobile App v1.55.1 (ESR) 9月にリリースされたv1.55.1が、モバイルアプリとしては初めてのESR(Extended Support Release)として設定されました。このバージョンは2023/06までサポートされます。\nモバイルアプリのメジャーバージョンアップであるv2.0が12月にリリース予定となりますが、モバイルアプリのカスタムビルドを利用しているユーザーのための経過措置になります。\nアップグレード時の注意事項 DBマイグレーション Postsテーブル内のParentIDカラムを削除するDBマイグレーションが実行されますが、MySQLを利用している場合、Postsテーブルのサイズによってはこの処理によってCPU使用率が上昇する場合があります。 また、このマイグレーション実行中は書き込みが制限されます。\nWebappプラグイン PluginRegistry.registerCustomRouteを利用したプラグイン開発を行なっている場合、CSSgrid-area: centerが設定されていないとコンポーネントが適正な位置に表示されなくなります。\nその他の変更 Starterプランの名称がFreeに変更 今まで、Mattermostの無償プランはStarterプランと呼ばれていましたが、これからはFreeプランと呼ぶようになりました。\n未読チャンネルをフィルタするためのショートカットが追加 未読のチャンネルのみを表示するためショートカットとして Ctrl/Cmd + Shift + Uが追加されました。\nその他のトピック Mattermost関連の記事紹介 Mattermost構築  【Tool】Mattermostのセルフホスティングを導入してみる | willserver for tech-future  AWS LightsailにMattermostを構築する手順について   【Tool】Mattermostクライアントインストール手順(Windows、macOS、Linux) | willserver for tech-future  Mattermost Desktopアプリ(Windows/Linux/macOS) のインストール方法について   Slackの投稿データをMattermostに移行してみる - Qiita  SlackのデータをMattermostへ移行する方法について    Mattermostの紹介  Mattermost〜OSSのチャットツール〜 | OSSのデージーネット  Mattermostの概要・機能紹介    おわりに 次のv7.6のリリースは 2022/12/15(Thu)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-7.4/","title":"Mattermost 7.4の新機能","section":"post","date":"2022.10.15","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2022/10/14 に Mattermost のアップデートとなる v7.4.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v7.4 is now available - Mattermost Mattermost self-hosted changelog   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(OSS 版)でも利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard) Platform: 上記機能を含むMattermost全体  Calls: キーボードショートカットが利用可能に Calls機能の操作を行うためのキーボードショートカットが追加されました。 ミュート解除やスクリーン共有などの操作をする際にマウスを操作する必要がなくなるので、キーボードから手を離す必要がなくなります。\n現在サポートされているキーボードショートカットは以下の通りです。\nKeyboard shortcuts for Channels\nBoards: Commenter/Viewerロールの追加 Boardsの権限ロールに、コメントの追加が可能なCommenterと、Boardおよびその内容の閲覧のみが可能なViewer が追加されました。これらの権限が追加されたことで、Board内容の意図せぬ変更の可能性を減らすことができるようになります。\nBoardsに対する権限ロールの設定は、Boards画面右上の Share ボタンから行うことができます\n 現在、Commenter の日本語訳が コメントした人 となっていますが、次バージョンではコメンターに修正されているかと思います。\nまた、 Viewer(閲覧者)以外のロールが設定されたユーザーのロールを変更しようとすると、Viewer(閲覧者)の表示位置がずれてしまいます。\nこちらについても既に修正済みのため、次バージョンで修正されているかと思います。\nFix misaligned \u0026lsquo;viewer\u0026rsquo; role on share board/template dialog by vivekkj123 · Pull Request #3926 · mattermost/focalboard\nBoards: ゲストアカウントでもBoards機能が利用可能に Mattermostには昔から組織外のユーザー用にゲストアカウントを作成する機能がありましたが、本バージョンからゲストアカウントもBoardにアクセスできるようになりました。　ただし、正規のユーザーとは異なり「新しいBoardの作成は行えない」や「Boardの管理者権限は付与できない」などの制限があります。詳しくは公式ドキュメントを参照してください。\nBoards: メンバー追加時に自動補完リストが表示されるように Cardの内容やコメントを追加する際に @ を入力することで、ユーザーの自動補完リストが表示されるようになりました。\nもし、Boardのユーザーではないユーザーの場合、自動補完リストのユーザー名の横に (not board member) と表示されます。\nまた、このユーザーに対する@メンションを行おうとすると、そのユーザーの権限を設定するダイアログが表示されます。\nこれにより、@メンションの対象となったユーザーをBoardに追加するとともに、そのユーザーの権限も同時に設定することができます。\nこの自動補完リストは、Cardのプロパティでも動作します。\nBoards: Boardのリンク/リンク解除操作がチャンネルに通知されるように ChannelsのAppBar(右サイドバー)からチャンネルをBoardにリンク、もしくはチャンネルとのリンクの解除を実行すると、チャンネルに通知メッセージが投稿されるようになりました。\nBoards: Multi-personプロパティの追加 Cardのプロパティに複数のユーザーを指定できる Multi-person というプロパティ種別が追加されました。\n今までのバージョンでは、一人のユーザーのみ指定できる Person タイプしか選択できませんでした、そのため、例えばCardに対する担当者(Assignee)を複数人設定したい場合は、複数のプロパティ(Assignee1, Assignee2, \u0026hellip;)を作成する必要がありました。しかし、Multi-personが追加されたことで、一つのプロパティで複数人の担当者を扱えるようになります。\nその他の変更 メッセージ転送機能における日本語入力時の不具合改善 Mattermost v7.2で追加されたメッセージ転送(Message Forwarding)機能にて転送メッセージを日本語で入力する際、入力確定の Enter を押下すると、意図せずメッセージ転送が実行されてしまうという不具合がありました。\nMattermost 7.2の新機能 - 注意: 日本語入力時の不具合について\nこの不具合はv7.4で解消されました。\nUnable to add Japanese comments correctly in Message Forwarding Dialog · Issue #20838 · mattermost/mattermost-server\nその他のトピック Hacktoberfest 今年もMattermostはHacktoberfestに力を入れています。\nHacktoberfest is here again! - Mattermost\nHacktoberfestの期間中(10月中)にMattermostへのコントリビューを行うと、オリジナルのステッカーが貰えるそうです。また、期間中のトップコントリビューターに選ばれると、Tシャツやマグカップ等も貰えるようです。\nMattermost関連の記事紹介 Mattermost構築  Mattermost を Docker でローカルサーバにインストール - Qiita  mattermost/dockerを利用したMattermost構築方法について   MattermostサーバをGCPパッケージを使って構築する - Qiita  GCPにMattermostを構築する手順について   森　崇さんはTwitterを使っています: 「仕事でmattermostに大量のユーザ/ポストを登録必要があり、バッチ・スクリプト群を一般公開ししました。 負荷テストやるときに便利と思います〜。 https://t.co/0ErNlJhI2w #mattermost」 / Twitter  Mattermostに任意のデータを一括登録するスクリプトの紹介    Tech  Mattermost サンプルデータの作成  公式CLIツール(mmctl)を使ったMattermostサンプルデータの自動生成について   Mattermost 投稿内容の出力  公式CLIツール(mmctl)を使ったMattermost投稿データの取得について   Mattermost 投稿数順に集計して通知  投稿数ランキングをMattermostで通知する方法について (Python)   Mattermot APIのPHPドライバを Laravel で実行する手順 - Qiita  Mattermost PHPドライバ (コミュニティ製) の実行方法の紹介    おわりに 次のv7.5のリリースは 2022/11/16(We)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-7.3/","title":"Mattermost 7.3の新機能","section":"post","date":"2022.09.19","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2022/09/16 に Mattermost のアップデートとなる v7.3.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v7.3 is now available - Mattermost Mattermost self-hosted changelog   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(OSS 版)でも利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard) Platform: 上記機能を含むMattermost全体  Boards: Roleベースの権限設定 今までBoards機能の各ボードの権限はMattermostのチャンネルに基づいて管理されていましたが、今回のバージョンからRoleベースの権限管理に変更されました。\nボード画面の右上に表示される 共有 ボタンから、ボードに対する権限設定を行うことができます。\nチーム全体に対する権限と、チャンネル・ユーザーごとの権限を設定できるようになっています。\nユーザーに対する権限は、ボードの内容を編集できる「編集者(Editor)」と、それに加えてボードの権限設定まで行うことができる「管理者(Admin)」から選択できます。また、今後のリリースでは、コメントの追加のみ可能な「Commenter」とBoardの閲覧のみ可能な「Viewer」の権限が追加される予定です。\nMattermostチャンネルのメンバー全員に権限を与えるには、ボードをMattermostチャンネルにリンクする必要があります。ボードとのリンクを行うと、そのMattermostチャンネルのメンバー全員にボードに対する 編集者(Editor) 権限が付与されます。ボードは一つのMattermostチャンネルとリンクすることができ、Mattermostチャンネルとボードをリンクすると、チャンネル画面の右サイドバーにリンクされたボードの一覧が表示されるようになります。\nボードの共有メニューでは、リンク済みのチャンネルに対する リンク解除(Unlink) を実行することができます。既にMattermostチャンネルにリンクされてるボードを別のMattermostチャンネルにリンクしようとすると、元々リンク済みだったチャンネルとのリンクが解除されるという警告メッセージが表示されます。\nBoardの権限や共有の設定について、詳しくは公式ドキュメントを参照してください。\nSharing | What’s new in Mattermost Boards\nBoards: 新しいサイドバーナビゲーション Boardsのサイドバーが刷新されました。\n以前のバージョンでは、チャンネルごとにボードが設定されており、別のチャンネルにリンクされているボードを開くには、左上のメニューからチャンネルを切り替える必要がありました。\n今回のバージョンからボードを開く際にチャンネルを選択する必要はなくなり、Mattermostチーム内の全てのボードを一つの画面で閲覧できるようになりました。また、Channelsのサイドバーと同様、Ctrl+K / Cmd + Kのショートカットでチーム内のボードを検索することができ、さらに、カスタムカテゴリを作成してユーザー独自のグルーピングを行うことができるようになっています。\n新しいサイドバーについて、詳しくは公式ドキュメントを参照してください。\nNavigation | What’s new in Mattermost Boards\nBoards: カスタムテンプレートが簡単に共有可能に 以前のバージョンでは、Boardsのカスタムテンプレートを他のチームに共有しようとすると、一度Exportしてから別のチームでImportする必要がありました。\n今回のバージョンから、Boardsテンプレート編集画面の 共有 メニューから、Mattermost Workspace(インスタンス)内全員に対してテンプレートを公開することができるようになりました。また、ユーザーを指定して公開することもできます。(チャンネルは選択できないようなので、プレースホルダのメッセージは間違っている気がします)\nPlaybooks: サイドバーの刷新 Playbooks機能もサイドバーナビゲーションが刷新され、Mattermost Channels(チャット機能)と同様の見た目になりました。\n以前のバージョン(下画像・右)では、プレイブックと実行(Run)がそれぞれ全画面で表示されてるため、それぞれの内容を確認するためにはタブを切り替える必要がありました。今回のバージョン(下画像・左)からは、全てのプレイブックと実行(Run)をサイドバーから一覧することができるようになり、プレイブック・実行(Run)へのアクセスが容易になりました。\n今後、カスタムカテゴリによるグルーピング機能もリリース予定だそうです。\nPlatform: インサイト機能の改善 インサイトに表示される項目が追加されました。\n「新しいチームメンバー」では、Mattermostチームに新たに参加したユーザーを確認することができます。チームインサイトでは「新しいチームメンバー」が表示されますが、自分に関するインサイトである私のインサイト画面では、同じ場所に「もっともアクティブなダイレクトメッセージ」が表示され、DMのやり取りの回数の多いユーザーが表示されます。\n「最もアクティブでないチャンネル」では、活動の少ないチャンネルを確認することができます。活動の少ないチャンネルの情報は、再び投稿を作成して注意をひくよう計画したり、チャンネルを脱退するなどの判断に利用することができます。\n「トップPlaybooks」では、最も実行回数の多いプレイブックを確認することができます。\nその他の変更 (Enterprise) Channels: Call機能専用のCallサーバーが利用可能に Calls機能専用のrtcd(read-time communication daemon)サーバーが公開されました。MattermostサーバーからCalls機能の機能をrtcdサーバーに移譲することで、よりスケーラブルな通話環境を構築することができるようになります。\n詳しくは、公式ドキュメントを参照してください。\nCalls self-hosted deployment\nアップグレード時の注意事項 Boardsのマイグレーション 本バージョンから、Boards機能はチャンネルベースの権限管理からRoleベースの権限管理に移行します。Boardsごとの権限のマイグレーションはMattermostアップデート時に自動で行われますが、アップデート前にバックアップを実施することをお薦めします。\nBoards機能のアップデート内容について、詳しくは公式ドキュメントを参照してください。\nその他のトピック Mattermost関連の記事 先月に引き続き、Slackの料金改定に端を発するMattermostへの移行の流れの中で、Mattermostに関する記事を見かけることが多かったため、目にした範囲で紹介します。\nSlackからMattermostへの移行  MattermostをUbuntu環境にインストール - Qiita Slack から Mattermost へデータ移行 - Qiita GCP無料枠を使ってSlackからMattermostへ移行してみた｜あらB｜note  SlackからMattermostへの移行サポート  SlackからMattermostへの移行作業のサポートについて｜PressWalker  Mattermost構築  【Ubuntu】Mattermost をインストール - Qiita MattermostをGCP無料枠で試す - Qiita MattermostをUbuntu20.0.4 サーバにインストールする手順 - Qiita  Mattermost Integrations  GitHub ActionsからMattermostにCommit内容を通知する方法 | UmentuLab(Shintaro Tachibana)  おわりに 次のv7.4のリリースは 2022/10/14(Fri)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-7.2/","title":"Mattermost 7.2の新機能","section":"post","date":"2022.08.19","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2022/08/16 に Mattermost のアップデートとなる v7.2.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v7.2 is now available - Mattermost Mattermost self-hosted changelog   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(OSS 版)でも利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard) Platform: 上記機能を含むMattermost全体  Channels: メッセージ転送 (Message Forwarding) Mattermost内の投稿を他のチャンネルへ転送するメニューが追加されました。\nForward messages\nメッセージ転送機能を使わなくても、投稿のURLをMattermostへ投稿することでメッセージを別のチャンネルでプレビュー表示する機能はMattermost v6.0の時点で利用可能でした。しかし、このメッセージプレビューによる投稿内容の共有を行う場合、元の投稿のURLを取得・コピーし、転送先のチャンネルへ移動してURLを投稿する必要がありました。本バージョンで転送機能が実装されたことで、この作業が簡略化され、有益なメッセージを簡単に共有することができるようになります。\n 転送機能を利用するには、投稿のメニューから転送を選択します。\n表示されるダイアログに転送先チャンネルとコメントを入力し、転送を実行することで、転送先に指定したチャンネルに記入したコメントとともに投稿内容が転送されます。\n転送先チャンネルには、Mattermostインスタンス内の自分が参加しているチャンネルならばどのチャンネルでも指定することができます。また、以前にダイレクトメッセージ(DM)をやり取りしたことのあるユーザーに対しては、そのDMチャンネルを転送先として選択することもできます(手元の環境では、DMを送ったことのないユーザーとのDMチャンネルは転送先として指定できないようでした)。また、非公開チャンネルやDM/GM(グループメッセージ)チャンネルの投稿でも転送メニューを選択することはできますが、転送先チャンネルは指定することができず、その投稿の存在するチャンネルにしか転送することができません。\nまた、コメント入力欄は1行テキスト欄に見えますが、Shift+Enterを押すことで改行を行うことができ、Markdown記法も使用することができます。\n転送が完了すると、ダイアログで選択した転送先チャンネルに以下のような投稿が作成されます。\n元の投稿へのリンクURLは自動で挿入されます。\n注意: 日本語入力時の不具合について 現在、コメントを追加する前に転送先チャンネルを選択してしまうと、コメント入力中のEnterキー押下によってメッセージ転送が実行されてしまうバグがあるようです。日本語でコメントを入力する場合は、Enterキーを押さずに確定を行う（カーソルを押下することが確定するなど）か、転送先チャンネルを選択する前に入力を完了することで回避できそうです。\nUnable to add Japanese comments correctly in Message Forwarding Dialog · Issue #20838 · mattermost/mattermost-server\n(Enterprise) Platform: Audit Log v2 Beta システム管理者向けの監査ログの内容がアップデートされるようです。\nAudit log v2 (experimental)\n今回のアップデートでは、監査対象イベントの前後の状態の変化により焦点を当て、以前より多くのイベントのデータが記録できるようスキーマの変更が行われているようです。 以前のバージョンの監査ログを対象にアラート設定などを行なっている場合、今後Audit Log v2に合わせた修正が必要になります。\nその他の変更 Channels: 未読チャンネルを表示する際のスクロールポジション設定 未読の投稿が存在するチャンネルを開いた時のスクロール位置に関する設定が追加されました。設定 \u0026gt; 詳細 \u0026gt; 未読チャンネルを表示したときのスクロール位置 から設定を変更することができます。\nStart me where I left off (以前表示した位置から開始する)を選択すると、以前チャンネルを開いた時に表示していた位置に遡ってチャンネルが表示されます。Start me at the newest message (最新のメッセージから開始する)を選択すると、以前開いていた位置とは関係なく、常に最新のメッセージを開始位置としてチャンネルを表示します。\nアップグレード時の注意事項 スキーマ変更に係る所要時間 今回のバージョンアップでは、格納されるデータをより厳密なものにするためにデータベースのスキーマ変更が実行されます。スキーマ変更にかかる時間はチャンネル数に依存するようですが、10万チャンネル以上あるインスタンスでも10秒超ほどで完了するため、大きな問題にはならないかと思います。\nスキーマの変更内容と所要時間に関するテスト結果については以下のリンク先を参照してください。\nImportant Upgrade Notes\nその他のトピック Slack料金改訂に伴いMattermostへの言及が増加 2022/07/18にSlackが料金改訂を行うことを発表しました。\n中でもフリープランのメッセージ上限が10,000件から90日間に変更されたことの影響が大きいようで、フリープランを利用していたSlackユーザーの方々が代わりのチャット基盤となり得るチャットツールを探し、SNS等でそれらのツールに対する言及するといったことが多く行われていました。\nそれに合わせ、ここ１ヶ月ほどでMattermostを紹介する記事がいくつも公開されていたため、見つけた範囲でまとめてみました。\nMattermostnの紹介およびセットアップ手順に関する記事\n 第726回　Slackの代替として、ハドルミーティングも実装されたオープンソース版のMattermostはいかが？ | gihyo.jp チャットツールMattermostとは？使い方や評判、無料で出来ることを紹介 - TravelWork Slack フリープランが改悪したので Mattermost をインストールしてみた - Qiita WSL2 Ubuntu で Mattermost Preview を試す Mattermost を Docker で試験導入する (Docker Image 版)  SlackからMattermostへの移行に関する記事\n SlackからMattermostへの移行 - Qiita Slack から Mattermost へ移行  Mattermost利用者向けサポートサービスに関する記事\n 【インターネットにつながってなくても使える】NASAがSlackの代わりに使うビジネスチャット「Mattermost」を知ってほしい。｜リックソフト：Jira,Slack, WorkatoなどBtoB「仕事を楽にする」ITツール導入支援 SlackからMattermostの切り替えサポートについて｜PressWalker  Mattermost Pricingページの記載内容に一部誤解を招く表現があることについて MattermostのPricingページの記述を確認すると、Self-hostedのStarterプラン(無償利用)でも、アクセスできるメッセージ履歴の数に制限があるように読めてしまうようです。\nPricingページのStarterプランの説明に、メッセージ履歴は最新の10,000件しかアクセスできないというような表記があります。この制限は、Cloud版のStarterプラン利用時のみの制約であるはずですが、PricingページはSelf-hosted版とCloud版について記載を分けていないようなので、この制限がSelf-hosted版にも適用されるように見えてしまいます。\nまた、Pricingページ末尾のFAQにも、「Self-hosted版とCloud版で料金の面で差異は無い」と書かれているため、Pricingページの記載だけを読むと、やはりSelf-hosted版にもデータ制限があるように読めてしまいます。\nこの点についてMattermost公式チームに問い合わせてみましたが、やはりデータ制限はCloud版のみの話で、Self-hosted版には特にMattermostとしてデータ制限は無いはずとの回答をもらいました。\nPricingページの記載内容についても見直してくれるそうです。\nRoadmap Channels: 今後追加される予定の機能について 毎月、Mattermost公式コミュニティサーバーのRoadmapチャンネルにて、Mattermostプロダクトの方向性についての情報共有が行われています。その中から、Mattermostのチャット機能であるChannelsに追加される予定の機能を紹介します。\n参考にしたのは以下の資料で、誰でもみれる形で公開されています。\nJuly 2022 - Channels Roadmap Update - Viewer Copy - Google スライド\nまず、Global Draftsです。\nGlobal Draftsでは、Mattermost上でメッセージを投稿しようとして途中で入力を中断した場合などに、その書きかけのメッセージを集約してくれる機能です。\n今までのバージョンでも、書きかけのメッセージがある場合、左サイドバーでそのチャンネルのアイコンが鉛筆アイコンに変わることで目視することはできましたが、参加するチャンネルが多い場合は見つけづらいなどの難点がありました。Global Draftsによって、急な対応が必要になった場合でも、すぐに書きかけのメッセージに戻ることができそうです。\nもう一つはMessage Priority \u0026amp; Acknowledgementです。\nこの機能により、Mattermost内の投稿に対する注目度をさまざまな形式で設定できるようになりそうです。\nMessage Priorityでは、メッセージの重要度をStandard、Important、Urgentなどの形式で設定できるようになるようです。\nまた、Request acknowledgementでは、メッセージの既読チェックに使えるボタンが付与されるようです。今までは絵文字リアクションで行なうことが多いかと思いますが、公式の機能としてサポートされるようです。\n最後に、Message PriorityをUrgentに設定した投稿は、acknowledgeか返信が行われるまで5分ごとに通知が行われるようにすることもできるようです。\nこれらの機能について、実装されたらまた紹介したいと思います。\nおわりに 次のv7.3のリリースは 2022/09/16(Fri)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/tech/enhancement-mattermost-japanese-search/","title":"Mattermostの日本語検索を改善するためにBleveSearchを少し調査した","section":"post","date":"2022.08.16","body":"背景: Mattermost Bleve検索 2021/06にリリースされたMattermost v5.24から、Bleveによるメッセージの日本語検索が利用できるようになった。\nBleve search (experimental)\nそれ以前のバージョンでは、Mattermostセットアップ時にDB(MySQL, PostgreSQL)の設定に手を加える必要があったが、Bleveによる検索機能が公式にサポートされたことで、システムコンソール画面からいくつか設定を変更するだけで日本語検索が実現できるようになった。嬉しい。\n問題: 意図せぬ投稿が検索される Bleve検索自体はとても便利な機能だが、その検索結果に少し問題がある。\n2文字以上の単語で構成される日本語クエリによるBleve検索をおこなった際、本来ならばその単語が出現する投稿のみが検索結果として表示して欲しいところだが、実際の検索結果には、その単語内で使用されている文字が全て現れる投稿を検索してしまう。\n例えば、「メロスは激怒した。必ず、かの邪智暴虐の王を除かなければならぬと決意した。」という投稿があったとする。\n「激怒」「邪智暴虐」などの単語で検索を行うと、想定通りこの投稿を検索することができる。しかし、「激暴」という単語で検索を行った場合も、この単語自体は対象の投稿に存在しないにも関わらず、単語を構成する「激」「暴」の両方の文字が投稿に含まれているため、対象の投稿が検索結果として表示されてしまう。\nこの問題を改善するため、調査を行った。\n調査1: Bleveのcjk言語向けAnalyzer まず、Mattermost側でBleveをどのように使用しているかを調べる。\n投稿内容のインデックスは、以下で定義されている。\n... import ( ... \u0026#34;github.com/blevesearch/bleve/v2/analysis/analyzer/standard\u0026#34; ... ) ... func init() { ... standardMapping = bleve.NewTextFieldMapping() standardMapping.Analyzer = standard.Name ... } ... func getPostIndexMapping() *mapping.IndexMappingImpl { postMapping := bleve.NewDocumentMapping() ... postMapping.AddFieldMappingsAt(\u0026#34;Message\u0026#34;, standardMapping) ... } https://github.com/mattermost/mattermost-server/blob/5ea2ca8a3a25cb89b4cf52012ae3897d03e0a64f/services/searchengine/bleveengine/bleve.go#L79\nMattermostの投稿(Post)の内容(Message)は、Bleveのstandard.Nameで表されるAnalyzerによって解析されるようだ。Bleveについてあまり詳しくはないが、standard.Nameで表されるAnalyzerの内容を見ると、en.StopNameが使われており、英文を前提としたAnalyzerだと考えられるので、この部分が問題なのではないかと思う。\nhttps://github.com/blevesearch/bleve/blob/master/analysis/analyzer/standard/standard.go\nBleveのAnalyzerについて調べていると、cjk向けのAnalyzerもあることが分かった。\nhttps://github.com/blevesearch/bleve/tree/master/analysis/lang/cjk\n単純にMattermostの投稿内容のインデックスをBleveのcjk Analyzerを使って行うよう変更してみる。\n@@ -14,7 +14,7 @@ import (  \u0026#34;github.com/blevesearch/bleve/v2\u0026#34; \u0026#34;github.com/blevesearch/bleve/v2/analysis/analyzer/keyword\u0026#34; - \u0026#34;github.com/blevesearch/bleve/v2/analysis/analyzer/standard\u0026#34; + \u0026#34;github.com/blevesearch/bleve/v2/analysis/lang/cjk\u0026#34;  \u0026#34;github.com/blevesearch/bleve/v2/mapping\u0026#34; \u0026#34;github.com/mattermost/mattermost-server/v6/model\u0026#34; @@ -49,7 +49,7 @@ func init() {  keywordMapping.Analyzer = keyword.Name standardMapping = bleve.NewTextFieldMapping() - standardMapping.Analyzer = standard.Name + standardMapping.Analyzer = cjk.AnalyzerName  この変更を有効にしてMattermostを再起動し、Bleveインデックスを破棄→再構築すると、「激暴」という単語で当該の投稿が検索されなくなった。\nめでたしめでたし。\n\u0026hellip;とはならなかった。\n上記の変更を加えたことで、今度は1語による検索ができなくなった。\n「検索は2語以上で」という制限を設ければ問題は解決だが、この制限はあまり好ましくない。\n調査2: Bleve cjk Analyzerを使用した際に1語検索ができるようにする Bleveのcjk AnalyzerはTokenFilterとしてBigramを使用している。つまり、2語ずつインデックスを構築しているので、1語での検索ができないようだ。\n... const AnalyzerName = \u0026#34;cjk\u0026#34; func AnalyzerConstructor(config map[string]interface{}, cache *registry.Cache) (*analysis.Analyzer, error) { ... bigramFilter, err := cache.TokenFilterNamed(BigramName) if err != nil { return nil, err } rv := analysis.Analyzer{ Tokenizer: tokenizer, TokenFilters: []analysis.TokenFilter{ widthFilter, toLowerFilter, bigramFilter, }, } ... } ... https://github.com/blevesearch/bleve/blob/d89c6c0a6873fcca1673fb6e7e3128d39bc6494d/analysis/lang/cjk/analyzer_cjk.go#L40\nもう一度、Bleveのcjkパッケージを見てみるとoutput_unigramという設定があることに気づく。名前から、この設定をOnにしてインデックスを構築することで、1語のインデックスも出力されるようになるのではないかと予想する。(それによるインデックスサイズの増加についてはここでは考慮しないことにする)\n... func CJKBigramFilterConstructor(config map[string]interface{}, cache *registry.Cache) (analysis.TokenFilter, error) { outputUnigram := false outVal, ok := config[\u0026#34;output_unigram\u0026#34;].(bool) if ok { outputUnigram = outVal } return NewCJKBigramFilter(outputUnigram), nil } ... https://github.com/blevesearch/bleve/blob/d89c6c0a6873fcca1673fb6e7e3128d39bc6494d/analysis/lang/cjk/cjk_bigram.go#L185\noutput_unigramの設定をOnにする方法について色々調べてみたが、どうやってもOnにする方法が見つからない(これがこの記事を書くきっかけだったりする)。\n以下のItemNamed関数内で実行しているbuild(name, nil, cache)の第二引数が前述のCJKBigramFilterConstructor関数の第一引数 (config)になり、ここにoutput_unigram: trueが設定されていれば有効にできるらしいが、nilでハードコードされているのでどうしようもない。\nfunc (c *ConcurrentCache) ItemNamed(name string, cache *Cache, build CacheBuild) (interface{}, error) { ... // try to build it \tnewItem, err := build(name, nil, cache) ... } https://github.com/blevesearch/bleve/blob/d89c6c0a6873fcca1673fb6e7e3128d39bc6494d/registry/cache.go#L47\n自分が気づいていない方法があるのかも知れないが、調べていてもわからないので、output_unigramをtrueにしたAnalyzerを新たに登録し、それを使用してみる。\n@@ -13,9 +13,13 @@ import (  \u0026#34;time\u0026#34; \u0026#34;github.com/blevesearch/bleve/v2\u0026#34; + \u0026#34;github.com/blevesearch/bleve/v2/analysis\u0026#34;  \u0026#34;github.com/blevesearch/bleve/v2/analysis/analyzer/keyword\u0026#34; - \u0026#34;github.com/blevesearch/bleve/v2/analysis/analyzer/standard\u0026#34; + \u0026#34;github.com/blevesearch/bleve/v2/analysis/lang/cjk\u0026#34; + \u0026#34;github.com/blevesearch/bleve/v2/analysis/token/lowercase\u0026#34; + \u0026#34;github.com/blevesearch/bleve/v2/analysis/tokenizer/unicode\u0026#34;  \u0026#34;github.com/blevesearch/bleve/v2/mapping\u0026#34; + \u0026#34;github.com/blevesearch/bleve/v2/registry\u0026#34;  \u0026#34;github.com/mattermost/mattermost-server/v6/model\u0026#34; \u0026#34;github.com/mattermost/mattermost-server/v6/shared/mlog\u0026#34; @@ -44,12 +48,50 @@ var keywordMapping *mapping.FieldMapping  var standardMapping *mapping.FieldMapping var dateMapping *mapping.FieldMapping +const customCJKAnalyzerName = \u0026#34;custom_cjk_analyzer\u0026#34; +const customCJKTokenFilterName = \u0026#34;custom_cjk_filter\u0026#34; + +func CustomCJKAnalyzerConstructor(config map[string]interface{}, cache *registry.Cache) (*analysis.Analyzer, error) { + tokenizer, err := cache.TokenizerNamed(unicode.Name) + if err != nil { + return nil, err + } + widthFilter, err := cache.TokenFilterNamed(cjk.WidthName) + if err != nil { + return nil, err + } + toLowerFilter, err := cache.TokenFilterNamed(lowercase.Name) + if err != nil { + return nil, err + } + bigramFilter, err := cache.TokenFilterNamed(customCJKTokenFilterName) + if err != nil { + return nil, err + } + rv := analysis.Analyzer{ + Tokenizer: tokenizer, + TokenFilters: []analysis.TokenFilter{ + widthFilter, + toLowerFilter, + bigramFilter, + }, + } + return \u0026amp;rv, nil +} + +func CustomCJKBigramFilterConstructor(config map[string]interface{}, cache *registry.Cache) (analysis.TokenFilter, error) { + return cjk.NewCJKBigramFilter(true), nil +} +  func init() { + registry.RegisterTokenFilter(customCJKTokenFilterName, CustomCJKBigramFilterConstructor) + registry.RegisterAnalyzer(customCJKAnalyzerName, CustomCJKAnalyzerConstructor) +  keywordMapping = bleve.NewTextFieldMapping() keywordMapping.Analyzer = keyword.Name standardMapping = bleve.NewTextFieldMapping() - standardMapping.Analyzer = standard.Name + standardMapping.Analyzer = customCJKAnalyzerName  dateMapping = bleve.NewNumericFieldMapping() } 冗長だ。\n再びMattermostを再起動、Bleveインデックスの破棄→再構築を行い検索を実行すると、1語でも検索ができるようになった。\nおわりに というわけで、MattermostのBleveによる日本語検索の改善について調べてみた。\nとりあえず小さなサンプルでは実現可能なことが分かったが、output_unigramの設定のせいで修正量が多くなりそうなので、もう少し調査してからIssueで報告しようと思う。\n調査内容としては以下のあたりかな。\n 検索内容の正当性  日本語検索のテストセットが欲しいな\u0026hellip;   検索インデックスの容量増加  日本語の投稿がたくさんあるMattermostインスタンスのデータが欲しいな\u0026hellip;   blevexのkagomeを使用した検索  blevexのREADMEを見ると、Mattermost本体に組み込んでメンテし続けるのはちょっと怖い気がするな\u0026hellip;    Mattermostで実装するときは、Bleveの設定画面でAnalyzer選ぶような感じになるのかな。CJK以外でAnalyzer変更が必要な言語が無かったりすると、ちょっと独自改造っぽい感じになるので受け入れられにくそうな感じもするな。\n"},{"ref":"https://blog.kaakaa.dev/post/tech/copilot-rights/","title":"オープンソースの権利とGitHub Copilotについて調べたことと私見","section":"post","date":"2022.08.03","body":"はじめに AIによるペアプログラミングを掲げるGitHub Copilotが正式リリースとなった1。\nGitHub Copilotは、IDE上で自然言語でプログラムの情報を入力すると入力内容を満たすコード片を補完してくれるツールであるが、このコード片を生成するために用いられる機械学習モデルは、GitHub上で公開されているソースコードを元に学習されていると謳っている。\nGitHub上に公開されているソースコードは、何かしらのオープンソースライセンスの元で公開されているものが大半であるが、そのようなソースコードやそのソースコードから生成された成果物を利用する場合、オープンソースライセンスの求める条項に従う必要がある。GitHub上のソースコードはインターネット上に公開された情報であるため、機械学習の学習対象として使用することは “fair-use” として認められていると解釈するのが一般的であるとは思うが、学習によって得られたモデルから生成された成果物(ここではCopilotが提案するコード片)の権利や権利侵害については確たる結論がないというのが現状であると思う。そのため、Copilotが提案するコード片は、GitHub上に公開されている他のプロジェクトの権利を侵害する、もしくはそのプロジェクトの設定したオープンソースライセンスの条項に反する利用となる可能性を含んでいる。この問題についてはTwitterやブログ2などでも言及されている。\n弁護士プログラマによる GitHub Copilotの評価: Copilotが生成するコードが正しい保証はないし、つねにライセンス違反の危険があるため、多くの企業は使えないだろう。オープンソースはつねに明確なライセンスがあって機能してきた。だがCopilotにはそういうものが何もない。https://t.co/GHbcCBL1Nj\n\u0026mdash; 新山祐介 (Yusuke Shinyama) (@mootastic) June 29, 2022  本エントリでは、この問題に対してOpenAI社/GitHub社がどのような意見を持っているのかを調べ、また、プログラムの権利に関する判例やAI生成物に対する動向を元に、Copilotをどのように利用すべきかについての私見をまとめたものである。\n筆者は法律の専門家ではなく、また、AIを取り巻く権利関係についての知識も乏しいため、本エントリで述べることは単なる個人の見解・私見であり、誤りが含まれる可能性があることに注意されたい。現時点での理解をまとめるため、自分に向けて書き残しているものである。\nTL;DR; 長いので結論を先に。\n OpenAI社/GitHub社のCodex/Copilotに関する公開情報を見るに、両社とも学習元プロジェクトのコードと一致するコードが提案される可能性があることは認めているが、それが学習元プロジェクトの権利侵害に当たるとは考えていなさそう。 プログラムの著作物性に関する国内の判例をいくつか見るに、Codex/Copilotが提案する規模のコード片に対して、学習元となったプロジェクトがその著作物性を主張することは難しのではないかという感想を持った。 Codex/Copilotは学習元プロジェクトに対する権利侵害の恐れはないであろうという気持ちに傾いてはいるが、実際に企業で利用することを考えると、著作権の内国民優遇の特性やAI生成物の権利に関する議論を考慮した上で、利用には慎重になるべき だという考えを持った。 AI生成物の権利に関する議論が進み、AIとのペアプロが発展していくことを願っています。  前提: オープンソースソフトウェアと権利 本エントリでは、主に、Copilot利用者とCopilotサービス提供者、OSSプロジェクトの三者に共通して関連する権利として特許権と著作権を取り上げる。\n特許権では、「先願主義」「属地主義」が採用されており、特許庁への出願と審査請求を経て登録されることで権利が発生し、また、登録された特許であっても特許権の効力は出願先の国の領域内でのみ認められるものである。\n特許権により保護される技術は、新規性・進捗性のある”技術”であるため、プログラム自体が特許として認められることはまずない(と思われる)。つまり、2つのプログラムの見た目が異なっていたとしても、そのプログラムによって実現されるアイディア・アルゴリズム等が特許として登録されている技術と同一であると認められる場合は特許権侵害となり得る事になる。\n著作権は、ベルヌ条約/万国著作権条約により「無方式主義」「内国民待遇」が採用されているため、登録の必要なく認められる権利であり、かつ、条約加盟国間では外国で作成された著作物であっても内国著作物と同等の保護が保証されている。そのため、GitHub等でコードが公開されているプログラムは、どの国で作成されたものであっても等しく自動的に著作権で保護されることとなる。\nまた、著作権は、思想または感情を創作的に表現した著作物に対して与えられる権利であるため、特許権の場合とは違い、同一のアイディア・アルゴリズムを実現したプログラムであっても、その表現方法(プログラム)が異なれば個々のプログラムに著作権が発生し得る。\nGitHub上のプログラムについて考えると、上述の通り、著作権は公開した時点(厳密には作成した時点ではあると思うが)で発生する権利であり、その瞬間から著作権によって保護される著作物となる。\nしかし、公開されているプログラムを利用するために毎回著作権者の許諾を求めていてはソフトウェアの発展が妨げられてしまうため、オープンソースとして公開されているプロジェクトの多くは、著作物であるプログラムの自由な利用・改変・頒布等を一定の条件の元で認めることを表明するためにOSSライセンスを設置している。\nただし、OSSライセンスの中でも制限が緩いと言われているMITライセンスであっても、利用する側のプロジェクトに対して元のプロジェクトの著作権表示と許諾表示の記載を求めており、OSSのプログラムを利用する場合はほぼ必ず何かしらの対応を取る必要がある。 (数多く存在するライセンスの中には、何も対応を求めないライセンスもある3。また、それらのライセンスはOSDによる定義4に適合していないため、OSSとは言わないという話もある。細かい話をするとキリがないのでMIT, Apache-2.0, GPL等のメジャーなライセンスのみを頭に浮かべながら書いている。メジャーなライセンスとは何かという話も(ry。 )\n問題点: GitHub Copilotの学習元プロジェクトに対する権利侵害 2022/06にGitHub Copilotが正式サービスとしてリリースされた。\n「はじめに」でも述べたが、Copilot正式リリースが話題に上るとともに、Copilotが既存プロジェクトのコード片と合致するコードを提案する可能性があることへの懸念に関する言及も多くあった。\n後述するが、まず、GitHub等のインターネット上に公開されているデータを機械学習の用に利用することは\u0026quot;fair-use\u0026quot;である。また、サービス提供者であるGitHub/OpenAI社は、GitHub Copilotが提案するコード片をどのように扱うかについてはCopilot利用者側に責任があるとしており、Copilotを利用して開発されたソフトウェアに権利侵害が見つかった場合、それは利用者側の責任ということになる。これらの点については、調査の対象外とする。\n本エントリでは、「GitHub CopilotがCopilot利用者に対して提案するコードが学習元プロジェクトの権利侵害にあたらないか」という点について主に取り上げている。\n調査: 開発側(GitHub社, OpenAI社) の解釈についての推察 GitHub Copilotおよび、その裏で動いているOpenAI Codexを開発/提供しているGitHub社,OpenAI社がこの問題についてどのように捉えているのか、公開情報を元に調べてみた。\nOpenAI社 GitHub Copilotの裏で使われているOpenAI Codexについては2021/07に論文が公開されている。\n[2107.03374] Evaluating Large Language Models Trained on Code\n(その他、OpenAI社のブログにCodexに関する記事56が2本ほどあるが、求めているような情報はなかったため省略する)\n論文の内容は大体以下の通り。\nソースコードに特化していない普通のGPT-3でも簡単なプログラミングタスクを解くことができたことから「よりソースコードに特化した学習を行うことで多様なプログラミングタスクを解くことができるのではないか」という仮説の元、GitHubで公開されているソースコード等にfine-tuneされたGPT language modelとしてCodexを開発。本論文では、Pythonを対象言語とし、自然言語で書かれたdocstringから標準的なPython関数を生成できるかについて評価を行っている。生成されたプログラムの評価フレームワークとして HumanEval を提案し、データセットをGitHub上で公開している。\n本論文において、OSSライセンスや権利関係についての記述がないかみてみると、学習に使用したGitHub上のリソースについては 3.1. Data Collection に言及がある。\n 3.1. Data Collection\nOur training dataset was collected in May 2020 from 54 million public software repositories hosted on GitHub, containing 179 GB of unique Python files under 1 MB.\n この後にもファイルサイズやプログラムの性質によるフィルタリングについての言及があるが、学習元のプロジェクトのライセンス等への言及は特にない。\nまた、7.7. Legal implications にて、法的な問題について言及がある。ここが本題。\nまず、”インターネット上で公開されているデータセットをAIの学習に用いることは “fair-use” であると認定されている” 7 ことについて触れている。\n To begin with, the training of AI systems on Internet data, such as public GitHub repositories, has previously been identified as an instance of “fair use” (O’Keefe et al., 2019).\n これを元にすると、GitHubに公開されているコードを、そのコードがどんなライセンスの元で公開されていたとしても、学習に利用すること自体は “fair-use” であると考えられる。(「このプロジェクトのコードは機械学習に利用してはいけない」という条項を含むライセンスの元でコードを公開するというトロール仕草もあるだろうが、ここでは考えない。)\n余談だが、日本国内においても、平成30年5月に成立した「著作権法を一部改正する法律8」において著作物の利用に関する規定が変更され、情報解析の用に用いる場合は著作物であっても無許諾で利用できるようになっている。\n次に、Codexモデルが、稀に学習元と同じコードを提示してしまう事象について触れている。\n Our preliminary research also finds that Codex models rarely generate code that is identical to the contents of training data.\n これの原因として、学習元からそのままコピペしている訳ではなく、提示されたコードが学習時に何度も出現するようなプログラミング言語における一般的な表現や規約であるため、モデル内の予測的な重みづけによって学習データと同じようなコードが生成されることがあるということを挙げている。(後述のGitHub CopilotのFAQ 9 では、もう少し深くこの問題について触れている)\nこれは個人の感想だが、GPLでライセンスされたプロジェクト内のコードと同一の部分があったとしても、その部分がプログラミング言語における規約や標準的な記法の範疇と判断されるならば、開発者の創作性は認められず、GPLの求める一定の条件に従う必要はないのではないかと思う。元のプロジェクトと同一のソースコードが生成されたこと、それ自体が問題なのではなく、どのようなコードが生成されたのかによって扱いが変わる類の問題のように思う。\nまた論文では、生成されるコードはユーザーの入力によって変化するものであり、かつ、提示されたコードを編集したり受け入れたりするなどの最終的な判断はユーザー自身に委ねられている点についても触れている。\n Generated code is also responsive and customized to the user’s input, and the user retains complete control over editing and acceptance of the generated code.\n 穿った見方をすると、”OpenAI社は(場合によっては)著作権違反となるコードを提案しているのにも関わらず、利用者側にその責任をなすりつけようとしている”ようにも読めてしまうが、同じOpenAI社のDALL-E 2の生成物が商用利用可能となった10ことを考えると、OpenAI社としてはCodexにより提案されるコードもその著作権は利用者が有するものであると判断しているように個人的には思える。\nこの章の最後では「我々の責任ある安全なAIに対するコミットメントには、コード生成システムの広範な知的財産権に対する継続的な注意が含まれる」と述べられており、また、政策立案者(policymaker)との対話についても触れられている。\n Our commitment to responsible and safe AI includes continued attention to the broader intellectual property implications of code generation systems. We intend to remain engaged with policymakers and experts on these issues so that the users of such systems can ultimately deploy them with confidence.\n OpenAI社としても、現時点ではCodexの利用が権利侵害等に侵害等に繋がる事はないと判断しサービスのリリースは行なっているものの、未だ曖昧な部分はあると認識しており、今後、法整備等に向けた活動を行なっていくというところでは無いだろうか。(OpenAI社に肩入れした意見に見えることは認識している)\nGitHub Copilot 次にGitHub側の公開情報に権利関係の記述がないか調べた。\nCopilot内部で利用しているOpenAI Codexが提案するコードに仮に権利侵害の危険性があったとしても、実際に利用者に提案される前に内部的に棄却される仕組みを備えているのであれば、問題を回避できるていると考えられる可能性もある。\nCopilotに関する公開情報の中では、GitHub CopilotのFAQに関係しそうな記述があったため、いくかFAQを取り上げる。\nGitHub Copilot · Your AI pair programmer\n Does GitHub Copilot recite code from the training set?\nThe vast majority of the code that GitHub Copilot suggests has never been seen before. Our latest internal research shows that about 1% of the time, a suggestion may contain some code snippets longer than ~150 characters that matches the training set. Previous research showed that many of these cases happen when GitHub Copilot is unable to glean sufficient context from the code you are writing, or when there is a common, perhaps even universal, solution to the problem.\n このFAQでは、OpenAI社の論文と同様、,u\u0026gt;Copilotが提案するコードの中に学習元と同一のコードが含まれる可能性があるという問題について述べているが、こちらはOpenAI社の論文よりも踏み込んだ調査をしている。11 このFAQでは、約1%の確率でCopilotの提案するコードの中に学習元のコードと一致する150文字以上のコード片が含まれる可能性があると述べている。また、この事象は、利用者の記述からうまくコンテキストを抽出することができず、よく現れる一般的なパターンを提案してしまったためと説明されているが、同一のコードが提案されることによるOSSライセンス上の問題等については特に触れていない。\nこれは個人の考えだが、150文字以上の一致となるとプログラム自身に創作性が認められる可能性が十分にあるようにも思えてしまうが、I/O関係の処理などはエラー処理も含めると長いお作法となりがちなので、文字数だけでは語れず、やはり実際にどのようなコードが一致したのかを見ないとなんとも言えないと感じてしまう。\n Does GitHub own the code generated by GitHub Copilot?\nGitHub Copilot is a tool, like a compiler or a pen. GitHub does not own the suggestions GitHub Copilot generates. The code you write with GitHub Copilot’s help belongs to you, and you are responsible for it. We recommend that you carefully test, review, and vet the code before pushing it to production, as you would with any code you write that incorporates material you did not independently originate.\n こちらのFAQでは、Copilotが提案したコードを利用した書き上げたコードは利用者自身に帰属し、その責任も利用者が負わなければならないと言っており、Copilot利用者の成果物に対する権利侵害の注意喚起を行なっているが、Copilotが提案するコード自身の権利侵害については特に記述されていない。Copilotの利用規約にも同様のことが書かれている。\nGitHub Terms for Additional Products and Features - GitHub Docs\n The code, functions, and other output returned to you by GitHub Copilot are called “Suggestions.” GitHub does not claim any rights in Suggestions, and you retain ownership of and responsibility for Your Code, including Suggestions you include in Your Code.\n OpenAI社の論文でもそうであったが、GitHub側のステートメントでもCodex/Copilotが提案するコード片自体に権利侵害の恐れはないと暗に判断しているということが伺える(そうでもなければサービス化なんてできないだろうが)。また、このFAQでは、GitHub Copilotが道具である (GitHub Copilot is a tool)と明に言っており、AIを道具として使用した際の生成物の著作権に関する議論を意識しているようにも読める(この辺りの議論ついては後述の余談のところで少し触れている)。\n What can I do to reduce GitHub Copilot’s suggestion of code that matches public code?\nWe built a filter to help detect and suppress the rare instances where a GitHub Copilot suggestion contains code that matches public code on GitHub. You have the choice to turn that filter on or off during setup. With the filter on, GitHub Copilot checks code suggestions with its surrounding code for matches or near matches (ignoring whitespace) against public code on GitHub of about 150 characters. If there is a match, the suggestion will not be shown to you. We plan on continuing to evolve this approach and welcome feedback and comment.\n このFAQでは、GitHub Copilotに提案内容が公開コードと一致しているかチェックする機能が存在し、一致している場合は提案しないようもできるオプションを備えていると言っている。\nこのオプションはGitHubのSetings \u0026gt; GitHub Copilotから設定することができるようだ。\nひとつ前のFAQより、GitHub社自身はCopilotの提案するコードが直接的に他者の権利侵害に繋がることはないと判断しているように思えるが、AI生成物の権利について未だ確たる結論がない以上、公開コードとの一致による権利侵害に懸念を持っている利用者もいるはずであり、そのような人向けのオプションも用意しているということだろうか。\n 少し脇道に逸れるが、ここで生じる新たな疑問として「コードの完全な一致(maching)さえ防ぐことができれば、学習元プロジェクトに対する権利侵害を回避できるのか?」というものがある。\n特許権に照らして考えると、特許は実装それ自身ではなくアイディアに対して認められるものであるため、もちろんNoである。しかし、Codex自体がコーディングタスクを解くためのモデルであることを考えると、特許権を侵害するほどの実装を提案するということがあるかという疑問が残る。また、前述の”約1%の確率で学習元コードと一致”という事象はあるが、この時提案されているのは言語共通の実装であるため、それが特許権を侵害したコードであるとするのであれば、すでに特許権を侵害したコードが複数公開されていることになり、Codex/Copilotの問題ではないように思う(Codex/Copilotの責任が消える訳ではないが)。もちろん、Codexの性質や、学習元と一致している提案コードの内容はサービス提供側のOpenAI/GitHub両社の言い分に元付いているため、これらに対する疑義は残るものの、Copilotの提案レベルのコードで特許権の侵害が発生するとは考えにくいというのが個人の感想。\n次に、著作権に照らして考えてみる。著作権は表現方法に対して与えられる権利であるため、もちろん完全に一致している場合は権利侵害にあたる。しかし、完全な一致を弾いたとしても、コードに関してはどこまで似ていれば表現が同じだと解釈されるのかは個人的に気にはなる(例: 空白文字が違う、変数名が違う、処理の順序が違う、等)。この点を掘り下げるために、プログラムとソフトウェアに関する判例について少し見てみた。\n東京地裁　平成２８年（ワ）第３６９２４号 1213 本判決において、原告側は、開発したプログラムの機能及び特徴からプログラムの著作物性を主張している。しかし、裁判所側の判断は以下である。\n 著作権法は，プログラムの機能やアイデアを保護するものではなく，その具体的表現を保護するものであるところ，プログラムにおいては，所定のプログラム言語，規約及び解法に制約されつつ，コンピューターに対する指令をどのように表現するか，その指令の表現をどのように組み合わせ，どのような表現順序とするかなどについて作成者の個性が表れることになる。\nしたがって，プログラムに著作物性があるというためには，指令の表現自体，その指令の表現の組合せ，その表現順序からなるプログラムの全体に選択の幅があり，かつ，それがありふれた表現ではなく，作成者の個性，すなわち，表現上の創作性が表れていることが認められる必要がある。\n ここで述べられているプログラムの著作物性の特徴に関して「プログラムに著作物性があるというためには…プログラム全体の選択の幅があり…」という部分が気になった。当然ではあるが実装するプログラムの責務を増やすほど、また、コードの量が増えるほど、プログラム全体の選択の幅は広がる。実際、プログラムの著作物性が認められた判例1415では、著作物性が認められる要因としてソースコードが大量であったことが大きく寄与しているように見える。もちろん、量が多いこと自体が独創性に寄与する訳ではないが、プログラム選択の幅が増えることで独創性を主張できる余地が広がり、逆にいうと量が少ないと独創性を主張する余地が少なくなる。Codexの解こうとしているコーディングタスクレベルの要求で、著作物性が認められるほどの選択の幅が存在するかというと、個人的には疑問がある。\nまた、この判例において、原告側はプログラムの表現上の特徴を以って独創性を主張しているが、これは裁判所により棄却されている。\n また，原告は，本件プログラムには，①クラス，関数，変数などは全て小文字を使用すること，②クラスメンバ変数名の先頭には「_（アンダースコア）」を付することなど，表現上の特徴があると主張するが，これらの表記方法は，関数その他の指令単体の表現の特徴であって，その組合せに係る表現の特徴ではない上，いずれもありふれた表現ということができるから，本件プログラムに著作物性があるということはできない。\n 著作権自体は表現に対して与えられるものであるが、それがありふれた表現であると著作物性が認められない。一般に、プログラムを記述する際は誰が読んでも自然に読めるよう「可読性」を念頭に置くことが多く、できるだけありふれた表現を使用することが求められることが多い。また、プログラミング言語を決定した時点で使用できる言語仕様・APIなどは限定されるため、選択の幅は限られる。これにさらに、Codex/Copilotの解こうとしている問題が標準的なコーディングタスクであることを考慮すると、著作物性が認められるほど独創的なコードが提案されるとはやはり考えにくいというのが個人の感想である。\n 以上より、個人的な感想ではあるが、Codex/Copilotにより提案されるコードが学習元のコードの著作権を侵害する事象が起こるとは考えにくい。もちろん、この判断は現時点でのCodex/Copilotの公開情報からその能力を想像した上での判断に過ぎないため、実際に使ってみると著作権侵害となるコードが多数提案されるのかも知れないし、今後の改良等でこれらの前提が変わる可能性もある。さらに、最終的に著作物性の判断は人が行うこととなるため、AIの側で著作権侵害に当たるコードの提案のみを取りやめるということは恐らく不可能であるため、Copilotによる学習元プロジェクトに対する著作権侵害のリスクが完全になくなるということは無いと思われる。\n余談: AI生成物の権利に関する議論に寄せて 最後に、AIが生成する成果物の権利について調べたことを書き残す。\nAIを利用する際に、そのAI利用者からのAIへの指示に利用者の創作意図や創作的寄与が認められ、AIをその利用者の指示を具現化するための単なる道具として使用した場合、AIからの生成物の著作権は利用者に帰属するという考え方がある1617。\nCopilotをソフトウェア開発に用いることを想定すると、まずCopilot利用者は開発するソフトウェアの要件・仕様を頭に描いているはずであり、その中の一部分の実装について、その部分が満たすべき仕様をdocstringとしてCopilotに与え、Copilotがその実装を返す、という利用シーンが一般的であると考えられる(遊びの用途であればこの範疇でない)。この**「開発するソフトウェアの要件・仕様を頭に描く」や「Copilotに仕様を与える」という行為から、個人的にCopilot利用者の創作意図や創作的寄与は十分に認められるのではないか**と考えられる。そのため、前述のAI生成物に関する著作権の話に照らし合わせれば、Copilotを利用することはAIを道具として利用したに過ぎず、Copilotにより提案されるコードの著作権はCopilot利用者に帰属すると考えることもできる。そして、もしCopilotが提案するコードが特許権を侵害しているのであれば、特許はアイディアに対して認められる権利であるため、利用者がCopilotに与える仕様自体が権利侵害に当たるはずである。そのため、特許権侵害はCopilot利用者側で防ぐものであり、実装にCopilotを用いたかどうかによって結論が変わるものではないと思われる。\nこれより、「AI利用者に十分な創作意図・創作的寄与が認められ、AIを道具として使用しているだけであれば、その生成物の著作権はAI利用者に帰属する」というような考えが認められれば、Copilotの利用が特許権・著作権侵害に当たるとは考えにくい。\nと、ここまで書いて一旦は納得していたが、改めて全体を読み直すうちに、この解釈はプログラムの著作物性の要件と合致しない可能性があることに気がついた。今一度、判例「東京地裁　平成２８年（ワ）第３６９２４号13」にあるプログラムの著作物性の要件を再度載せる。\n したがって，プログラムに著作物性があるというためには，指令の表現自体，その指令の表現の組合せ，その表現順序からなるプログラムの全体に選択の幅があり，かつ，それがありふれた表現ではなく，作成者の個性，すなわち，表現上の創作性が表れていることが認められる必要がある。\n ここでは、プログラムの著作物性があると言うためには「指令の表現自体、その指令の組み合せ、その表現順序」に表現上の創作性が表れていることが必要だと言っている。AIを道具として利用してプログラムを生成する場合に、プログラムの著作物性という観点でAIへの指示内容に創作意図や創作的寄与が認められるためには、AIに対する指示に「指令の表現自体、その指令の組み合せ、その表現順序」に関する記述が含まれる必要があるのではないか。つまり、AIの生成するコードに対する創作的寄与としては「AとBのAPIを、この通りの順序で呼んでZからファイルを読み込む処理」のようなプログラムの表現に対する具体的な指示を含める必要があるのではないかと思った。Codex/Copilotの用途として想定されている「AとBからCを計算する処理」と言う抽象的な指示であれば、ソフトウェア全体または部分としての創作意図や創作的寄与は十分に認められるとは思うが、著作物性のあるプログラムを生成するための指示としては、創作的寄与が不十分であるとも考えられる。\nただし、このことはAIの生成するコードが自分の著作物であると主張するには不十分であるということであり、AIの生成するコードが著作権を侵害しているかどうかという問題には関係しないようにも思う。先にも述べたが、生成されるコードは表現上の創作性が現れるほど大規模なコードにはならないと考えられるため、多くの場合では問題とはならないと個人的には捉えている。(ただし、AIの生成するコードが自分の著作物だと主張できない場合、そのようなコードをどのように扱うべきかと言う問題は残る。OpenAI/GitHub社の公開文書からは、提案コード自体は利用者の著作物にはならないため、finish workを行うことで自分に著作とせよという意図を汲み取ることもできる。)\n以上の話は、AI生成物の権利に関するある一つの解釈に基づく話であって、実際のこのような法律や法解釈がある訳ではない(と思われる)。公開情報の機械学習への利用がfair-useと認められたことと同様、AI生成物に関する権利侵害の話について、法整備も含めた今後の動向を注視する必要がある。\n感想 まず、本調査を行う以前より、AIとのペアプロという体験については賛成の立場であった。というのも、自分が開発をする際も、自分でコードを書くときと、人のコードをレビューするときでは視点が変わると感じていたからである。自分でコードを書いてしまうと、どうしてもバイアスがかかってしまうために自分でレビューすることは難しい(見直し程度であればできるが)。つまり、レビュワーが一人減ってしまうことになる。伽藍とバザール18にあるように、目玉の数が多いほどバグは見つかりやすいため、元となる実装はAIにやってもらい、自分はそれを見る目玉の一つ(2つ)となることができれば、多少なりともバグを減らす影響があるのではないかと考えているからである。\n 8. ベータテスタと共同開発者の基盤さえ十分大きければ、ほとんどすべての問題はすぐに見つけだされて、その直し方もだれかにはすぐわかるはず。\nあるいはもっとくだけた表現だと、「目玉の数さえ十分あれば、どんなバグも深刻ではない」。これをぼくはリーヌスの法則と呼んでる。\n もちろん一人増えただけでは「目玉の数さえ十分」とは言えないが、OpenSSL/Heartbleedの問題で明らかになったように、重要なインフラを担うプロジェクトでさえ開発者の数が少ないとなると、一つであっても目玉を増やす活動というのは意義があるのではないかと期待している。\nCopilot周りの権利関係について調べてみた結果としては、OpenAI社もGitHub社もCodex/Copilotが生成するコードの知的財産権への影響に関する意識は持っており、両社とも現時点ではCodex/Copilotは問題にはならないと判断し、また、Codex/CopilotによってAI生成物の権利に関する議論を促進するという姿勢であるのだと個人的には感じた。また、過去の判例からプログラムの著作物性の要件を知り、Codex/Copilotの提案するコードレベルでは、学習元プロジェクトが提案されるコードに対して著作物性を主張するのは困難なように思えた。ただし、調べた判例は国内だけのものであり、著作権は内国民優遇の特性を持つため、海外の判例まで含めて調べきれないとなると、安易に「Codex/Copilotが権利侵害となることはほぼない」と言い切ることができない。また、AI生成物の権利や権利侵害については各国で議論が進んでいるところであると思うので、GitHub Copilotのような影響力の大きいツールが正式リリースされたことにより、この辺りの議論がさらに深まることに期待したい。(現時点の議論も全然追えてはいないが…)\n最後に、自分がCopilotの利用者であると考えると、個人としての立場としては利用しても良いと思えるが、企業として利用することは難しいのかと思った。他者の権利侵害リスクにのみ着目すると、自己レビューの段階で著作物性が認められそうなコードを弾くことで対応はできるように思う。ただし、その場合Copilotが著作物性のあるコードを提案すること自体は認めることとなり、職業倫理に照らし合わせると、使用すること自体がCodex/Copilotの権利侵害を認めることとなり、使用が難しいのではないかと思った(この線引きも微妙である感は拭えないが)。\nいずれにせよ、自分はCopilot無償利用枠からは漏れており、課金して使うほどとは思っていないので、当面の間は利用することはないとは思うが。\n余談: Amazon CodeWhisperer GitHub Copilotの正式リリースと同時期にAmazon社もCodeWhispererという、Copilotに似たサービスを発表19したので、そちらについても少し見てみる。\nAmazon CodeWhispererは、GitHub Copilotと同様、開発者によるコメント (docstring) を元に、実装を提案するツールのようだが、提案されるコードの内容に最適なクラウドサービスやパブリックライブラリの選択が含まれるらしいので、GitHub Copilotより広範なタスクを扱えると言っているように見える。\n CodeWhisperer はコメントを自動的に分析し、指定されたタスクに最適なクラウドサービスとパブリックライブラリを決定し、ソースコードエディタで直接コードスニペットを推奨します。\n また、学習元プロジェクトに対する権利関係で大きな違いとして、Amazon CodeWhispererは、提案されたコードがトレーニングデータと類似している場合、それを検出して表示する機能が付いているらしい。\n このサービスには、推奨コードが特定のトレーニングデータに類似しているかどうかを検出するリファレンストラッカーも含まれています。開発者はコードの例を簡単に見つけて確認し、プロジェクトでそのコードを使用するかどうかを決定できます。\n CodeWhiperer の解説記事20の方に、スクリーンショット付きでこの機能の解説がある。\nこれを見ると、確かに採用した提案コードがどのようなライセンスの元で公開されているのかを一目で確認でき、採用不採用を決定するのに役に立ちそう。\n少し気になったので、スクリーンショットで例として表示されているリポジトリの記述が正しいのか調べてみた。\ngithub drfs で検索すると https://github.com/datarevenue-berlin/drfs がヒットし、このリポジトリはMITライセンスで公開されており、また、S3に関する処理があり、Pythonで書かれていることから、このリポジトリの例を表示しているように見える。このプロジェクトの2021/12/23最新コミットで、提案されているコードと同様の記述を探すと、以下が見つかる。\nhttps://github.com/datarevenue-berlin/drfs/blob/329c108793e24f133c0a0119966d6bb7806d4e84/drfs/filesystems/local.py#L87-L91\n@return_pathlib @allow_pathlib def walk(self, path): \u0026#34;\u0026#34;\u0026#34;Walk over all files in this directory (recursively).\u0026#34;\u0026#34;\u0026#34; return [ os.path.join(root, f) for root, dirs, files in os.walk(path) for f in files ] このメソッドは、改行位置や変数名が異なるものの、提案されているコードと等価な記述であるため、動作としては特に問題がないように見える。\nただ、提案されているコードと学習元のコードの間に変数名の違いがある点について、トレーニングセットとして datarevenue-berlin/drfs のコードを使用しているとした場合、学習元のコードから提案内容のような変数名の変換を機械的に行うことは難しいように見える。学習元の記述 os.path.join(root, f) から提案内容の os.path.join(root, name) へ変換する場合、 join の第2引数がファイル名を表す文字列であると知っていなければ変数名の変換を行うことは難しく、人の手を加えないとスクリーンショットにある提案内容にはならない気がしている。もしくは、このリポジトリ以外にも提案内容のリファレンスとなるリポジトリがあるか。ただ、いずれにせよCodeWhispererの動作に怪しい点があると言えるだけの材料にはならないので、単純に”気になった”というレベルの話。\nもう一点気になったのが、このように学習元のライセンスを表示する場合、CodeWhisperer自身がOSSライセンスの求める条項に従う必要があるのではないかということ。このスクリーンショットではMITライセンスのプロジェクトのコードを提案内容のリファレンスとして利用したと表示されているが、その場合、CodeWhispererはMITライセンスの求めに従い、このプロジェクト (drfs) のライセンス文と許諾表示を記載する必要があるように思う。もちろん、それだけであればそのようなページなりを作成すればいいのだが、例えばここでGPLでライセンスされたプロジェクトがリファレンスとして表示されると、話は厄介になるように思う。CodeWhispererのFAQ21を見ても、「オープンソースのコードを学習に使用した」程度にしか書かれていないため、ライセンスによって学習対象としてのフィルタリングを行なったかどうかについては書かれていない。\n Q. Where did AWS obtain the training data to build this service?\nCodeWhisperer code generation is powered by ML models trained on various data sources, including Amazon and open-source code.\n このあたりの動作は気になる点ではあるが、これらは「もし、リファレンスログに表示されるプロジェクトのライセンス表示がなければ」や「もし、GPLのコードがリファレンスとして表示されれば」などの仮定に基づいた懸念点であり、実際に触ってみれば解消する類の問題なのかも知れない。\n最後に、FAQ21の中の気になる記述について。\n Q. Who owns the code generated by CodeWhisperer?\nDevelopers own the code and are responsible for it.\n ここでは、簡潔にCodeWhispererの生成するコードは開発者のものであると言い切っているが、AI生成物の権利に関する議論に照らすと、何に基づいて権利が開発者に帰属すると言っているのか分からないのが少し気になった。(自分が知らないだけで、そのような決定があったのかも知れないが。)この点については、OpenAI/GitHub社のような、「Codex/Copilotにより提案されたコードに対して弊社は権利を主張しないが、提案されたコードを利用して書いた成果物に対する責任は開発者自身が負う」という書き方の方が誠実なように見えた。\n  GitHub Copilot is generally available to all developers\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n GitHub Copilotとライセンス問題\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n ちょっとユニークなライセンスたち・まとめ - Qiita\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The Open Source Definition (Annotated) | Open Source Initiative\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n OpenAI Codex\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Powering Next Generation Applications with OpenAI Codex\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://perma.cc/ZS7G-2QWF\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://www.bunka.go.jp/seisaku/chosakuken/hokaisei/h30_hokaisei/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/features/copilot#faq-privacy\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n DALL·E Now Available in Beta\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n GitHub Copilot research recitation | The GitHub Blog\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 東京地裁　平成２８年（ワ）第３６９２４号\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n ≪プログラムの著作物につき，著作物性（創作性）が否定された事例≫ | 知財弁護士.COM｜知的財産紛争・企業法務のご相談なら弁護士法人内田・鮫島法律事務所\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 東京地裁 平成１９年(ワ)第２４６９８号\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 知財高裁 平成２５年（ネ）第１００８５号\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n AI 生成物・機械学習と著作権法\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 「AI 創作物」の著作権法上の保護\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The Cathedral and the Bazaar: Japanese\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n AWS が Amazon CodeWhisperer を発表 (プレビュー)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n ntroducing Amazon CodeWhisperer, the ML-powered coding companion | AWS Machine Learning Blog\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n ML-Powered Coding Companion for Developers – Amazon CodeWhisperer FAQs – Amazon Web Services\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-7.1/","title":"Mattermost 7.1の新機能","section":"post","date":"2022.07.20","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2022/07/15 に Mattermost のアップデートとなる v7.1.0 がリリースされました。また、同日にMarketplace関連の問題を修正した v7.1.1 がリリースされています。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v7.1 is now available - Upgrade today Mattermost self-hosted changelog   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(OSS 版)でも利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard) Platform: 上記機能を含むMattermost全体  (Professional/Enterprise) Platform: インサイト (ベータ版) ワークスペース内の利用状況や活動状況を一目で確認できるインサイト機能が追加されました。(有償版限定の機能です。)\nインサイトは、自分が参加しているチャンネル・スレッドのみの情報を集めたインサイト(私のインサイト)と、チーム全体に関するインサイト (チームインサイト)の2つから選んで表示することができます。\nまた、インサイトの集計期間は、今日、直近7日間、直近28日間から選ぶことができます。\n各ウィジェットのタイトル部分をクリックすると、トップスレッドは上位5スレッド、トップボードとトップリアクションは上位10項目まで確認することができます。\nチームインサイトのトップスレッドには、自分が参加していないチャンネルのスレッドも表示されるため、会話が盛り上がっているチャンネルを見つけることなどができるようにもなりそうです。\nChannels: Mobile v2.0(ベータ版)の開発に伴う各種更新 今回のリリースには、先月紹介したMobileアプリ v2.0のベータ版の開発に伴う更新が含まれています。Mobile v2.0(Beta)は、機能追加やバグ修正が毎週行われており、ユーザーからのフィードバックも歓迎しています。正式版のリリースは今年末を予定しているそうです。\nMobileアプリ v2.0のベータテストに参加する方法は、以下のブログエントリに説明があります。\nJoin the Mattermost mobile beta program: v2.0 is now live! - Mattermost\nアップグレード時の注意事項 新たに追加されたMaxImageDecoderConcurrencyの設定値について 新たに追加された画像デコード同時実行数に関する設定 MaxImageDecoderConcurrency にはデフォルトで -1 が設定されており、これはCPUと同数であることを表しています。\nこの設定は、Mattermostサーバーのメモリ消費量に影響があり、設定値の決定に注意が必要です。\nまず、Mattermostで単一の画像を処理する際の最大メモリ消費量は、最大画像解像度の設定MaxImageResolutionの設定値を使用して MaxImageResolution * 24バイトと計算することができます。さらに、本バージョンより追加されたMaxImageDecoderConcurrencyによる画像処理の同時実行数を考慮すると、MaxImageResolution * MaxImageDecoderConcurrency * 24バイトが、Mattermostに割り当てられたメモリより小さくなるよう設定値を決定することをお勧めします。\nスキーマ変更にかかる所要時間 Mattermost 7.1にはデータベースのスキーマ変更が存在します。アップグレード時にスキーマ変更にかかる時間については以下のテスト結果を参考にしてください。\n MySQL, 投稿数1200万, リアクション数250万 → ~1分34秒 (8 core CPU / 16GB RAM) PostgreSQL, 投稿数1200万, リアクション数250万 → ~1分18秒 (db.r5.2xlarge)  以下のSQLを実行することでアップグレード前に手動でスキーマ変更を行うことができますが、このクエリはReactionテーブルへのロックを取得するため、SQL実行中にユーザーが投稿したリアクションはデータベースに反映されません。\n MySQL  ALTER TABLE Reactions ADD COLUMN ChannelId varchar(26) NOT NULL DEFAULT \u0026#34;\u0026#34;; UPDATE Reactions SET ChannelId = COALESCE((select ChannelId from Posts where Posts.Id = Reactions.PostId), \u0026#39;\u0026#39;) WHERE ChannelId=\u0026#34;\u0026#34;; CREATE INDEX idx_reactions_channel_id ON Reactions(ChannelId) LOCK=NONE;  PostgreSQL  ALTER TABLE reactions ADD COLUMN IF NOT EXISTS channelid varchar(26) NOT NULL DEFAULT \u0026#39;\u0026#39;; UPDATE reactions SET channelid = COALESCE((select channelid from posts where posts.id = reactions.postid), \u0026#39;\u0026#39;) WHERE channelid=\u0026#39;\u0026#39;; CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_reactions_channel_id on reactions (channelid); おわりに 次のv7.2のリリースは 2022/08/16(Tue)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/tech/github-pr-update-branch/","title":"他人の作ったPull Requestのブランチをbaseブランチに追従させたい","section":"post","date":"2022.06.19","body":"背景 CIが壊れてるときにPRをもらってしまい、CIがコケてCheckが通らずマージができないという事態。\nCIを直すにはCIスクリプトの方を直す必要があったので、CIを直すPRを作ってマージ。そうすると、作ってもらったPRのブランチの方にも、CIスクリプトの修正を取り込んでもらわないといけない。\n「お願い〜」と言ったけど、反応がない。まぁ、時間経っちゃったので仕方ない。\nリリース作るためにマージはしちゃいたいんだけどどうしよう、というのが背景。\n調査 mattermod Mattermostのリポジトリだと、PRに/update-branchとコメントすることで自動でbaseブランチの変更を取り込んでくれるBotとか動いてたなぁということを思い出し、リポジトリを見に行ってみる。\nコードを見ると、どうもgoogle/go-githubのUpdateBranchという関数を実行している模様。\n_, resp, err := s.GithubClient.PullRequests.UpdateBranch(ctx, pr.RepoOwner, pr.RepoName, pr.Number, opt) https://github.com/mattermost/mattermost-mattermod/blob/master/server/update_branch.go#L66\ngoogle/go-github google/go-githubのgodocを見に行く。\nhttps://pkg.go.dev/github.com/google/go-github/v45/github#PullRequestsService.UpdateBranch\nGitHubのドキュメントへのリンクが貼ってある。\nGitHub API ドキュメント google/go-githubのgodocに載ってたドキュメントを見てみる。\nhttps://docs.github.com/en/rest/pulls/pulls#update-a-pull-request-branch\nそれっぽいAPIはあるらしい。\nでもAPI叩くのはなんか嫌なので、API名でググってみる。\nGitHub　ドキュメント やはり画面から操作できる設定がある模様。 \u0026ldquo;Settings \u0026gt; Always suggest updating pull request branches\u0026ldquo;をONにすると、なんかやりたいことができるようになるっぽい。\nManaging suggestions to update pull request branches - GitHub Docs\n一応、設定名でもググって、やりたいことに沿っていそうか確かめる。\nProductivity Weekly (2022-02-09号)\n GitHub のプルリクエスト画面で base ブランチ[1]の最新のコミットを head ブランチ[2]に取り込む「Update branch」機能が rebase を選べるようになりました。これまでは merge しか選べなかったためマージコミットができてしまっていました。\n 実施 \u0026ldquo;Always suggest updating pull request branches\u0026ldquo;の設定を有効にしてみると、PullRequestのところにUpdate branchというボタンが生えている。\nUpdate with rebaseの方を選んでUpdate branchを実行したところ、元のコミットのCo-authorとして自分が追加され、force pushされる模様。\nUpdate with merge commitの方だと、自分によるマージコミットが作られるんだろうけど、どっちがいいんだろ。マージコミット作った方がわかりやすかった気がする。\nおわりに GitHubの設定が増えすぎて全然理解が追いついてない。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-7.0/","title":"Mattermost 7.0の新機能","section":"post","date":"2022.06.18","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2022/06/15 に Mattermost のメジャーバージョンアップデートとなる v7.0.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v7.0 is now available - Mattermost Mattermost self-hosted changelog   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(OSS 版)でも利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard)  Channels: 返信スレッドの折りたたみ機能がGA(General Availability)へ昇格 Feature Request Forumで最も多くの要望を集めていた返信スレッドの折りたたみ機能が正式にリリースされました。\n返信スレッドの折りたたみ機能の概要は、以下の動画で確認することができます。\nTutorial: Using Collapsed Reply Threads on Mattermost - YouTube\n正式リリースとなったことにより、全てのユーザーが設定 \u0026gt; 表示 \u0026gt; 返信スレッドの折りたたみから本機能のON/OFFを選択できるようになりました。(以前バージョンではベータ版としてリリースだったため、返信スレッドの折りたたみ設定を表示するにはシステムコンソール \u0026gt; 実験的機能 \u0026gt; 機能 \u0026gt; 返信スレッドの折りたたみから設定を有効にする必要がありました)\n(翻訳の更新があたっていないのか、英語以外の多くの言語で \u0026ldquo;(ベータ版)\u0026rdquo; の表記が残ってしまっていますが、正式版です。この表記は次のリリースで修正されていると思います。)\nもし、返信スレッドの折りたたみ機能をMattermostインスタンス全体として無効にしたい場合などは、システムコンソール \u0026gt; サイト設定 \u0026gt; 投稿 \u0026gt; 返信スレッドの折りたたみから設定することができます。\nChannels: Mobile v2.0 (Beta) Feature Request Forumで二番目に多くの要望を集めていたモバイルアプリで複数サーバーへ接続する機能を含む、Mattermostモバイルアプリのメジャーアップデートとなるv2.0のリリースが今年の後半に予定されています。それに先立ち、v2.0のベータ版を試用してくれるユーザーを募集しているようです。\nベータ版の利用方法については、公式のリリースブログを参照してください。\nChannels: Mobile v2.0 (Beta)\n複数サーバーへ接続する機能は、以下のような操作性になるようです。\nMattermost画面左上にあるサーバーのようなアイコンをクリックすると、接続するサーバーを選択するメニューが表示されます。\nChannels: 音声通話と画面共有 (Beta) Slackのハドルミーティングのような音声通話機能がMattermostにも追加されました。\nチャンネルごとに音声通話を開始することができ、通話中でもMattermostの機能を通常通り使用することができます。\n以下に自環境でブラウザを2つ横に並べて音声通話機能を動作させた時の様子を載せています。\n音声通話/画面共有機能はDesktopアプリ、Mobileアプリ、およびブラウザ上で利用することができます。\nMobileアプリでも共有された画面を綺麗に見ることができました。共有画面のサイズが大きい場合は厳しそうですが。また、前述のMobileアプリv2.0では利用できませんでした。\n本機能はWebRTCをベースに構築されており、Mattermost PluginプロジェクトとしてGitHubで開発が進められています。 (mattermost-plugins-callsプラグインは、コンパイル済みのプラグインを利用する場合はMITライセンスの条件の下で利用することが可能ですが、ソースコードを改変して利用する場合は特殊な条件があるようなので注意が必要です。)\nhttps://github.com/mattermost/mattermost-plugin-calls\nMattermost公式のクラウドサービスを利用している場合、音声通話機能の設定が完了した状態で提供されるため、すぐに使い始めることができますが、セルフホスト版を利用している場合は、以下のドキュメントを参考にプラグインの設定を行う必要があります。\nStart a call (beta)\nChannels: メッセージ書式設定ツールバー Mattermostのメッセージ入力欄にWYSIWYG風なボタンが追加され、ボタンによるメッセージの書式設定を行えるようになりました。\n書式設定のボタンは追加されていますが、メッセージ入力自体は今まで通りMarkdown形式で入力することができ、追加されたボタンはMarkdown形式の入力を補助する機能という位置付けのようです。\n動作している様子については公式ブログを参照ください。\nChannels: Message Formatting Toolbar\nPlaybooks: インラインPlaybookエディタ Playbookの編集画面が新しくなり、各セクションごとに分割して表示されているのでは無く、1枚のレポートのように各セクションがシームレスに結合されて表示されるようになりました。\nPlaybooks: Playbooksの利用統計 Playbooksの利用統計情報がシステムコンソールから確認できるようになり、インスタンス内でPlaybooksがどの程度利用されているかを把握しやすくなりました。。システムコンソール \u0026gt; レポート \u0026gt; サイトの使用統計から確認することができます。\nPlaybooks: 実行中のPlaybookに対するアクションとトリガーの追加 実行中のPlaybookのステータスが更新された際に、その更新内容の配信先となるチャンネルと外向きのウェブフックを実行ごとに指定できるようになりました。今までもPlaybook単位で配信先を指定することはできましたが、本バージョンからPlaybookの実行ごとに配信先を追加で設定することができます。\nIntegrations: Apps Bar (ベータ版) Mattermost統合機能のアイコンを表示する領域として、新たに画面右端にApps Barという領域が追加されました。\n今までのバージョンでも、MattermostにはPluginやApps等の統合機能によってチャンネルヘッダ部分に統合機能専用のアイコンを表示することができました。ただ、追加される統合機能が多くなると全てのチャンネルのヘッダ部分に統合機能のアイコンが数多く並ぶようになり、チャンネルヘッダのテキストなど、現在表示しているチャンネルに特化した情報が埋もれるようになっていました。Mattermost v6.0で刷新された新しいUIでは、チャンネルヘッダにはそのチャンネルに特化した情報を表示すべきという明確な目的が与えられたため、v7で統合機能のアイコンを表示するための専用の場所(Apps Bar)が作成されたようです。\nApps Bar機能はシステムコンソール \u0026gt; 実験的機能 \u0026gt; 機能 \u0026gt; Enable App Barから有効/無効を設定できます。\nPlatform: デスクトップアプリがmacOS App Storeからインストール可能に MattermostデスクトップアプリがmacOS App Storeから取得できるようになりました。　Mattermost Desktop on the Mac App Store\nApp Storeからインストールした場合、新しいバージョンがリリースされると自動でデスクトップアプリがアップデートされるようになります。\nPlatform デスクトップアプリのDEB/RPMパッケージリリース Linux向けにもMattemrostデスクトップアプリのDEB/RPMパッケージがリリースされました。\nインストール方法については公式ブログを参照ください。\nPlatform: Linux DEB and RPM packages for Desktop App\nその他の変更 ログイン画面の更新 ログイン画面のデザインが更新されました。\nアップグレード時の注意事項 ログインセッション維持期間に関する設定変更への対応 Mattermostのログインセッションの維持期間に関する設定が、日(day)単位から時間(hour)単位に変更されました。config.json を使ったファイル形式で設定を管理している場合、セッション維持期間に関する設定値は自動的に新しい形式へ変換されますが、環境変数を通じて設定している場合は設定する環境変数を変更する必要があります。環境変数による設定の変更方法について詳しくは以下の公式ドキュメントを参照してください。\nImportant Upgrade Notes\nMySQLを使用している場合、アップグレード時のマイグレーションに時間がかかる可能性有 セルフホストのMySQLを使ってMattermostを構築している場合、FileInfoテーブルに格納されているデータの数によっては、アップグレード時のマイグレーション処理に時間がかかる可能性があります。\n参考情報として、CPU: Intel i7 6cores@2.6GHz、Memory: 16GBの環境で、FileInfoテーブルに70万行のデータが格納されている場合、マイグレーションに19秒かかったとのことです。PostgreSQLの場合、マイグレーションの処理時間は無視できるほどです。\nプラグインにより追加されたチャンネルヘッダーアイコンがAppBar領域へ v7より追加されたApp Bar機能をシステムコンソール \u0026gt; 実験的機能 \u0026gt; 機能 \u0026gt; Enable App Barから有効にした場合、プラグインによってチャンネルヘッダーに追加された全てのアイコンが、AppBar領域に移動されます。セルフホスト版では、AppBar機能はデフォルトで無効になっています。\nTrustedProxyIPHeaderの設定値の確認 以前のバージョンでは、特定の状況下でServiceSettings.TrustedProxyIPHeaderのデフォルト設定値が空配列にならないバグが存在しましたが、本バージョンからデフォルト値が空配列になるよう修正されました。以前のバージョンからv7へアップデートする場合、この設定値を確認し、意図しない値が設定されている場合は nil を設定する必要があります。\n当該設定項目に関する説明はConfiguration settingsを参照してください。\nその他のトピック チャンネル名コンテスト MattermostのTwitterで、実際に運用されているユニークなMattermostチャンネル名を表彰するコンテストが開催されています。募集期限は6/22 PM12:00(ET) まで募集しており、最もユニークなチャンネル名を投稿した5名の勝者にはグッズが送られるようです。\n応募方法など詳しくは、以下のツイートツリーを参照ください。\nhttps://twitter.com/Mattermost/status/1537080481384124419\nHappy Pride Month 6月は、アメリカやカナダ、オーストラリアを始め様々な国でLGBTQ+の権利についての啓発を行うイベントが開催されるPride Monthとされています。Mattermost社は仕事をする上でもPrideを尊重することは生産性と幸福を高めると考えており、Pride Monthに関する意識を向上させるために、6月の毎週金曜日にPride Monthに関するクイズを出し、最初に正解した人にグッズを贈呈するというイベントを開催しています。\nhttps://community-daily.mattermost.com/core/channels/off-topic-pub/9hwibadgfp8jxj8sdfur5qt7kw\nHackathon Mattermost社のプロダクト(Channels, Playbooks, Boardsなどを指しているものだと思います)を、うまく活用したソリューションのアイデアを集めるためのハッカソンが6月下旬に予定されています。\nMattermost社のR\u0026amp;Dチームが主体となって開催しているものですが、コミュニティメンバーの参加も歓迎されています。\nMattermost Hackathon 2022 - Google スライド\nおわりに 次のv7.1のリリースは 2022/07/15(Fri)を予定しています。\n "},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-6.7/","title":"Mattermost 6.7の新機能","section":"post","date":"2022.05.17","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2022/05/16 に Mattermost の新しいバージョン v6.7.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v6.7 is now available - Mattermost Mattermost self-hosted changelog   アップグレード時の注意事項 今回のアップグレードではデータベースのスキーマ変更が行われるため、アップグレードに時間がかかる可能性があります。MySQLを利用していて900万投稿程度のデータが存在する場合、アップグレードに2分程度の時間がかかるようです(インスタンスはdb.r5.xlargeを使用)。\nアップグレード時のダウンタイムを0にしたい場合、アップグレード前に以下のSQLを手動で実行し、事前にスキーマ変更を済ませておくこともできます。\n For MySQL: CREATE INDEX idx_posts_create_at_id on Posts(CreateAt, Id) LOCK=NONE; For Postgres: CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_posts_create_at_id on posts(createat, id);  これらのSQLによる変更は、テーブルロックを取得せず、既存のオペレーションに対する影響はないため、Mattermost起動中でも実行することができます。\n詳しくは公式ドキュメントを参照してください。\nImportant Upgrade Notes\n 各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(OSS 版)でも利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard)  (Professional/Enterprise) Playbooks: タスクの期限を設定可能に Playbookに設定したチェックリスト内の各タスクに対して期限を設定できるようになりました。期限は 今日/明日/次週を選択するか、At 5:00 pm in three days のような自然言語(英語のみ)を使って設定することができます。\nPlaybooksの日次ダイジェスト通知には期限の迫ったタスクと期限の過ぎたタスクのみが通知されるようになるため、タスクの期限を設定することで通知ノイズを減らすことができます。\nこの機能は、Professional/Enterpriseプラン限定の機能です。\nその他の変更 Mattermost Desktop App: 自動アップデート機能 Mattermost Desktop Appに自動アップデートの機能が追加されました。\nWindows向けのMattermost Desktop Appを使用している場合、新しいバージョンが利用可能になると、アプリ上で更新を促すアラートが表示され、1クリックでDesktop Appのアップデートを完了することができます。\nmacOSでは、GitHubのReleasesページからバイナリをインストールして利用している場合、自動アップデートは機能しないそうです。App Storeからインストールした場合のみ、新しいバージョンが自動で利用可能になるようですが、まだApp StoreではMattermost Desktop Appは公開されていないようで、公式ドキュメントからもApp Storeからのインストール手順が削除されています。App Storeで公開され次第、再度ドキュメントが更新されるのだと思います。\nDesktop App Automatic \u0026amp; Manual Updates by cwarnermm · Pull Request #5628 · mattermost/docs\nLinux OSでは、自動アップデートはサポートされていないようです。\n詳しくは下記のドキュメントを参照ください。\nDesktop App install guides\nChannelsのUI変更 ChannelsのUIにいくつか変更があります。\n右サイドバーのチャンネル情報に表示項目が追加 v6.6からチャンネル情報を右サイドバーで確認できるようになりましたが、表示項目にチャンネルメンバー、ファイルとピン留めされた投稿が追加されました。\nチャンネル作成ダイアログの変更 チャンネル作成ダイアログのUIが変更されました。\nチャンネル名が1文字のチャンネルが作成可能に Mattermostのチャンネル名は2文字以上にする必要がありましたが、今回のバージョンから1文字のチャンネル名も作成できるようになりました。\nMM-41909: Allow 1 char channel name by KevinSJ · Pull Request #19845 · mattermost/mattermost-server\nその他のトピック Roadmap Mattermost公式により運用されているコミュニティサーバー内のRoadmapチャンネルにて、今後のMattermostの方向性に関する情報が公開されています。\nMattermostのメインとなるチャット機能であるChannelsのロードマップについては、以下の資料が公開されています。\nMay 2022 - Channels Roadmap Update - Viewer Copy - Google スライド\nRoadmapの資料によると、2022年6月にメジャーバージョンアップとなるv7.0のリリースを予定しているようです。\nv7.0では、現在ベータ版として提供されている返信スレッドの折り畳み機能がGA(Generic Available)機能に昇格するほか、WYSIWYG形式のメッセージ入力欄の導入等が行われる模様です。\nまた、モバイルアプリv2も開発中となっており、こちらはMattermost v7がリリースされる2022年6月にベータ版がリリースされる予定となっているようです。\nモバイルアプリv2からは、一つのアプリに複数のMattermostサーバーを登録しておける機能などが追加される予定となっています。複数Mattermostサーバー登録機能については、以下のJIRAチケットのFigmaで作られたデザインイメージが参考になりそうです。(実際にリリースされる機能とは異なる可能性がありますが)\n[MM-41961] Multi Server: All servers are logged out - Mattermost\nおわりに 次のv7.0のリリースは 2022/06/15(Wed)を予定しています。\n "},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-6.6/","title":"Mattermost 6.6の新機能","section":"post","date":"2022.04.23","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2022/04/16 に Mattermost の新しいバージョン v6.6.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v6.6 is now available - Upgrade today Mattermost self-hosted changelog   アップグレード時の注意事項 Mattermostと他システムを連携する仕組みの一つであるMattermost Apps Frameworkのプロトコルの一部に破壊的な変更があります。今までのバージョンでbindingやformのリクエストを送信する際にcall要素として設定していた値が、submit,form,refresh,lookup要素に分割されました。以前のバージョンで動作するよう開発していたAppsは、新しいプロトコル向けに修正する必要があります。\n 各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(OSS 版)でも利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard)  Channels: トリガーとアクション ユーザーがMattermost上で特定の行動(トリガー)を行った場合に、自動で実行されるアクションをMattermost上で定義できるようになりました。対象となるのは後述する2つのトリガー/アクションのみですが、コードを書くことなく、Mattermost上の操作だけで設定することができます。\n(本機能はMattermost Plugin Playbooks v1.27により追加される機能だと思われます。そのため、Playbooksプラグインのバージョンが古い、Playbooksプラグインが有効になっていない等の場合は後述のChannel Actionsを追加するメニューが表示されません。メニューが表示されない場合は、システムコンソール \u0026gt; プラグイン管理 \u0026gt; インストール済みプラグインからPlaybooks v1.27が有効になっていることを確認してみてください。)\n設定方法 トリガーとアクションはチャンネルごとに チャンネルメニュー \u0026gt; Channel Actions から設定することができます。設定するにはチャンネル管理者の権限が必要です。\nトリガー1: ユーザーがチャンネルに参加した時 \u0026ldquo;ユーザーへ一時的なウェルカムメッセージを送信する\u0026ldquo;を設定することで、新たにユーザーがチャンネルに参加した際に、そのユーザーのみが閲覧できるメッセージを表示することができます。新たにチャンネルに参加したユーザーに目を通しておいて欲しい情報や、チャンネルの運用ルール等を自動で伝えることができます。\nまた、\u0026quot;ユーザーのサイドバーカテゴリにチャンネルを追加する\u0026ldquo;から、参加したチャンネルを左サイドバーのどのカテゴリに追加するかを指定することもできます。参加したユーザーの左サイドバーに追加先のカテゴリが存在しない場合は自動で作成されます。\nこのチャンネルアクションを設定したチャンネルに参加すると、以下のように左サイドバーの指定したカテゴリにチャンネルが表示され、ウェルカムメッセージが表示されます。(左サイドバーのカテゴリに移動するまでに多少時間がかかることがあります。)\nトリガー2: 特定のキーワードを含むメッセージを投稿した時 \u0026ldquo;これらのキーワードを含むメッセージが投稿された場合\u0026ldquo;で設定したキーワードを含むメッセージが投稿された際に、Playbookを開始するかどうかを尋ねるダイアログを自動で表示することができます。\nこの機能を使うことで、例えば「システムのモニタリングツールがpriority: high;というキーワードを含むメッセージをMattermostに投稿すると、SREチームがインシデント対応手順を即座に開始する」というようなフローを組むことができるようになります。\nChannels: メッセージアクションの表示位置変更 PluginやAppsによりメッセージのコンテキストメニューに独自のメニューを追加することができますが、このメニューの表示位置が変更されました。\n今までのバージョンでは、Plugin/Appsによって追加されたメニューもMattermostデフォルトのメッセージアクション（編集、削除など）と並列に表示されていましたが、本バージョンからはカスタムアクション専用のボタンが表示されるようになりました。\n(Enterprise) Playbooks: レトロスペクティブメトリクス Playbookの各実行完了後に、任意のメトリクスを4つまで入力できるようになりました。入力したメトリクス値の統計情報を自動で計算・表示してくれるため、インシデント対応のパフォーマンス指標などに利用することができます。\n(Enterprise限定機能であるかのように説明されていますが、Team Editionでも利用できそう？)\n設定 まず、Playbookに関するメトリクスを収集するために、収集対象のキーメトリクスを設定する必要があります。キーメトリクスとは、Playbook編集画面のレトロスペクティブタブから設定することができます。\nメトリクス値の入力 Playbookにキーメトリクスを設定しておくと、Playbookの実行が完了した後に入力を促されるレトロスペクティブ編集画面で、設定したキーメトリクスの入力欄が表示されるようになります。\nメトリクス統計情報の確認 キーメトリクスを入力してレトロスペクティブを発行すると、Playbook概要ページのキーメトリクスタブから、入力したメトリクスの統計値や推移を確認できるようになります。\nその他の変更 Integrations: App FrameworkがGeneral Availabilityに 開発者プレビュー版として公開されていたMattermost Apps FrameworkがGeneral Availabilityになりました。 App Frameworkは、Plugin機能に近い拡張性を持ち、どんなプログラミング言語でも記述でき、さらにサーバーレス技術を使ったホスティングも可能なMattermostの統合機能です。\n今までのバージョンでは、App Frameworkを利用するにはmattermost-plugin-appsというプラグインを自身でアップロードする必要がありましたが、このv6.6からは全てのMattermostサーバーで自動で有効になります。\nMattermost Apps Frameworkについて日本語で書かれている記事は、以下のようなものがあります。\n(Mattermost Apps Frameworkの開発者向けプレビュー版が公開された当時に書かれたもののため、記述内容が古くなっている可能性があります。)\n Mattermost Apps Frameworkを触ってみた Mattermost Apps Framework をJava (JAX-RS)で試してみた – maruTA(Bis5)\u0026rsquo;s Weblog – Side T:echnology  チャンネル情報が右サイドバーに チャンネル情報を表示するためのボタンがチャンネルヘッダ部分に追加されました。 ボタンをクリックすると、右サイドバーにチャンネル情報が表示されます。\nおわりに 次のv6.7のリリースは 2022/05/16(Mon)を予定しています。\n "},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-6.5/","title":"Mattermost 6.5の新機能","section":"post","date":"2022.03.19","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2022/03/16 に Mattermost の新しいバージョン v6.5.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v6.5 is now available - Upgrade your deployment today Mattermost Self-Hosted Changelog   アップグレード時の注意事項 CLIコマンドmattermost versionの実行結果にデータベースのバージョンが含まれなくなりました（今までのバージョンでは実行結果にDB Version: 6.5.0のようにDBのバージョンも出力されていました）。また、mattermost versionがDBとのやり取りを行わなくなり、DBマイグレーションも実行しなくなったため、DBマイグレーションを行うための新たなコマンド mattermost db migrateが追加されました。(PR)\n 各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(OSS 版)でも利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard)  (Enterprise/Professional) Channels: カスタムグループ (ベータ版) 複数のユーザーにメンションを送信する際に利用できるカスタムグループを作成できるようになりました。例えば、developerというグループを作成し、そのグループにユーザーを追加しておくと、@developerというメンションで、グループ内の全員にメンションすることができます。　今までのバージョンでもAD/LDAP連携を設定している場合はLDAP上で設定されたグループに対してメンションを送る機能はありましたが、今回追加されたカスタムグループの機能によりAD/LDAP連携を行なっていなくてもグループメンションが利用できるようになりました。\nカスタムグループの作成はMattermost UIのProduct Menuから行うことができます。操作概要については、公式リリースブログの Channels: Custom groups (Beta) セクションの動画を参照ください。\nMattermost v6.5 is now available - Upgrade your deployment today\nまた、スラッシュコマンド/inviteで、ユーザーをグループに追加することもできます。\nカスタムグループ機能について、詳しくは以下のドキュメントを参照ください。\nManage Custom Groups\nChannels: チーム横断的なチャンネル移動が可能に Ctrl + k のショートカットで開くことができるチャンネル検索ダイアログで、他のチームのチャンネルも横断的に検索できるようになりました。 今までのバージョンでは、チャンネル検索ダイアログで検索できるチャンネルは現在アクセスしているチームのチャンネルのみに限定されていましたが、今回のバージョンより参加したことのあるチャンネルであればチームに関係なく検索することができるようになります。\n検索結果のチャンネル名の右側にチーム名が表示されるため、複数のチームに同名のチャンネルが存在しても見分けることができます。\nPlaybooks: 複製、インポート、エクスポート 既存のPlaybookを複製することができるようになりました。\nまた、Playbook内容をJSON形式でエクスポートできるようになり、Playbookのバックアップや、インポート機能と組み合わせて別のMattermostインスタンスへのPlaybookの移行などが実施できるようになりました。\n複製メニューをクリックすると、Copy of ${Playbook名} という名前のPlaybookが新たに作成されます。\nBoards: 共有機能のUI改善 Boardsの共有リンクを取得する際のUIが改善されました。\nまず、Board画面に共有（Share）ボタンが表示されるようになりました。（今までは、オプションメニュー内に表示されていました）\nまた、リンクを生成する際に、Mattermostユーザー向けの内部リンクを作成する画面と、MattermostユーザーアカウントがなくてもBoardの内容が確認できる読取専用の公開リンクを作成する画面が別画面になりました。\nBoards: チャンネルイントロにBoardへのリンクが表示されるように チャンネル作成時に一番最初に表示されるテキストにBoardへのリンクが含まれるようになりました。\nBoards: インポート機能のドキュメントへのリンク Trello・Jira・NotionなどのツールからBoardsへデータをインポートする際の手順に関するドキュメントへのリンクが追加されました。\nBoardsの設定メニューから表示することができます。\n他ツールからBoardsへのインポート機能について、詳しくは以下のリンク先を参照してください。\nImport your data\nIntegration: 統合機能 Mattermostと他機能を連携させる統合機能について、いくつかのアップデートがあります。\nAtlassian Bitbucket Cloud Plugin Atlassian社のGitリポジトリ管理ツールであるBitbuket CloudとMattermostを連携させる統合機能がリリースされています。\n毎日Mattermostへログインした際にBitbucket　Cloud内で行われた重要な活動が通知される機能や、Bitbucket Cloud内で自分がメンションされたことをMattermostのDMで通知してくれる機能などが利用できるようになります。 また、PRのリストが常にMattermostのサイドバーに表示されるようになります。\nインストール方法など、詳しくは以下のリンク先を参照してください。\nMattermost/Bitbucket Plugin - BitBucket Plugin\nConfiguration Wizard いくつかの統合機能は、インストール後にセットアップ手順を実行する必要があります。 いくつかの統合機能について、このセットアップ手順がプラグインインストール時にMattermostのDMとして投稿されるようになりました。これにより、外部サイトを参照しながらセットアップを行う必要がなくなります。(Mattermost GitHub Plugin v2.1.0で試してみましたが、うまく動作しませんでした)\nGitHub Plugin v2.1 Mattermost GitHub Plugin v2.1がリリースされました。\nMattermostのメッセージからGitHubにIssueを作成する際に利用できる Create Issue in GitHub メニューなどが追加されています。\n変更点について詳しくはリリースノートを参照してください。\nRelease v2.1.0 · mattermost/mattermost-plugin-github\nPlatform Mattermostインスタンス全体 (Platform) についても、いくつか更新点があります。\nワークスペースの最適化 運用中のMattermostインスタンスが最適な設定で運用されているかどうかを判定し、最適でない場合にどのように変更すべきかを提案するダッシュボード機能が追加されました。 システムコンソール \u0026gt; ワークスペースの最適化から確認することができます。（手元の環境ではメニューが表示されませんでした\u0026hellip;）\n詳しくは、以下の公式ドキュメントを参照してください。 Optimize Your Mattermost Workspace\nOnboarding tourの改善 初めてMattermostにアクセスした際に表示されるオンボーディングが、Board/Playbookでも表示されるようになりました。\nBoards/Playbooks機能の利用方法をチュートリアル形式で確認していくことができます。\nその他の変更  Firefox の利用推奨最低バージョンがv78からv91に変更されました （PR） Safari の利用推奨最低バージョンがv12からv14.1に変更されました （PR）  その他のトピック Go Conference JP 2022/04/23に日本で(オンライン)開催される Go Conference Online 2022 SpringにMattermost社のJesús Espino氏が登壇します。\nGo Conference 2022 Spring | Dissecting Slices, Maps and Channels in Go\nJesus氏はMattermostの開発者ブログでも、Goに関するエントリをいくつか書いています。\n Maintaining Consistency in Codebases with Go vet Layered Store and Struct Embedding in Go  今回の発表もGo言語のランタイムにおいて、Slice, Map, Channelがどのように動作しているかというディープな話になりそうです。\nBoardsのコメント欄に日本語を入力できない問題 Boardsのカード内のコメントに日本語を入力しようとすると、Enterキーで入力を確定したタイミングで入力内容が消えてしまう事象が発生しています。\nこの問題については、以下のIssueで対応が進められています。 Bug: Unable to enter Japanese text into comments field · Issue #2343 · mattermost/focalboard\nロシア/ベラルーシを輸出禁止国に追加 米国政府による制裁に応じ、Mattermost社もロシア・ベラルーシを輸出禁止国のリストに追加したそうです。\nMattermost policy changes due to conflict in Ukraine - Mattermost\nおわりに 次のv6.6のリリースは 2022/04/14(Thu)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-6.4/","title":"Mattermost 6.4の新機能","section":"post","date":"2022.02.19","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2022/02/16 に Mattermost の新しいバージョン v6.4.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v6.4 is now available - Upgrade today Mattermost Self-Hosted Changelog   アップグレード時の注意事項 本バージョンからバージョンアップ時のDBスキーママイグレーション方法が新しくなったため、アップグレード前にバックアップを取っておくことを強く推奨します。 新しいマイグレーション方法では、マイグレーションの記録をDBに保存しておくために、すべてのマイグレーションが実行されます。マイグレーションの実行結果は db_migrations テーブルに記録されます。 また、マイグレーション処理が並列に行われていないようにするために db_lock テーブルを利用します。\nもしマイグレーション処理にエラーが発生した場合は、この2つのテーブルを確認してください。\n 各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(OSS 版)でも利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard)  Channels: Mattermost Cloudからの新しい移行方法 Mattermost Cloud上のデータをセルフホストのMattermostインスタンスへ移行する場合の新しいプロセスが公開されました。mmctlコマンドを利用したデータ移行方法となっており、セルフホストのMattermostインスタンスのデータをMattermost Cloudへ移行する方法も今後同じページで公開されるようです。\nMattermost Workspace Migration\nまた、Mattermost Cloudへの移行をサポートするツールとして、新たにAWAT (= Automatic Workspace Archive Translator) というツールが公開されています。\nhttps://github.com/mattermost/awat\nこれは、セルフホストのMattermostだけでなく、Slackのワークスペース情報などもMattermost Cloudのデータ形式に翻訳した上で移行するなど、Mattermostインスタンスの移行をサポートするツールのようです。\nPlaybooks: Team/Starter EditionでもPlaybookを無制限に作成可能に Mattermost v6.0でMattermostの機能として提供されるようになったPlaybooksの機能ですが、無償版のユーザーはPlaybookを一つしか作成できないよう制限されていました。 しかし、ユーザーからのフィードバックを受け、v6.4からは無償版のユーザーでもPlaybooksを無制限に作成できるようになりました。\nこの変更を受けてか、Playbooks機能を利用した事例に関する記事執筆を求めるWritingキャンペーンを開始しています。\nGet Paid to Write About Mattermost Playbooks - Mattermost\nBoards: テンプレートプレビュー Boardを新規に作成する際にBoardのテンプレートを選択することができますが、このテンプレートを選択する画面が新しくなり、テンプレートの内容をプレビューできるようになりました。\nまた、デフォルトで選択できるBoardテンプレートの内容が刷新され、さらに新しいテンプレートも追加されています。\nBoards: 画像を含む新たなアーカイブ形式 Boardの内容をエクスポートした際に、カードに添付された画像データなどもエクスポートファイルに含まれるようになりました。 また、エクスポートファイルの拡張子が .focalboard から .boardarchive に変更されました。古い .focalboard という拡張子でエクスポートされたデータも現時点ではインポートすることが可能ですが、今後のバージョンでインポートできなくなる予定です。\nBoards: カードバッジ カード内に説明やコメント、チェックリストなどが存在する場合、Board画面でカードバッジとして表示されるようになり、カードを開くことなく概要を確認することができるようになりました。\nカードバッジはBoardのプロパティ \u0026gt; Comments and Description で表示/非表示を切り替えることができます。\nBoards: URLプロパティの改善 URLプロパティを設定した場合、そのURLリンクを開くためには小さなリンクアイコンをクリックしなけれなりませんでしたが、本バージョンからURL文字列全体がリンクとしてクリックできるようになりました。\nBoards: カードの説明にGIFが利用可能に カードの概要にアニメーションGIFを利用することできるようになりました。\nその他の変更  アカウント設定というメニューは無くなり、設定という名前になりました  その他のトピック ChatOps導入ガイドの公開 Mattermostから、エンタープライズチームにChatOpsを導入するための7つのステップが公開されました。\n7 Steps to ChatOps for Enterprise Teams - Mattermost\nMattermostの機能や実際の事例と絡めながら、ChatOpsを組織に導入するステップが説明されています。\nおわりに 次のv6.5のリリースは 2022/03/16(Web)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-6.3/","title":"Mattermost 6.3の新機能","section":"post","date":"2022.01.18","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2022/01/14 に Mattermost の新しいバージョン v6.3.0 がリリースされました。\n本バージョンはExtended Support Release(ESR)としてリリースされており、2022/10/15までセキュリティFixなどのサポートが実施される予定です。(通常リリースのサポート期間は3ヶ月間)\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v6.3 is now available - Upgrade today Mattermost Self-Hosted Changelog   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(OSS 版)でも利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard)  (Enterprise) Playbook: 詳細な権限スキーム Playbookについての権限設定を詳細に行えるようになりました。\nシステムコンソール \u0026gt; ユーザー管理 \u0026gt; 権限で設定可能な権限一覧に、Playbooksに関する権限項目が表示されるようになりました。(権限設定について詳しくはAdvanced Permissionsを参照)\nまた、Playbookに関する新たなロールである Playbook Administrator(プレイブック管理者) が追加され、Playbookに対して可能な操作をユーザー単位で設定することができるようになりました。\nユーザーに対するロールは、Playbook編集画面で設定することができます。\nPlaybooksの権限やロールについては、Roles and Permissionsを参照してください。\nPlaybooks: 翻訳 Playbook機能もメッセージの翻訳が行われており、すでに12を超える言語で翻訳がスタートしています。日本語への翻訳も既に一部対応しています。\nPlaybooks: 通知の改善 通知機能のアップデートにより、チャンネルのノイズを減らし、重要な通知のみを受け取れるようになりました。\nチャンネル内に投稿される通知は全て削除され、タスクが割り当てられた場合や実行オーナーに設定された場合などの重要な通知はPlaybooks Botからダイレクトメッセージとして通知されるようになりました。\nPlaybooksの通知について詳しくはNotifications and Updatesを参照してください。\nBoards: General Availability Board機能が正式にGeneral Availability(GA)な機能となりました。\n2021年にオープンソースプロジェクトとして(Focalboard)開始されて以降、159人のコントリビューターと7,200を超えるGitHubスターを獲得しており、Trello/Notion/Asanaなどのプロプライエタリなプロジェクト管理ツールの競合となるオープンソースプロジェクトの中で最もポピュラーなものの一つになっています。\nBoards: 更新通知 カードの更新を見逃さないようにするため、カードをフォローすることが出来るようになりました。\nカードをフォローすることで、そのカードに対する変更内容をMattermostメッセージとして受け取ることができます。自分が作成したカードや@メンションされたカードは自動でフォローされます。\n(ローカル環境のMattermostにv0.12.0のPlugin版をインストールしてみましたが、うまく動作しませんでした。)\nBoards: アバター表示 カード内の人物プロパティを選択する際、名前の横にアイコン画像が表示されるようになりました。アイコンはコメント入力画面で@を入力した際も表示されます。\nその他の変更 特になし\nその他のトピック Desktop App Contributor Event Join the Mattermost Desktop App Contributor Event\nMattermost デスクトップアプリのコントリビューションイベントが 2022/2/4 まで開催されています。\nPlaywrightやRobot.jsを使ったE2Eテストに関するコントリビュートを増やすことが主な目的のようで、これらのツールを使ったDesktopアプリのE2Eテストについて興味がある場合は、Mattermostのテスト方法を知ったり、Mattermostの開発者にテストの書き方をレビューをしてもらうチャンスかもしれません。\nMattermost Community Awards The 2021 Mattermost Community Awards - Mattermost\n2021年中にMattermostへ貢献をした3,400名のうち、目立った貢献をしたコントリビューターを表彰するMattermost Community Awardsに Top Overall Mattermost Contributors として選出していだだきました。\n Yusuke Nemoto\nYusuke is proof that you can have a huge impact on an open source community without contributing large volumes of code. To start, he’s our unofficial Japanese diplomat and has been at the center of our community growth in Japanese audiences. He dedicates considerable time to maintaining Japanese translations of Mattermost release announcements on his personal blog and is highly active in our localization community for Japanese translations. He’s also active on social media, where he maintains our community-run Japanese Twitter account. All the while, Yusuke contributes code to multiple Mattermost repos regularly.\n おわりに 次のv6.4のリリースは 2022/02/16(Web)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/life/money-pipeline/","title":"Whimsicalでお金のパイプラインを描いてみた","section":"post","date":"2022.01.14","body":"背景 以下のPodcastで @yuya_takeyamaさん がお金のパイプラインについて話していたのを聴いた。\nMiddle Aged Developers: Managing money like a CI/CD pipeline on Apple Podcasts\nお金のパイプラインとは、ざっくりいうと自分を取り巻くお金の流れをCI/CDパイプラインのように考えようというもの。\n自分は、クレカ作成や投資や公共料金の払込みなど、イベント発生した時に調べてやりはするけど、見直すのは気が向いたときに〜みたいな感じだったので、どこでどう支払いが繋がっているのかなどは都度調べないと思い出せないような状態だった。 ちょうど年末年始に子供の口座を作るイベントが発生するなど、諸々の資産管理を見直そうと思っていたところだったので、ついでにパイプラインを描いてみようと思った。\nパイプライン チキンなので具体名は載せないけど、Whimsical使ってこんなふうに描いてみた。\nWhimsicalはアイコンもモダンな感じだし、コネクタも扱いやすいので描いてて楽しい。PNG形式でExportできるので、ブログ用にサクッとダイアグラムを描きたいだけの時とかは機能的に十分な感じ。無償枠だと置けるオブジェクト数に限りがあるけど、個人で使う分にはそんなに問題にならなそう。\n描いてみた感想 パイプラインとして可視化することで「ここはこの金融機関にした方が繋げやすそう」とか「ここの支払いこっちでやった方が良いじゃん」とかが見えてくるので体験として良かった。 また、Whimsicalでは、各オブジェクトにコメントを書くことが出来るため、「そのオブジェクトに求められる要件」みたいなのを書いておくことで、後々サービスの改悪などで移行が必要になった場合に便利になりそうという期待もある。\nあと、家庭における支払いはだいたい自分が担当しているのだけど、自分にもしものことがあったときのためにお金の流れを可視化しておくのは良いと思った。リストよりフローの方がどこから対処したら良いか分かり易いだろうし。(ただ、これはCIパイプラインとか普段から考えてる職業だからかもしれない)\n"},{"ref":"https://blog.kaakaa.dev/post/life/music-2021/","title":"2021年 音楽振り返り","section":"post","date":"2021.12.28","body":"今年聞いた音楽の振り返り。\n メタル民。スラッジ/ドゥーム/サイケな感じが好き。 サブスクはApple Music BGMとしてリピートで流し続けることが多いので、再生回数多くなりがち  Top 10 Albums Apple Musicでは、1年の間によく聞いた音楽のプレイリストが自動で作られていて、その元データと思しき情報を一部参照することができる。\nhttps://Replay.music.apple.com/up\nその中からTop 10アルバムをピックアップ。\n   No. Artist Name Year 再生回数     1 Kendrick Lamar DAMN. 2017 343   2 α Healing 眠れるディズニーオルゴール 2019 332   3 Mastodon Hushed and Grim 2021 222   4 The Album Leaf Into the Blue Again 2006 218   5 Kendrick Lamar To Pimp a Butterfly 2015 209   6 Relax α Wave ぐっすり眠れるα波 〜 ディズニー プレミアム・オルゴール・ベスト 2015 183   7 Opeth In Live Cconcert at the Royal Albert Hall 2010 167   8 下村陽子 聖剣伝説 Legend of Mana (Original Soundtrack) 2004 162   9 Robert Glasper Experiment Black Radio 2012 155   10 The Album Leaf In a Safe Place 2004 142    2,6のオルゴール系は、子供を寝かしつけるときに流してたもの。\nOpeth/下村陽子は昔から聴いているBGM。\nKendrick Lamar 1番聴いたのは Kendrick Lamar / DAMN.. Kendrickは5位にも To Pimp a Butterfly も入ってるので、よく聴いてたらしい。ラップ系は普段聞かないけど、Rate Your MusicのAll Time Bestで評価が高いのを見て、ちょっと聴いてみようかなと思ったのがきっかけ。暗め?のトラックが印象的で結構好きだった。ラップ系の曲はラップが主体なので、後ろで鳴ってるトラックはあまり展開が無いのが多く、その辺りがドゥームメタルと通じるところがあるのかな。\n   Mastodon Mastodon / Hushed and Grim は10月末発売だったけど、新譜が出るたびにLP買うぐらい好きなので再生回数が多い。今作のアートワークはCrack the Skyeまでの作品を手がけていたPaul Romanoが久しぶりに携わってるらしいのでLP来るの楽しみ(発送ミスで遅延中)。今作はミドルテンポの曲が多く、まったり聴ける感じ。メンバーが出てるMVは久しぶりだな。\n  The Album Leaf 4位と10位に入ってる。The Album Leafは学生時代に結構聴いていて、ふとしたタイミングで思い出して流してた。好きなアーティストとして名前をあげる事はあまりなかったけど、曲はずっと印象に残ってる。幻想的だけど哀しさ・寂しさみたいなのを感じる。ノスタルジー。\n  Robert Glasper experiment Robert Glasper Experiment / Black Radio は、 Kamasi Washington / Dinner Party 経由で聴いてた。 Art Science の方が聴いてた印象あったけど、 Black Radioの方が回数多かったか。他にも Esperanza Spalding, Nate Smith あたりをよく流してた記憶。 Esperanza Spalding の新譜はピンと来なかったけど。\n  この Nate Smith / Square Wheel のコーラス入るところの強引な転調好き。(Robert Glasperじゃない)\nFavorite Floating Points, Pharoah Sanders, The London Symphony Orchestra / Promises いろんなメディアの年間ベストで高評価を取っているので聴いてみたらハマった。\nアルバム全体を通して1小節の短いフレーズを主軸にサックスやボーカルの短いフレーズが散発的に現れ、最終的にはLondon Symphony Orchestraと絡みながら壮大な展開をしていく。アルバム通して音数は少ないのにとても印象に残るアルバムだった。\n  この動画のPharoah Sanders、めっちゃ雰囲気ありますね(語彙)。\n  Mdou Moctar / Afrique Victime 中東系?のメロディラインに民族的な歌唱を載せてるんだけど、絶妙に聴けるロックになってる感じ。ニジェール出身で砂漠のジミヘンと呼ばれてるらしい。\n  オバマ元大統領のFavorite Music of 2021にも入ってたり、各種年間ベストでよく名前が出てたりする。\nI\u0026#39;ve always enjoyed listening to a wide variety of music, so it’s no surprise that I listened to a little bit of everything this year. I hope you find a new artist or song to add to your own playlist. pic.twitter.com/g6kBzAbrZG\n\u0026mdash; Barack Obama (@BarackObama) December 17, 2021  Cynic / Ascension Codes 2015年の来日公演直後の解散騒動から、2020年には初期の主要メンバーだったSean Maloneが亡くなり、Paul Masvidalの個人プロジェクトのような形でリリースされた作品。(2015年の解散騒動と引き金となり、そのまま脱退したSean Reinertも2020年に亡くなってた模様…)\n旧作のようなテクデス感はだいぶ抑えめで、メタル感は残ってはいるけど電子音も多く使われており、全体的に壮大な感じに仕上がっている。なんとなくメタル側からアプローチしたSquarepusherみたいな印象を受けた。\n  Pickups 今年知った気になる音楽たち。YouTubeの Stoned Meadow of Doom チャンネル経由で知ったものがほとんど。\nMalammar/Mazza (2021) スペインのインストDoom/Sludge。\nヘヴィな動のパートとホストメタルっぽい静なパートの塩梅が丁度良い。旧作も含めアートワークの感じも好み。\n  Onsegen Ensemble / Duel (2018) FinlandのProgressive? Rock。\nなんと表現すれば良いのか分からないけど、民族的なリズムをベースになんか色々やってる。Swansとかに近いかな？こういうリズムはっきりしてるけど掴みどころない感じの音楽が好きなようだ。\n  Monkey Okay / The Long Haul of Cercopithecoidea (2020) デンマークのサイケストーナー。\nこれも民族系のパートがあったり、サイケストーナーなフレーズがあったり、スペーシーな音作りだったり、最後の曲が20分超えてたり、なんかいろいろ。\n  以前の動画を見ると普通のストーナーっぽいので、2020年発表の今作で何かあったんだろうな。\nSomnuri / Somnuri (2017) 初期MastodonやBaroness系統のスラッジメタル。\nどこかのメディアでKaizenという曲が紹介されていて、曲名が気になって聞いてみたら、いい感じだった。リファクタリングするときに聴きたい。\n   いつも適当に聞いてるから、年末に書こうとすると結局年末あたりい聴いてたものの印象が強くなっちゃうな。\n最近Notionに聴いた作品のRatingを残す活動を始めたので、それがちゃんと続くといいな。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/merge-instances/","title":"Lessons learned from merging Mattermost instances","section":"post","date":"2021.12.20","body":"この記事はFUJITSU Advent Calender 2021の20日目の記事です。\n今回は、別々に運用されていた2つのMattermostインスタンスを合体させた事例について紹介します。\n変更履歴  2021/12/22: 移行時に実行したコマンド にて、Bulk Exportコマンドに--attachmentsオプションが付与されていなかったため追加 2021/12/22: 移行時に実行したコマンド について説明を追加  背景 社内では、オンプレミスで運用できるチャット基盤としてOSSのMattermostを利用しているところが数多くあります。もちろんコミュニケーション基盤は統一的なインスタンスで運用できているのが望ましいですが、MattermostはOSSで誰でも使えるということもあり、過去に同時発生的に有志によるMattermostの運用が始まってしまったため、それぞれのインスタンスでの運用が続いているという状況があります。\n今回統合を行った2つのMattermostインスタンスは、幾度かの組織変更により両方のインスタンスにアカウントを持つユーザーが増えてきているということもあって、以前からユーザーの利便性のためにも統合したいねという話が出ていました。今年の4月に大きなグループ再編の動きがあったことから、この流れに乗ってMattermostインスタンスの統合に踏み切りました。\nMattermostのインスタンスを統合した事例は今まで目にしたことは無いため、公開されている事例としては世界初になるのではないかと思っています(あったら教えて欲しい)。(refs: Mattermost Forum)\n免責事項 Mattermostは、2つのインスタンスの統合を公式にはサポートしていません。 本記事で述べる内容は非公式の手順であるため、データの損失や欠落を招く可能性があります。その点に留意してください。\n最終的に統合作業を完了させていますが、以下のような制限事項がありました。\n 統合機能（ウェブフックやスラッシュコマンド）は手動での移行作業が必要  API の URL が変わるので、内向きのウェブフックなどは連携アプリ側も書き換える必要がある   ピン留めされた投稿のリストが消える 保存済みの投稿のリストが消える チャンネルやダイレクトメッセージが全部未読になる プロフィール画像が移行されない 投稿に付けられた絵文字リアクションが消えることがある 投稿に対する URL が変わるので、Mattermost内に書き込まれた投稿へのリンクが切れてしまう チャンネルの作成者と作成日時の情報が消えてしまう カスタム絵文字の登録者の情報が消えてしまう 移行前と移行後でユーザー名が異なる場合、投稿内の @メンション がリンクからテキストになってしまう チャンネルへの参加/脱退やヘッダー変更を伝えるシステムメッセージがユーザーの投稿になってしまう (対応中) 投稿を後から編集した場合にメッセージに表示される (編集済) のフラグが消えてしまう (対応中)  これらの点については、事前にユーザーに通知をし、制限事項を認識してもらったうえでインスタンスの統合を実施しました。\nMattermostの機能について Mattermostには、2つの異なるインスタンス間の共有や移行に関する以下のような機能があります。\nShared Channel 複数インスタンス間でチャンネルを共有する機能です。\n今回は、ユーザーの利便性のためにインスタンス自体を統合したいという要求であったため、この方法は採用しませんでした。(また、この機能は有償版限定のためそもそも採用できませんでした)\nMigration Guide Mattermostは、稼働中のインスタンスを別サーバーを移行するための手順を公開しています(Slackなどの他のメッセージングサービスからからMattermostへ移行する手順の紹介などもあります)。\nただし、この手順によるMattermostサーバーの移行は、データベースごと新しいインスタンスへ移行する方式のため、既にデータの存在するMattermostインスタンスへの移行には適用できませんでした。\nBulk Export / Bulk Import(Loading) Bulk Export/Bulk Import(Loading) 機能は、インスタンス上のデータをファイル形式でExportする機能と、Exportされたファイル形式を元にImport処理を行う機能です。\nこれらの機能も、Mattermostインスタンス上のデータをアーカイブとして出力することを目的とした Bulk Export と、他のメッセージングシステム(Slack, HipChat等)からExportしたデータをMattermostへImportする際のデータ形式を定めた Bulk Import の機能という位置づけであり、2つのMattermostインスタンスの統合をサポートしているものではありません。単純に Bulk Export したデータを、そのまま既にデータの存在するMattermostインスタンスへ Bulk Import すると、様々なデータの不整合が発生する可能性があります。\nしかし、その他にインスタンスを統合する有効な手段が無かったため、今回はこのBulk Export/Bulk Import(Loading)の機能をベースにインスタンス統合の作業を行いました。\n本記事では、 Bulk Export/Bulk Import 機能を利用したインスタンス統合において発生した問題と、対処方法について紹介していきます。\nMattermostインスタンス統合作業について はじめに インスタンスの統合を行う際には、以下のことが重要です。\n 移行元と移行先のMattermostのバージョンを合わせること インスタンス統合結果が想定通りのものとなっていることを確認できるテスト環境を用意すること  今回は以下のような2つのインスタンスを統合しました。\n    移行元 移行先     Mattermost Version v5.35.2 v5.34.0   ユーザー数 301 685   投稿数 数十万程度 100万程度    (早速バージョン合ってないですが、移行元からデータをExportする際にバージョン上げないと上手く動かない部分があり\u0026hellip;)\nBulk Export/Bulk Import機能について Mattermostの Bulk Export 機能は、Mattermost内の各リソースを以下のようなJSONL形式で出力できる機能です。\n{ \u0026quot;type\u0026quot;: \u0026quot;version\u0026quot;, ... } { \u0026quot;type\u0026quot;: \u0026quot;team\u0026quot;, \u0026quot;team\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;TeamA\u0026quot;, ...} } { \u0026quot;type\u0026quot;: \u0026quot;team\u0026quot;, \u0026quot;team\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;TeamB\u0026quot;, ...} } { \u0026quot;type\u0026quot;: \u0026quot;channel\u0026quot;, \u0026quot;channel\u0026quot;: { \u0026quot;team\u0026quot;: \u0026quot;TeamA\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;ChannelA1\u0026quot;, ...} } { \u0026quot;type\u0026quot;: \u0026quot;channel\u0026quot;, \u0026quot;channel\u0026quot;: { \u0026quot;team\u0026quot;: \u0026quot;TeamA\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;ChannelA2\u0026quot;, ...} } { \u0026quot;type\u0026quot;: \u0026quot;user\u0026quot;, \u0026quot;user\u0026quot;: { \u0026quot;username\u0026quot;: \u0026quot;user001\u0026quot;, ...} } { \u0026quot;type\u0026quot;: \u0026quot;user\u0026quot;, \u0026quot;user\u0026quot;: { \u0026quot;username\u0026quot;: \u0026quot;user002\u0026quot;, ...} } { \u0026quot;type\u0026quot;: \u0026quot;user\u0026quot;, \u0026quot;user\u0026quot;: { \u0026quot;username\u0026quot;: \u0026quot;user003\u0026quot;, ...} } . . . { \u0026quot;type\u0026quot;: \u0026quot;post\u0026quot;, { \u0026quot;team\u0026quot;: \u0026quot;TeamA\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;ChannelA1\u0026quot;, \u0026quot;user\u0026quot;: \u0026quot;user001\u0026quot;, ...} } { \u0026quot;type\u0026quot;: \u0026quot;post\u0026quot;, { \u0026quot;team\u0026quot;: \u0026quot;TeamA\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;ChannelA1\u0026quot;, \u0026quot;user\u0026quot;: \u0026quot;user001\u0026quot;, ...} } . . . Mattermost内のリソースが1行のJSONデータとして各行に記録されており、Bulk Import実行時も1行ずつ処理されていきます。\n投稿に対する添付ファイルや、カスタム絵文字のファイルの実体などは、このJSONLファイルとは別に出力されており、Bulk Import実行時に併せて読みだされてMattermostへ登録されていきます。\nExportされるデータ種別やその内容については、公式ドキュメントを参照してください。 https://docs.mattermost.com/manage/bulk-export-tool.html\n移行時に実行したコマンド 統合実行時のコマンドは以下になります。\nまず、移行元のサーバーでBulk Exportのコマンドを実行します。\nこの時、--configオプションの値には起動しているMattermostサーバーのconfig.jsonを指定します。また、mattermost-export-YYYY-MM-DD.txtが出力ファイルとなるのですが、このファイルの出力先フォルダにMattermostの添付ファイルを格納しているdata/フォルダが存在すると、その内容がすべて0byteのファイルで上書きされてしまいます。Bulk Exportコマンドの出力先には十分注意してください。\n# Export $ ./bin/mattermost --config ~/config.json export bulk ~/mattermost-export-YYYY-MM-DD.txt --attachments 先にも述べましたが、既にデータの存在するインスタンスに対して、ExportしたJSONLファイルをそのままImportしようすると、データの不整合が発生する可能性があります。そのため、Exportされたデータに対してsedによる置換を実施しています。また、Bulk Import実行時にエラーとならないようファイルの拡張子を.jsonlに変更しています。sedによる置換内容については以降のセクションで紹介していきます。\n# Edit exported data $ sed -f migration.sed ~/mattermost-export-YYYY-MM-DD.txt \u0026gt; ~/mattermost-import-YYYY-MM-DD.jsonl 最後に、Bulk Exportによって出力されたdata/,exported_emoji/,mattermost-import-YYYY-MM-DD.jsonlを移行先のMattermostサーバーへコピーし、Bulk Importを実行します。この時、mattermost-import-YYYY-MM-DD.jsonlとdata/,exported_emoji/フォルダは同じフォルダ内に置いておく必要があります。\n# Validation $ ./bin/mattermost --config ~/config.json import bulk ~/mattermost-import-YYYY-MM-DD.jsonl --import-path ~/data --validate # Import $ ./bin/mattermost --config ~/config.json import bulk ~/mattermost-import-YYYY-MM-DD.jsonl --import-path ~/data --apply (余談ですが、今回統合を実施した環境では、Mattermostの管理CLIツールがmattermostコマンドからmmctlコマンドへ移行する過渡期であり、ところどころの調査ではmmctlコマンドを利用していたりもします。Mattermost v6からは管理CLIコマンドの大部分がmmctlコマンドに集約されているため、Mattermost v6移行の環境で統合を実施する場合は実行コマンドが変わるかもしれません。)\n統合実施時に注意が必要なデータ Team object Example Team object\n{ \u0026#34;type\u0026#34;: \u0026#34;team\u0026#34;, \u0026#34;team\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;team-name\u0026#34;, \u0026#34;display_name\u0026#34;: \u0026#34;Team Display Name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;O\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The Team Description\u0026#34;, \u0026#34;allow_open_invite\u0026#34;: true } } name 移行元/移行先で チーム名 (name)が同じだった場合、移行元と移行先のチームがマージされる (移行先のチームに移行元の同名チーム内のチャンネルが作成される) ような動作になります。\n今回の移行では、移行元/移行先で異なるチーム名で運用していましたが、チームを統一するために移行元のチーム名を移行先のメインで使われているチーム名に変更しました。\nChannel object Example Channel object\n{ \u0026#34;type\u0026#34;: \u0026#34;channel\u0026#34;, \u0026#34;channel\u0026#34;: { \u0026#34;team\u0026#34;: \u0026#34;team-name\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;channel-name\u0026#34;, \u0026#34;display_name\u0026#34;: \u0026#34;Channel Name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;O\u0026#34;, \u0026#34;header\u0026#34;: \u0026#34;The Channel Header\u0026#34;, \u0026#34;purpose\u0026#34;: \u0026#34;The Channel Purpose\u0026#34;, } } team/name 移行元/移行先の両方に同じ　チーム名/チャンネル名　を持つチャンネルが存在する場合、2つのチャンネルの投稿が1つのチャンネルにマージされます（すごい）。 今回のインスタンス統合では、移行元/移行先で同名となるチャンネルについて事前に調査を行い、マージを希望しないチャンネルについては、移行元のインスタンスのチャンネル名に 特定のprefixを付ける ことでマージが実施されないように対処しました。一部、マージを希望するチャンネルについては同名チャンネルのまま統合作業を行いましたが、特に問題なく移行元/移行先のチャンネルのマージが行われました(すごい)。\nただし、Mattermostでチームを作成した時に自動で作成される town-square、off-topic チャンネルには注意が必要です。\nこの2つのチャンネルは、ユーザーがチームに新しく参加した時に自動で参加するチャンネルであり、事前にチャンネル名を変更してしまうと、新たにユーザーをチームに参加させたときにエラーが発生してしまいます(off-topicはUIから名前を変更できますが、town-squareはシステム的な固有値だったはず)。この2つのチャンネルのチャンネル名を変更する場合はExportされたデータ上でチャンネル名を編集した方が良いです。\n また、Mattermost内に日本語を含むチャンネル表示名がある場合も注意が必要です。\nMattermostではチャンネルの名前を表す属性として チャンネル名 (name) と チャンネル表示名 (display_name) の2つがあります。普段Mattermost画面上で見ている名前は チャンネル表示名 (display_name) で、URLに使われる文字列が チャンネル名 (name) です。\nMattermostで画面上からチャンネルを作成する際に入力する名前は チャンネル表示名 (display_name)になりますが、表示名を入力すると自動で チャンネル名 (name)の方も同じ文字列で設定されます（チャンネル名のみを変更することも可能）。英語のみで構成されている チャンネル表示名 であれば同じ値が設定されますが、もし日本語などのマルチバイト文字が含まれる場合、Mattermostはそれらのマルチバイト文字を無視して英語部分だけで チャンネル名 を設定します。そのため「○○PJ(プロジェクトの意味)」のような、日本語を含む短い チャンネル表示名 を設定している場合、意図せず チャンネル名 (name) が重複することが有ります。\nこのため、日本語を含むチャンネル名が多く存在する場合、チャンネル名のConflictが発生しやすくなっており、事前の調査がとても重要になります。\n また、アーカイブ済みのチャンネルは Bulk Exportの対象になりません。 今回はアーカイブ済みのチャンネルも移行するために、Bulk Export実行前に移行元インスタンスのアーカイブされているチャンネルを復元し、移行先へImportした後に再度アーカイブを実行しました。\nまた、移行元のチャンネル名と同名のチャンネルが移行先にあり、かつ、移行先のチャンネルがアーカイブ済みだった場合、Import処理が失敗します。この場合は、当該チャンネルのデータを削除するか、アーカイブを解除する対処が必要です。\nUser object Example User object\n{ \u0026#34;type\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;profile_image\u0026#34;: \u0026#34;avatar.png\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;email@example.com\u0026#34;, \u0026#34;auth_service\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;auth_data\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;passw0rd\u0026#34;, \u0026#34;nickname\u0026#34;: \u0026#34;bobuser\u0026#34;, \u0026#34;first_name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;last_name\u0026#34;: \u0026#34;User\u0026#34;, \u0026#34;position\u0026#34;: \u0026#34;Senior Developer\u0026#34;, \u0026#34;roles\u0026#34;: \u0026#34;system_user\u0026#34;, \u0026#34;locale\u0026#34;: \u0026#34;pt_BR\u0026#34;, \u0026#34;teams\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;team-name\u0026#34;, \u0026#34;theme\u0026#34;: \u0026#34;{\\\u0026#34;awayIndicator\\\u0026#34;:\\\u0026#34;#DBBD4E\\\u0026#34;,...}\u0026#34;, \u0026#34;roles\u0026#34;: \u0026#34;team_user team_admin\u0026#34;, \u0026#34;channels\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;channel-name\u0026#34;, \u0026#34;roles\u0026#34;: \u0026#34;channel_user\u0026#34;, \u0026#34;notify_props\u0026#34;: { \u0026#34;desktop\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;mark_unread\u0026#34;: \u0026#34;all\u0026#34; } } ] } ] } } username/email 移行元/移行先の両方のインスタンスにアカウントを持っているユーザーがいる場合、アカウントのユーザー名/メールアドレスに応じて対処が必要になります。\n 移行元/移行先のアカウントが\u0026hellip;  同じユーザー名 / 同じメールアドレス: 対処不要 同じユーザー名 / 異なるメールアドレス: 移行元のメールアドレスに書き換えられる 異なるユーザー名 / 同じメールアドレス: Import処理でエラーが発生するため対処が必要 異なるユーザー名 / 異なるメールアドレス: 移行元のユーザー情報のユーザーが作成される    2.の事象については、もし、別々の人が移行元/移行先で同じユーザー名を使っていた場合、アカウントを乗っ取られたような動作になるので対処が必要になります。 4.の事象については、本来は正常動作ですが、同じユーザーがが移行元/移行先で異なるユーザー名 / 異なるメールアドレスのユーザーを持っていた場合、そのユーザーに対して2つのアカウントが生成されることになります。本来あまり起こらない事象だとは思いますが、過去に全社的にメールアドレスのドメイン名が微妙に変更になったことが有り(以前のメールアドレスも利用可能)、このような事象が発生しやすくなっていました。\nこれらの点についても、事前にユーザー名/メールアドレスの情報を突合せ、問題が発生する可能性のあるアカウントについては事前にユーザー名/メールアドレスの変更をお願いしたり、移行先のデータが書き換えられないようExportデータの内容を変更するなどして対処しました。\nauth_service/auth_data 移行元/移行先で異なる認証サービスを利用していた場合、Export後のJSONLファイルに対する対処が必要です。\n今回の統合においては、移行元のMattermostではGitLab認証を利用しており、移行先ではMattermost自身のパスワード認証を利用していました。ただ、移行元で利用していたGitLabは、富士通研究所としてGitHub Enterpriseが導入されたこともあってMattermost認証のためのアカウント管理機能ぐらいしか使われていなかったため、統合に併せてアカウント管理も移行先のMattermostに寄せることにしました。\n認証関連の情報は、 User object が持つ auth_service/auth_data 要素として格納されているため、Import実施前にこれらの要素を{..., \u0026quot;auth_service\u0026quot;:null, ...}のみ(auth_data要素は削除)に編集しました。これにより、Import実施時にシステム側でパスワードが生成・設定されるようになります。システム側で設定されたパスワードを知る術がないので、移行先のインスタンスでパスワードリセットの操作を行う必要がありました。\nroles ユーザーの権限に関するデータであるrolesは 非常に注意が必要です。\n移行元/移行先の両方に同じユーザー名のアカウントが存在した場合、そのユーザーの権限はExportデータ内のrolesの値で上書きされてしまいます。もし、移行先のシステム管理者ユーザーが移行元システムの一般ユーザー権限で上書きされ、移行先にシステム管理者がいなくなってしまった場合、そのインスタンスの運用を続けることが困難になってしまいます。統合にあたって事前にテストするなどして、このような状況が発生しないよう十分に注意してください。\nlocale/theme/notify_props/\u0026hellip; その他、ユーザーのアカウントに関する設定（表示言語、テーマ、通知設定など）も、移行元/移行先で同じユーザー名のユーザーが存在した場合、移行元のデータで置き換えられてしまいます。\nPost object Example Post object\n{ \u0026#34;type\u0026#34;: \u0026#34;post\u0026#34;, \u0026#34;post\u0026#34;: { \u0026#34;team\u0026#34;: \u0026#34;team-name\u0026#34;, \u0026#34;channel\u0026#34;: \u0026#34;channel-name\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;username\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;The post message\u0026#34;, \u0026#34;props\u0026#34;: { \u0026#34;attachments\u0026#34;: [{ \u0026#34;pretext\u0026#34;: \u0026#34;This is the attachment pretext.\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;This is the attachment text.\u0026#34; }] }, \u0026#34;create_at\u0026#34;: 140012340013, \u0026#34;flagged_by\u0026#34;: [ \u0026#34;username1\u0026#34;, \u0026#34;username2\u0026#34;, \u0026#34;username3\u0026#34; ], \u0026#34;replies\u0026#34;: [{ \u0026#34;user\u0026#34;: \u0026#34;username4\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;The reply message\u0026#34;, \u0026#34;create_at\u0026#34;: 140012352049, \u0026#34;attachments\u0026#34;: [{ \u0026#34;path\u0026#34;: \u0026#34;/some/valid/file/path/1\u0026#34; }], }, { \u0026#34;user\u0026#34;: \u0026#34;username5\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Other reply message\u0026#34;, \u0026#34;create_at\u0026#34;: 140012353057, }], \u0026#34;reactions\u0026#34;: [{ \u0026#34;user\u0026#34;: \u0026#34;username6\u0026#34;, \u0026#34;emoji_name\u0026#34;: \u0026#34;+1\u0026#34;, \u0026#34;create_at\u0026#34;: 140012356032, }, { \u0026#34;user\u0026#34;: \u0026#34;username7\u0026#34;, \u0026#34;emoji_name\u0026#34;: \u0026#34;heart\u0026#34;, \u0026#34;create_at\u0026#34;: 140012359034, }], \u0026#34;attachments\u0026#34;: [{ \u0026#34;path\u0026#34;: \u0026#34;/some/valid/file/path/1\u0026#34; }, { \u0026#34;path\u0026#34;: \u0026#34;/some/valid/file/path/2\u0026#34; }] } } Attachments 投稿に添付されたファイルの拡張子と実際に添付されたファイルの形式が異なる場合、Import処理でエラーが発生します。\nImport処理では、投稿に添付された画像ファイルなどに対してサムネイルを作成する処理が自動で実行されます。この時、Mattermostはファイル名の拡張子を元にサムネイル作成処理を実行しようとしますが、ファイル名の拡張子と実際のファイル形式が異なる場合、エラーが発生します。\n今回の統合作業でも、移行元のインスタンスに、.gifという拡張子を持つJPEGファイルなどが存在したため、以下のようなエラーが発生しました。\nGetInfoForBytes: Could not decode gif., gif: can\u0026#39;t recognize format \u0026#34;\\xff\\xd8\\xff\\xe0\\x00\\x10\u0026#34; Error occurred on data file line 87634 {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1624515819.9272816,\u0026#34;caller\u0026#34;:\u0026#34;app/server.go:841\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Stopping Server...\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1624515819.9273949,\u0026#34;caller\u0026#34;:\u0026#34;app/web_hub.go:103\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;stopping websocket hub connections\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1624515819.9294012,\u0026#34;caller\u0026#34;:\u0026#34;app/server.go:914\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Server stopped\u0026#34;} Error: GetInfoForBytes: Could not decode gif., gif: can\u0026#39;t recognize format \u0026#34;\\xff\\xd8\\xff\\xe0\\x00\\x10\u0026#34; Emoji object Example Emoji object\n{ \u0026#34;type\u0026#34;: \u0026#34;emoji\u0026#34;, \u0026#34;emoji\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;custom-emoji-troll\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;bulkdata/emoji/trollolol.png\u0026#34; } } name 移行元/移行先で同名のカスタム絵文字が登録されている場合、移行元の画像でカスタム絵文字が上書きされて しまいます。 今回の移行では、同名のカスタム絵文字については移行元のデータを削除することで対応しました。もし、Exportデータ内でカスタム絵文字の名前を変更するという対処を行う場合、投稿のデータにもリアクションとしてカスタム絵文字名が使用されている場合があるため、併せてそちらも修正する必要があると思います。\nOSSへの貢献 Mattermost Bulk Export/Importツールについてはあまり利用例がないのか、移行にあたっていくつか問題が発生しました。これらの問題について、MattermostへIssueによる報告や、PRによる改善要望を送っています。\n解決済み  [PR] Bulk export fails due to missing user · Issue #11659 · mattermost/mattermost-server  投稿にリアクションを付けていたユーザーをインスタンスから削除した場合、Bulk Export実行時にエラーとなるバグの報告と修正 2年以上前のIssueですが、この頃から少しずつ移行に向けて進捗していました   [PR] Fix bulk export file when exporting reply threads by kaakaa · Pull Request #17849 · mattermost/mattermost-server  メッセージスレッド内に多くのファイルが添付されている投稿をエクスポートする場合に、スレッド内の全添付ファイルを各投稿の情報として保持してしまうという問題の修正です。   [PR] Add bulk export options by kaakaa · Pull Request #4688 · mattermost/docs  公式ドキュメントにて、Bulk Exportコマンドのオプションの説明が不足していたため、説明を追加。    未解決  [Issue] Bulk import makes the system message the user message · Issue #18640 · mattermost/mattermost-server [PR] Added support for exporting and importing the type and edit_at of a post by kaakaa · Pull Request #18992 · mattermost/mattermost-server  Bulk Export/Importによるデータ移行を実施した際、システムメッセージが移行先でユーザーメッセージとして表示されてしまう問題   [Issue] Bulk export writes 0byte data to existing files · Issue #18699 · mattermost/mattermost-server  Bulk Exportコマンドを --attachments オプション（添付ファイルをエクスポートするオプション）付きで実行した際、コマンド実行ディレクトリにMattermostのデータファイル格納フォルダ(data/)が存在する場合にデータファイルを0バイトで上書きしてしまう問題   [Issue] Doing bulk export/import drops saved post data · Issue #18641 · mattermost/mattermost-server  Bulk Export実行時、保存された投稿の情報がExport対象にならない問題   [Issue] There is no way to list archived private channels if the user isn\u0026rsquo;t the member of its channel · Issue #401 · mattermost/mmctl  Mattermostの新しいCLIツール mmctl では、privateかつarchivedなチャンネルの一覧を取得できない問題    さいごに 今回は、MattermostのBulk Export / Bulk Import(Loading)の機能を使い、2つのMattermostインスタンスの統合を行いました。そして、インスタンス統合時に発生するデータ不整合と、その不整合にどのように対応したかについて紹介しました。\n2つのMattermostを完全な形で移行することは出来ませんでしたが、制限事項の部分以外は移行後も大きな問題が起こることも無く、現時点で数か月運用が出来ています。\n今回、インスタンス統合実施時に発生する問題に対処しつつ作業を完遂出来たのは、MattermostがOSSであったという点が大きいと思っています。問題が発生しても、データとコードを読み解くことで問題の原因を特定でき、原因に対してソフトウェアの方を修正するという対処も取りながら作業を進めることが出来ました。Mattermostは、自分たちのコミュニケーションのデータを自分たちの自由にできないフラストレーション から生まれたプロダクトであり、今回はその恩恵を十分に受けることができたと思います。(refs: The Mattermost Origin Story - The Craft of Open Source - Flagsmith)\n謝辞 今回、記事を公開しているのは私ですが、実際のインスタンス統合作業にはあまり関れておらず、普段からMattermostに関する記事を書いているということで、記事公開役を拝命しております。\n実際のインスタンス統合作業は、@zenjiro0123さんが 移行元のMattermostインスタンスの管理者 兼 今回の統合のメインの実施者として進めてくれました。また、@zenjiro0123さんが途中から育休に入るということで、岩田 聡さん(任天堂じゃない方)も、様々な面でサポートに回ってもらいました。また、統合作業のテストについては、移行先のMattermostインスタンスの管理者である@lastisさんに協力いただき、最終的な移行作業も@lastisさんに実行してもらいました。\n皆様、お疲れさまでした。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-6.2/","title":"Mattermost 6.2の新機能","section":"post","date":"2021.12.20","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2021/12/16 に Mattermost のメジャーバージョンアップである v6.2.0 がリリースされました。 また、2021/12/17にセキュリティFixを含むv6.2.1がリリースされています。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v6.2 is now available - Mattermost Mattermost Changelog   アップグレード時の注意事項 本バージョンより、チャンネル補完機能の対象に非公開チャンネルが追加されます。 それに伴い、 BleveやElasticsearchを利用した自動補完機能を有効にしている場合、インデックスの再構築が必要になります。この処理は時間がかかる可能性があるため、アップグレードする際は自動補完機能を一時的に無効にし、バックグラウンド処理によるインデックス構築が完了した後に、再度自動補完を有効にすることをお勧めします。\n 各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(OSS 版)でも利用可能な機能です。\nまた、各見出しにPrefixとしてMattermostの機能分類を記述しています。\n Channels: 従来のチャット機能 Playbook: Mattermost v6.0から追加されたインシデント管理機能 Boards: Mattermost v6.0から追加されたKanbanボード機能 (Focalboard)  Channels: 非公開チャンネルの自動補完 Mattermostでメッセージを投稿する際、メッセージ入力欄に~を入力するとチャンネル一覧が表示され、このチャンネル一覧から選択することでチャンネルへのリンクを簡単に入力できるという機能がありました。 今までのバージョンでは、この一覧に表示されるチャンネルは公開チャンネルのみでしたが、本バージョンからは自分が所属している非公開チャンネルも一覧に表示されるようになります。\nChannels: 返信スレッドに関する操作性改善 返信スレッドの折り畳み機能を有効にしている場合、スレッドビューにて表示するスレッドを↑、↓キーで切り替えることができるようになりました。\nまた、返信スレッドが存在する場合、メッセージのどの部分をクリックしても返信スレッドが表示されるようになりました。この機能は 設定 \u0026gt; 表示 \u0026gt; クリックしてスレッドを開くの設定から無効にすることもできます。\nPlaybooks: 実行中のPlaybookのフォロー 実行中のPlaybookをフォローする機能が追加されました。 Playbookの実行をフォローすることで、気にかけている作業の開始や完了、ステータス更新、期日の超過、レトロスペクティブ(振り返り)の公開などが通知されるようになります。また、Playbookの全ての実行を自動でフォローするよう設定することもできます。\nその他にも、Playbook検索機能やPlaybook共有URL、実行中のPlaybookのフィルタ条件の追加などの更新が行われています。\nBoards: カレンダー表示 Board上のカードをカレンダー上に表示できるようになり、締め切り管理がやりやすくなりました。\nデフォルトでは、カードの作成日をもとにカレンダー表示が行われますが、表示プロパティを切り替えることで、カードに設定されたプロパティの情報を元にカードを表示することができます。\nその他のトピック Mattermostのインスタンス統合により得た知見 弊社で2つのMattermostインスタンスを統合した事例について、アドベントカレンダーの記事として公開しました。\nLessons learned from merging Mattermost instances\n2つのMattermostインスタンスの統合は公式ではサポートされていなかったため、統合の際に問題となった点や対処方法、また失う可能性のあるデータ等についてまとめ増田。\n開発者の生産性に関するガイドの発行 Mattermostが、約300名の開発者に対する調査結果等をまとめた Unblocking Workflows: The Guide to Developer Productivity in 2022 という開発者の生産性に関するガイドを発行しています。\nおわりに 次のv6.3のリリースは 2022/01/14(Fri)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-6.1/","title":"Mattermost 6.1の新機能","section":"post","date":"2021.11.19","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nTwitter: @mattermost_jp で Mattermost に関する日本語の情報を提供しています。\nはじめに 2021/11/16 に Mattermost のメジャーバージョンアップである v6.1.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v6.1 is now available - Upgrade today Mattermost Changelog   アップグレード時の注意事項  v6.1へのアップグレード処理でデータベーススキーマの変更が行われます。v6へのメジャーアップデートほど大掛かりではないですが、多少時間がかかるため、アップグレード前に変更内容を確認することをことをおすすめします  スキーマ変更の内容と、所要時間の目安についてはMattermost v6.1.0 schema migration analysisに記述があります   オプションの検索エンジンとして搭載されているBleveの検索インデックスがScorch indexに変更されます。Scorch indexを採用することにより、ディスク使用量の削減ができるようです。  Mattermostサーバーのアップグレード後、システムコンソールからBleveインデックスの破棄と再生成を行うことでScorch indexに切り替えることができます 過去のバージョンで作成された検索インデックスでも動作はするため、インデックス種別を切り替えたくない場合、何も操作は必要ありません     各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(無償版)でも利用可能な機能です。\nChannels: チーム横断でのメンション検索 あなたへのメンションを含む投稿や、保存された投稿を一覧する機能は以前からありましたが、Mattermostのチームごとに管理されていたため、別のチームで行われたメンションや保存された投稿を確認するには、まずチームの切り替えを行う必要がありました。本バージョンから、所属している全チームのメンションと保存された投稿が一つの画面に表示されるようになったため、チーム切り替えを行うことなく別チームのメンション・保存投稿を確認できるようになりました。\nChannels: リアクションへのクイックアクセス 投稿メニューに最近使った絵文字が表示されるようになり、1-clickで簡単にリアクションをつけられるようになりました。\n設定 \u0026gt; 表示 \u0026gt; 1クリックでメッセージに反応するから、この機能のON/OFFをユーザーごとに設定することができます。\nChannels: 取り込み中状態の有効期間設定 Mattermostでは、\u0026ldquo;オンライン\u0026quot;や\u0026quot;離席中\u0026quot;など、ユーザーの現在の状態を設定することができます。この状態表示のうち取り込み中を選択する際、取り込み中の状態が継続する期間を設定することができるようになりました。 取り込み中を設定した場合、Mattermostからの通知が送信されなくなりますが、これが指定時間経過後に自動で解除され、通知が送信されるようになります。\nPlaybooks: プレビュー表示 本バージョンからPlaybookの内容をプレビュー表示できるようになりました。これにより、Playbookの概要を簡単に把握できるようになります。\nPlaybooks: TODO通知 Playbookの参加者とオーナーへ、割り当てられているタスクの一覧や期限超過の状態などを含む通知メッセージが届くようになりました。\n(画像は公式エントリから)\n/playbookコマンドを使い、通知をオフにすることや、任意のタイミングでTODOメッセージを受信することもできます。/playbookコマンドについては以下のドキュメントを参照してください。 Notifications and Updates\nBoards: ボード作成UIの改善 （以前のバージョンではサイドバー下部にあった）ボード作成ボタンがサイドバーの上部に移動しました。また、ボード作成画面も全画面形式に変更されています。\nBoards: メトリクス選択 以前のバージョンでは、Board内のカラム名の横にはそのカラムに属するカードの数が表示されるだけでしたが、この数値の集計方法を指定できるようになりました。\n例えば以下のような数値をカラムごとに集計して表示することができます。\n 指定したプロパティの内容が空のカードの数を表示する (重要な情報が未入力なカードを見つけやすくする) 機能の開発にかかる時間の合計を表示する 見積もり期間の範囲を表示する  Sum, Averageなどのメニューは、カードに数値プロパティが存在する場合のみ表示・選択できるようになります。\nBoards: @mention notification カードのコメントや説明部分で@メンションが行われると、その内容がChannels内にBoard BotからのDMとして通知されるようになりました。\nBoard: カードプレビュー カードへのリンクをチャット部分に投稿すると、その内容をプレビュー展開できるようになりました。プレビュー部分をクリックすることで、Boardが開き、該当のカードの詳細を確認することができます。\n その他の変更 編集済マークの表示位置変更 投稿後にメッセージ内容を編集した際に表示される編集済マークの表示位置が変更され、メッセージの末尾に表示されるようになりました。\nインラインLaTeX 今までもコードブロックとしてLaTeX書式を記述できましたが、本バージョンから文中にもLaTeX書式を記述できるようになりました。$マーク内にLaTeX形式の数式を記述することで、数式として表示できます。\n詳しくは以下のドキュメントを参照ください。\nFormatting Text - Math Formulas\nブラウザサポートバージョンの変更 サポートされているブラウザ/OSの最低バージョンが更新されています。\n Chrome updated from 61+ to 89+. Firefox updated from 60+ to 78+. MacOS updated from 10.9+ to 10.14+.  その他のトピック Mattermost Cloud 10ユーザー以内なら無料として利用できたMattermost Cloudですが、2022/2/15に無償プランが廃止され、有償のStarter plan(月額$12.41 or 年額 $149)への移行が必要となるようです。 2022/2/15までにクレジットカードの情報を入力するか、何もアクションがない場合は利用継続できなくなってしまうようです。\nおわりに 次のv6.2のリリースは 2021/12/16(Thu)を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-6.0/","title":"Mattermost 6.0の新機能","section":"post","date":"2021.10.19","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2021/10/13 に Mattermost のメジャーバージョンアップである v6.0.0 がリリースされました。\nまた、10/18にMedium Level Security Fixを含む v6.0.1 がリリースされています。今後、v6へアップグレードする場合は v6.0.1 を使用してください。\n本バージョンから開発におけるコラボレーションを加速させるPlaybookとBoardsという機能が追加されています。今回のメジャーバージョンアップは、MattermostがSlack alternativeなチャットツールから、開発におけるコラボレーションを扱うプラットフォームへと舵を切る分岐点となるリリースとなりそうです。\nMattermost 6.0リリースの背景については、以下のMattermost CEOによるエントリで語られています。\nIntroducing Mattermost 6.0: A New Approach to Developer Collaboration\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v6.0 is Now Available - Mattermost Mattermost Changelog   アップグレード時の注意事項 今回のアップグレードではデータベーススキーマの変更が行われており、この処理に(特にMySQLを使用している場合は)時間がかかることが予想されます。データベースのサイズによっては、長い時間Postテーブルへのロックがかかり、メッセージの投稿や受信に影響が出る場合があります。Mattermost上の投稿が1000万件以上ある環境や、クラスタ構成を採用している環境では特に注意が必要です。アップグレード作業時の注意点については以下のエントリにまとめられています。\n How to Upgrade to Mattermost v6.0  アップグレード時に実施されるスキーマ変更の内容と、1000万/7000万件の投稿を持つデータベースに対するアップグレード処理にかかる時間については、以下のドキュメントに参考情報がまとめられています。\n https://gist.github.com/streamer45/59b3582118913d4fc5e8ff81ea78b055 https://gist.github.com/streamer45/868c451164f6e8069d8b398685a31b6e  クラスタ構成を組んでいる場合、v6の一部データ形式が以前のバージョンと非互換となっている箇所があるため、クラスタ内でv5系とv6系を混在させることができなくなっています。クラスタ構成を組んでいる場合、またはMattermost Kubernetes operatorを利用している場合は ChangelogのImportant Upgrade Notes を参照してください。\nv6.0へのアップグレードのリスクを感じる場合、Mattermost 5.37がESR(Extended Support Release)として2022/4月までサポートされる予定のため、このリリースを使い続けるのが良さそうです。\n 各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Professional Enterprise  見出しの前に何もない場合、Starter(無償版)でも利用可能な機能です。\nプラットフォームの再設計と新たなサブスクリプションプラン v6.0からはチャットベースのメッセージングだけでなく、コラボレーションプラットフォームとしての価値を高めていく方にシフトするようです。 それに伴い、以前にIncident Collaborationと呼ばれていたプラグインがPlaybookとして、Focalboardと呼ばれていた機能がBoardsとして、それぞれMattermostプラットフォームに統合され、デフォルトで利用できるようになりました。\nMattermostプラットフォームの全体像については、以下の動画で紹介されています。 Mattermost Platform Overview - Mattermost\nまた、v6.0リリースに合わせてサブスクリプションプランの内容が変更されています。\nhttps://mattermost.com/pricing/\n今までは、無償のOSSセルフホスティング版はTeam Edition、有償プランはE10/E20と呼ばれていましたが、今後は無償版をStarter、E10に当たるプランをProfessional、E20に当たるプランをEnterpriseと呼ぶよう変更されたようです。 また、以前はMattermost Cloud独自のサブスクリプションプランがありましたが、本バージョンからセルフホスティング版のプランと統合され、それぞれのプランでセルフホスト/Cloudを選択できるようになったようです。(StarterプランでCloudを選択した場合のみ(?)、年額$149の追加費用が必要)\nまた、メジャーバージョンアップにあたり、いくつかの機能が下位のプランでも利用可能になっています。詳細については以下のChangelogを参照してください。\nhttps://docs.mattermost.com/install/self-managed-changelog.html#packaging-changes\nグローバルナビゲージョンの追加 Mattermostに関する各種メニューを表示するためのグローバルナビゲーションヘッダーが新たに追加されました。グローバルナビゲーションメニューから、本バージョンで追加されたPlaybookやBoardsへ簡単に移動することができます。 アカウント設定などのメニューは、今までは画面左上からアクセスできましたが、本バージョンからは画面右上に移動しているので注意が必要です。\n(画像は公式ブログより)\nベータ版機能のGA化 以前のバージョンでベータ版として含まれていた以下の機能が正式版(GA, Generally Available)となりました。(機能名末尾の文字列は、当該機能が利用できるプランを示しています)\n アーカイブされたチャンネルの閲覧 コンプライアンスエクスポート (Enterprise) カスタム利用規約 (Enterprise) ゲストアカウント (Enterprise, Professional) mmctl コマンド 追加のシステム管理者ロール (Enterprise) プラグイン機能 タイムゾーン設定  メッセージリンクのプレビュー表示 Mattermost内の投稿のリンクを同じMattermost内に投稿した際、投稿のプレビューが自動で表示されるようになりました。プレビューは、リンク先の投稿があるチャンネルに参加している場合のみ表示されます。\nSharing Messages\nプレビューが表示されるのは、メッセージのコンテキストメニューから リンクをコピーする を選択した時にコピーされるURL形式 (${SITE_URL}/${TEAM_NAME}/pl/${MESSAGE_ID}) の場合のようです。投稿日付の部分をクリックした時も投稿へのリンクを取得することができますが、この時のURL形式は${SITE_URL}/${TEAM_NAME}/channels/${CHANNEL_NAME}/${MESSAGE_ID} となり、この形式のリンクではプレビューが表示されませんでした。\nPlaybook 以前、Incident Collaboration Pluginとして開発されていた機能が Playbook としてMattermostプラットフォームに統合されました。\n https://docs.mattermost.com/guides/playbooks.html https://github.com/mattermost/mattermost-plugin-playbooks  Playbook は、繰り返し行われるプロセスのワークフロー/チェックリストをPlaybookとして事前に定義し、作業が発生するたびにPlaybookを元にチャンネルを作成することで、作業ごとの記録を一つのチャンネルにまとめておくことのできる機能です。\nリリース直後(約1年前)ぐらいに触った際の記録を以下に書いています。\nMattermost5.30の新機能 - (E20) Mattermostでインシデント管理\nその後、数多くの機能追加が行われているため、現在の機能について詳しくは公式ドキュメントを参照しください。また、Mattermost v6.0公開にあたり、更新通知の再設計やリマインダー設定機能の追加などの機能追加が行われています。\nBoards 以前、Focalboardとして開発されていた機能が Boards としてMattermostプラットフォームに統合されました。\n https://docs.mattermost.com/guides/boards.html https://www.focalboard.com/  Focalboardは、Mattermost社が開発しているTrello・Notion・Asana Alternativeを謳うKanbanツールです。Focalboardについては、以下の記事で紹介しています。\nNotionのようなUIのTrelloっぽいKanbanツールのOSSの Focalboard を触ってみた\n本バージョンから(?) Boardsを開くとチャンネルごとにBoardがどの程度利用されているか俯瞰できるようになっています。\nその他、v6リリースに伴うアップデートとして、カラムにsum/rangeなどの解析関数を設定可能になったり、日付プロパティに期間を指定する機能が追加されています。\nまた、shared boardsの機能により、誰でもBoardにアクセスできるリンクを生成できるようになりました。Boardはチャンネルごとに作成されるため、参加していないチャンネルに紐づくBoardや、そもそもMattermostにアカウントの無いユーザーはBoardにアクセスできませんが、そのようなユーザーでもBoardを閲覧できるようになる機能です。\nDesktop App v5.0 デスクトップアプリもv5系へメジャーバージョンアップされました。\nDesktop Application Changelog\nMattermost Desktop App v5.0はMattermost v5系もサポートしていますが、Minimum Server Versionが5.37となっているので注意が必要です。\nグローバルナビゲーションのサポート デスクトップアプリもグローバルナビゲーションに対応しており、Channels/Playbooks/Boardsを素早く切り替えることができます。\n今までのバージョンとは違い、タブではChannels/Playbooks/Boardsを表示し、サーバーの切り替えはドロップダウンメニューから行うようになっているようです。\nCtrl + Shift + [数字キー] のショートカットででサーバーを切り替えることができるようになっているので、多くのサーバーを登録していた場合は、このショートカットを覚えておいた方が良さそうです。サーバーの登録順はドラッグ＆ドロップで変更できます。（自分はMattermostだけでなくSlackなどもサーバー登録していたので、このショートカットは必須になりそうです）\nスペルチェック言語の多言語指定 スペルチェック機能の対象言語として複数の言語を指定できるようになりました。しかし、残念ながら日本語の設定は無いようです。\nMobile App v1.47.0 モバイルアプリの方は、マイナーバージョンアップのようです。\nMattermost Mobile Apps Changelog\nこちらもMattermost v5.37以上のみのバージョンをサポートするよう変更されているので、アップデートには注意が必要です。また、自己署名証明書を使用しているサーバーへ接続する場合は、デバイスへ証明書をインストールしなくてはならなくなったようです。\n Server Versions Supported: Server v5.37.0+ is required. Self-Signed SSL Certificates are not supported unless the user installs the CA certificate on their device.\n 破壊的変更 mattermostコマンド mattermostコマンドの多くのサブコマンドが mmctlへ移行されました。\nCommand Line Tools\nただし、import/exportサブコマンドと、それに関連するサブコマンドはmattermostコマンドに残っています。これは、ユーザー権限に基づいてMattermostインスタンスを操作するmmctlコマンドでは、インスタンス移行のためのコマンドを実行するには権限が足りないためだと思われます。\nインスタンスの移行等を検討する場合でない限りは、mmctlコマンドを使用することをお勧めします。\nSlackデータをMattermost上からアップロードする機能の廃止 以前のバージョンでは、SlackからエクスポートしたデータをMattermost画面上からアップロードすることができましたが、この機能が廃止されました。\nMigration Guide\n代わりにmmetlツールとmmctl importを使用して、コマンドラインからインポートする方法が推奨されるようになったようです。\nMigration Guide\nその他の破壊的変更 Mattermost v6リリースに伴い、以下のバージョンのサポートが廃止されました。\n MySQL 5.7.12以前のバージョン Elasticsearch 7以前のバージョン Windows 7  また、Mattermostの設定項目の内、いくつかの項目が削除されています。詳しくは以下のドキュメントを参照ください。\nhttps://docs.mattermost.com/install/self-managed-changelog.html#deprecations\n その他の変更 デフォルトテーマの変更 デフォルトのテーマが Denim に変更され、シックな印象となりました。\n公式サイトもDenimをテーマカラーとして刷新されています。\nhttps://mattermost.com/\nその他のテーマも、名称といくつかのカラーが変更されているため、Mattermostサーバーをv6.0にアップグレードした後は、少し見た目が変わっている場合があります。 既存のテーマカラーに戻したい場合は、カラーテーマが公式ドキュメントで公開されているので、カスタムテーマから設定してください。\nhttps://docs.mattermost.com/messaging/customizing-theme-colors.html#custom-theme-examples\nその他のトピック Hacktoberfest Join Mattermost for Hacktoberfest 2021\n今年もMattermostはHacktoberfestのPartnerとして参加しています。\nhttps://hacktoberfest.digitalocean.com/\nHacktoberfestの景品とは別に、Mattermost独自のSwagを用意しています。 10月中に一つでもコントリビュートを行なった場合は、限定ステッカーがもらえるようです。このステッカーは、日本のJapanese Maple Treeをモチーフにしているそうです。\nさらに、各カテゴリ(Focalboard, Mattermost App, Writing Program, Translation, QA Testing)でトップコントリビューターに選ばれた場合、オリジナルのメカニカルキーボードがプレゼントされるようです。\nおわりに 次のv6.1のリリースは 2021/11/16(Tue)を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter で Mattermost に関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/life/life-with-baby/","title":"第二子出産に伴う育児休職を取得したので雑感","section":"post","date":"2021.10.08","body":"この記事は、子育てに関する有用な知見や耳寄りな情報があるわけでもなく、単に記録として書いているだけのものです。\nはじめに 8月下旬に第二子となる女の子が誕生しました。\n我が家では上の子が2歳になったばかりで、かつ二人目の妊娠が発覚した時期がちょっと微妙で一人目は保育園にも入れていなかったので、出産直後の奥さん（出産直後でなくとも）に二人の世話は不可能だろうということで育児休職を取得することにしました。\n育児休業給付金を受給することを考えると子が1歳になるまで育児休職とすることもできますが、あまり長く休みすぎると生活に仕事を組み込んだリズムが構築できなくなりそうな気がしたので、まずは約一ヶ月としました。（出産が予定日より10日ほど早まったため、結局1ヶ月半ぐらいになりましたが）\n一ヶ月とした理由については、会社の積立休暇の範囲で有給にすることが可能なのと、短期で復帰した場合、子が一歳になるまでの期間であれば再度育児休職を取得するということもできるからです。\nhttps://fujitsu.recruiting.jp.fujitsu.com/whats/diversity/diversity-woman/\n 原則として休職期間は子どもの満1歳の誕生日の前日までを最長としてあらかじめ申し出た期間。育児休職期間が1ヶ月以内の場合、積立休暇の残日数の範囲で有給にすることが可能。保育所の事情などで1歳以降最初の4月20日、または1歳6ヶ月の前日までの長いほうの期間を最長にすることができます。\n また、ちょうど先日プレスリリースも出ていましたが、会社の「出産育児に関する休暇の取得日数拡大」により２カ月目ぐらいまでは休みやすかったというのもあります。\nhttps://pr.fujitsu.com/jp/news/2021/10/6.html\n 男性育児参加100％の推進\n社会課題の一つとなっている、子育て世代に対する仕事との両立支援施策として男性の育児参加を積極的に促進するべく、出産育児に関する休暇の取得日数を拡大し、積立休暇（多目的休暇）も併せて利用することで、配偶者の出産前後に最大2ヶ月の100％有給休暇を付与します。（2021年7月から実施）\n 生活のこと 育休期間中の毎日のスケジュールは大体こんな感じ。\n 07:00 起床・朝食準備・ゴミ出し 08:00 洗濯 (and 掃除) 10:00 長男外遊び (and 買い出し) 11:30 昼食準備・昼食 12:30 長男昼寝（奥さんに託す） 13:30 片付け・新生児の世話・etc 15:00 長男おやつ 16:00 長男外遊び 17:00 長男風呂 (夕食後の場合も有) 18:00 夕食準備 19:00 夕食 20:00 寝る準備 21:00 長男(奥さんに託す) 22:00 片付け・新生児にミルクあげて寝かす 24:00 就寝  基本は家事と第一子のお世話で、奥さんには第二子の世話に専念してもらう体制。あとは状況に応じて双方のサポートをするという感じ。奥さんがタフなので色々動いてくれたり、奥さんの実家が近いので協力してもらえたりもしたので、家事取りこぼしてもリカバーできる感じだったのは良かったと思います。\nコロナ禍での出産・育児 出産はコロナ禍ということもあり立会禁止で、出産後の面会も配偶者だけは許可されているようですが本当に子どもを見るだけという感じだったので、特に面会に行くことなく退院日までは自宅で上の子と2人で過ごしてました。上の子はお母さんいなくなってぐずるかと思ってたらそういうこともなく平和でした。\n出産5日後に新生児を自宅へ迎えましたが、退院直後ぐらいは寝てる時間が多く、奥さんも夜の授乳はありつつも、まだそんなに辛そうではない感じでした。\nただ、2週間から3週間後ぐらいから新生児も体力がき始めて起きる時間も長くなり、また、夜になると軽くグズる時間が長く続くようになり、奥さんも不眠っぽい感じになって段々と辛みが増してきました。また、第一子の方も昼間寝ている奥さんのところへ遊びに行こうとしてしまうので、日中は外に連れ出したり、家にいても常に気を張っていなくてはいけない状態なのはなかなか辛い所でした。第一子の時は、子供が寝れば大人はフリーな時間でしたが、そうはいかないのが2人目の大変なところだな、と。\n今は育休が明けていますが、奥さんのお母さんにヘルプに来てもらって生活を立て直しているという感じです。子にも依りますが１カ月だとちょっと短かったなという感じがします。仕事は完全テレワークなので上手いこと家庭のサポートにも回りつつ、回していければなと思ってます。\nあって良かったもの 山本ゆりのおいしいレシピBOOK 限定カラーのiwaki耐熱容器つき! (現在、Amazonでは無駄に価格が高騰してる模様。大きめの本屋なら平積みされてるっぽい。)\n【新刊のお知らせ】\n8/31にiwaki(イワキ)さんの耐熱容器「パック\u0026amp;レンジ」付のレシピ本を発売します‼️\nsyunkonシリーズではなくiwakiさんの本。なんなら正しくは「本付きの耐熱容器」です。\nメインが耐熱容器で、薄い本がペラっと付いてるイメージ(プロ野球チップスではなくセボンスターのスタンス) pic.twitter.com/u5k263cgyc\n\u0026mdash; 山本ゆり（syunkon レンジは600W) (@syunkon0507) July 15, 2021  これは本当によかった。\n元々料理はどちらかというと好き（上手い訳では決して無い）な方でしたが、毎日作るとなるとレパートリーもなく、下ごしらえから洗い物まで含めると結構な時間を持っていかれてしまうのが悩みでした。\nただ、この本の料理はとにかく手軽にできるだけでなく、レシピサイトの変に手のかかるものより味・量的にも満足度が高く、残り物も付属の耐熱容器に入れたまま冷蔵庫に入れて翌日のおかずにもできるので、ほぼ毎日何かしら作ってました。レシピは30種類ぐらいしか載って無いけど、もうこれのローテーションで良いよぐらいの気持ち。\nこれだけでもありがたいのに、ほぼすべてのレシピが家にある材料+αぐらいで作れるので、+αをいくつかまとめて買っておいて、その日にどれ作るか考えるみたいなことができた。＋αと言っても、「挽き肉」とか「茄子」とかそういうレベルなので他のレシピに切り替えるのも容易。あと、材料を耐熱容器に入れてチンするだけなので、洗い物も全然出ない。メリットしかなかった。\nこのレシピの料理をメインにして、あとご飯と汁物と常備菜みたいなのを作れば、（前日作った常備菜と合わせて）5品できるので何となくの安心感と達成感が生まれる。毎日料理作るとなると手軽にパパッと作れるのがいいですね。\nAftershokz OpenMove 🎉OpenMoveが2021年のレッドドットデザイン賞を受賞しました！🏆\n「OpenMoveは骨伝導技術により耳を塞がないため、外出時の安全性が大幅に向上。フィット感も非常に高いです」\n詳しくは賞のリリースをご覧ください👉\n*https://t.co/S3zxNtgeaO pic.twitter.com/YYWgHSOxxZ\n\u0026mdash; Shokz Japan (@ShokzJP) July 14, 2021  赤ちゃん寝かせる時に1時間とか抱いてなきゃ寝ないときもあり、その間は両手も塞がってるので動画とか見るぐらいしかやることないけど、動画の音で起きちゃう気もするのでモヤモヤしてmした。イヤホンするにしてもインナーイヤー型のしか持ってなくて、子供がいる中で物音に気づけないのも問題な気がして、オープンイヤー型のイヤホンでどうにかならないかなと購入しました。\nAftershokzはいくつかばりえーそんがあるけど、用途として音質などは気にせず、通話用に使う気もなかったので安いOpenMoveで。装着感的にメガネと干渉しないか心配だったけど、そこまで気にはならなかったです。Amazonとかヨドバシのレビューにある通り、骨伝導と言いつつ音漏れバリバリで、耳元にスピーカーを持ってきただけって感じなので電車の中とかでは使えなさそうですが、それでもテレビよりは音量小さくできる（と思う）し、今のところ音で起きるとかの弊害もなさそうなので買っといてよかったなと。付けたまま会話するのはちょっと難しいけど、子供の鳴き声とかは全然聴こえるので目的は達成できたかな。\n子供がグズり出して長い戦いになりそうだなと思ったら装着して、片手でリモコンなりスマホ操作して時間を潰すものを探す感じ。今のところ悪くない。\n授乳クッション 自分が授乳をするという訳ではないですが。\nこれも新生児抱っこし続けるとき用のアイテム。 立ったままの方が新生児も落ち着いてる気がするけど、ちょっと疲れてきて座ったりすると今度は腕の位置が下がってしまって肩が凝るという問題がありました。そんな時は授乳クッションを膝の上に挟んで高さを上げてあげるとちょっと楽だった。\nおわりに 育児については一人目を経験してるので強くてニューゲーム状態かと思ってたら全然状況が違いました。コントロール不能な年齢の上の子がいると、せっかく寝れてる奥さんのいる寝室に突撃して行ったりと予期せぬ行動を起こすので常に気を張ってなきゃいけない感じ。育児力不足か。 あと、１日の中で空き時間がないことはないけど、決まった時間に手が空く訳ではなく、また、子供が寝て空き時間になったと思ってもすぐ起きたりもするので、深い思考とかは難しいなと。休職前は積読消化ぐらいはできるかなとか思ってたけど全然できなかった。時間自体はあったはずですが、どこまで読み進められるか分からないと手が伸びなくなっちゃってたな。上の子が保育園行ってたり、もう少し歳が離れてたりすれば状況違ってたのかな、とか。まぁ、結局はケースバイケースなのですが。\n育休取得話でよく見るのは「子供の成長を間近で見れた」とかだけど、これは去年からずっとテレワークで毎日顔見れてるので特に感じることはなく。ただ、毎日テレワークだと家庭 ≒ 仕事場となるので家庭の状況は良い方がよく、そういう意味で出産後などのドラスティックに生活が変わるときにしっかりと時間を確保できる育休の重要性は上がる気がしました。\nとりあえず育休期間空けて仕事始めてますが、奥さんがなかなか寝付けなくなってきたというので早速奥さんの実家を頼っている感じに。保育園入れてない2歳がいる状態で育休1ヶ月はちょっと短かったかなというのが正直なところ。\n Mattermostの人に子供が生まれるみたいな話をしてたら、ベビーグッズを送ってくれました。Thanks!\nWhat a sweet swag! Baby wears to my baby girl 👶 and cool stickers 🍁 have just arrived from @Mattermost. Thanks! pic.twitter.com/SFMxtPJI1B\n\u0026mdash; yemoto (@kaakaa_hoe_prog) October 7, 2021  "},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.39/","title":"Mattermost 5.39の新機能","section":"post","date":"2021.09.17","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2021/09/16 に Mattermost v5.39.0 がリリースされました。 v5.39はいつものような Feature Release ではなく、Quality Releaseとなっているため、新機能の追加は無く、改善系の変更のみのリリースとなっています。\n先月の記事で、今月はメジャーバージョンアップであるv6.0のリリース日であると書きましたが、v6.0のリリースは来月(10/13)だったようです。（リリース日については、いつもMattermost公式チャットのRelease: Self-Managedチャンネルのチャンネルヘッダーを見て書いているのですが、見間違えたか変更されたかしていたようです）\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v5.39 is now available - Upgrade today Mattermost Changelog   返信スレッドの折り畳み機能の改善 2021年7月にリリースされたMattermost v5.37にてベータ版として導入され、先月のリリースからモバイルアプリでも利用可能になった返信スレッドの折り畳み機能のバグ修正がいくつか行われています。\nこの機能を利用している場合は、バグ修正を適用するために v5.39 へアップデートすることをお勧めします。\n現在ベータ版の本機能は、2021/4Q (2021年10月~12月) にベータ版ではなくGeneric Availableとしてリリースされる予定だそうです。 Looking ahead to general availability of Collapsed Reply Threads\nMattermost v6.0が10月にリリース 冒頭でも触れましたが、来月10/13(Wed)にMattermostのメジャーバージョンアップである v6.0 がリリースされます。 v6.0では今までベータ版としてリリースされていた以下のような機能が、Generic Availableとしてリリースされます。\n Archived Channels: アーカイブされたチャンネルの内容を検索する機能 Compliance Exports(E20): コンプラインアンス向けデータエクスポート機能 Custom Term of Service(E20): 独自の利用規約設定機能 Guest Accounts(E20): ゲストアカウント機能 mmctl: 管理者向けMattermost管理CLIツール Additional System Admin Roles(E20): システム管理ロールの追加 Plugin: Mattermostプラグイン機能  その他 v6.0 で変更が予定されている点は、以下の公式ブログエントリにまとめられています。\nLooking forward to the next big Mattermost product milestone: Mattermost v6.0\n Mattermost v6.0へのアップグレード時にDBのマイグレーションが実行されますが、このマイグレーション処理に時間がかかることが予想されます。マイグレーションにかかる時間に関する分析が Mattermost v6.0 DB Schema Migrations Analysisで公開されているため、アップデート作業時の参考にご利用ください。\n デスクトップアプリ、モバイルアプリに対しては後方互換性が保たれているため、現在のバージョンのままでもMattermost v6.0を利用できるようです。ただし、どちらもMattermost v6.0と同時期にリリースされる最新バージョンへのアップデートが推奨されています。\n Extended Support Release (ESR) となっている Mattermost v5.37 は、引き続き2021年4月までサポートされます。\nプラグインの更新 Mattermost本体の機能追加がないためか、最近 (?) 更新のあったプラグインが紹介されています。どちらのプラグインもプラグインマーケットプレースから簡単にインストールすることができます。\nWebex v1.2 Cisco Webexと連携するプラグインについて、Linuxクライアントを使用している場合のMeeting URLの改善をはじめ、いくつかの改善が加えられた新たなバージョンがリリースされています。\nhttps://github.com/mattermost/mattermost-plugin-webex/releases/tag/v1.2.0\nGif Commander v2.1.0 アニメーションGifをMattermostに投稿するプラグインについてもいくつか改善が行われています。\nhttps://github.com/moussetc/mattermost-plugin-giphy/releases/tag/v2.1.0\nMattermostコミュニティイベント Mattermostのメンバーが今後数週間のうちにいくつかのイベントに登壇する予定のようです。\nMattermostのイベント登壇を含むPublic向けのイベント情報は以下のカレンダーから確認できます。 Mattermost Public Events Calendar\nまた、今年もHacktoberfestへの参加を予定しているそうです。\n おわりに 3年半ぶりのメジャーバージョンアップとなる、次のv6.0のリリースは 2021/10/13(Web) を予定しています。\nMattermost公式コミュニティチャットの方では、一足先にMattermost v6.0を触ってみることができます。まだ開発途中のため、実際にリリースされるものとは異なりますが、雰囲気を感じることができると思います。 個人的には、メインメニューが画面上部にヘッダとしてまとめられてスッキリとしている印象があったのと、デフォルトのテーマが Denim になっておりシックになった感じがしました。\nまた、画面左上のメニューからは、最近開発に力を入れているPlaybookやFocalboardへ移動するメニューが追加されており、v6では、チャットをベースとしたDevOpsプラットフォームとしての発展に力を入れていくのかなと思いました。\n Mattermost 日本語(@mattermost_jp)さん | Twitter で Mattermost に関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.38/","title":"Mattermost 5.38の新機能","section":"post","date":"2021.08.21","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2021/08/16 に Mattermost v5.38.0 がリリースされました。 その後、2021/08/18 に 同梱されているMattermost Playbook (旧: Mattermost Incident Collaboration) v1.16.0 がインストールできない問題に対応した v5.38.1 がリリースされています。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v5.38 is now available - Upgrade today  Mattermost 5.38.1 released - Upgrade today if your deployment is affected   Mattermost Changelog   アップグレード時の注意事項  返信スレッドの折りたたみ機能(ベータ版)導入によりスレッドやチャンネルのメンション数や未読数が不正確となってしまう問題が発生していました。この改善がv5.38にて行われていますが、大規模なデータベースの場合、v5.38アップグレード時のDBマイグレーションに数分かかることがあります。 Mattermost v5.38.0と同時にリリースされたFocalboard v0.8.2 は、新たに追加されたデータベースコネクションシステムの影響でMattermost v5.37以降のバージョンでないと動作しなくなっています   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Cloud: Mattermost Cloud E20/E10: Enterprise E20/E10  見出しの前に何もない場合、Team Edition(OSS 版)でも利用可能な機能です。\nはじめてログインした際の案内画面の改善 Matttermostにアカウントを作成し、初めてログインした時に表示される「はじめに」に当たる画面の内容が改善されました。この画面から、プロフィールの入力、デスクトップ通知の設定、ユーザーの招待を行うことができます。 Mattermost Incident Collaboration が Mattermost Playbooks へリブランディング 最近、活発に開発が行われていたMattermost Incident Collaboration Pluginですが、インシデント管理に限らず、あらゆる種類のチーム活動に訴求できるということからMattermost Playbooksにリブランディングされました。\nhttps://github.com/mattermost/mattermost-plugin-playbooks\nまた、以下のような機能追加も行われています。\n 右サイドバーの表示内容改善 Mattermostプロジェクトで培われたベストプラクティスのテンプレート化 Playbookチャンネル参加時、左サイドバーが自動で整理されるトリガーの追加 Playbookが終了した際に自動でチャンネルエクスポート(E20/Cloud)が実行されるトリガーの追加  機能追加の詳細については 公式ブログ を参照ください。\nFocalboardの更新 Mattermost v5.38のリリースに合わせて Focalboardもv0.8.2に更新されています。\n 作成者プロパティの追加 DBコネクションのパフォーマンス改善  (E20) 詳細なデータ保持ポリシー設定 本バージョンからデータ保持ポリシーを特定のチーム及びチャンネルごとに設定できるようになりました。これによりコンプライアンスの維持とストレージの最適化を両立することができます。\n(公式ブログでの本機能の紹介と、動作確認をしているMattermost Cloudの画面が一致していないように見えるため、詳細については割愛します)\nその他のトピック Mattermost Dockathon ドキュメント改善をテーマにしたハッカソンである Mattermost Dockathon が 2021/07/26~08/06に行われました。 約2週間の間に 26 コントリビューターから 178 のコントリビュートがあったようです。\n結果については以下のエントリにまとめられています。\nHighlights from the first-ever Mattermost Docathon\nおわりに 3年半ぶりのメジャーバージョンアップとなる、次のv6.0のリリースは 2021/09/15(Web)を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter で Mattermost に関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.37/","title":"Mattermost 5.37の新機能","section":"post","date":"2021.07.17","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2021/07/16 に Mattermost v5.37.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。 変更内容の詳細については公式のリリースを確認してください。\n Mattermost v5.37 is now available - Upgrade today Mattermost Changelog   アップグレード時の注意事項  本バージョンより、返信機能の折りたたみ機能が利用可能になりましたが、まだベータ版のためバグが残っている可能性があり、既知の問題等を把握した上で利用することが推奨されています 本バージョンより、Emoji v13.0に基づく絵文字が利用できるようになりますが、新しく追加される絵文字と同名のカスタム絵文字がすでに登録されていた場合、アップデートにより既存のカスタム絵文字の内容が上書きされます Incident Collaborationプラグインを全エディションで利用可能とするために、最新のIncident Collaborationプラグインの最低動作バージョンが v5.37 に引き上げられています。Incident Collaborationプラグインをアップデートする際は注意してください。 長期サポートバージョンであるMattermost v5.31は2021/10/15にサポート終了となります。v5.31を利用しているユーザーは、v5.37以降のバージョンへアップグレードする必要があります。   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Cloud: Mattermost Cloud E20/E10: Enterprise E20/E10  見出しの前に何もない場合、Team Edition(OSS 版)でも利用可能な機能です。\nCollapsed Reply Threads (ベータ版) Get early access to the Mattermost Collapsed Reply Threads beta\nMattermostのFeature Requestフォーラムでも最も人気のあった返信スレッドの折りたたみ機能(Collapsed Reply Threads)がベータ版として利用できるようになりました。\n本機能を有効にすることで、投稿への返信がチャンネル内に表示されなくなり、チャンネル内の会話をトピックごとに把握しやすくなります。\n実際の動作の様子は、公式ドキュメントで確認できます。\n(上記画像は公式ブログから)\n 本機能を有効にするには、まず、システムコンソール \u0026gt; 実験的機能 \u0026gt; 機能 \u0026gt; 返信スレッドの折りたたみ が 有効(デフォルトOff) となっている必要があります。\n上記設定を有効にした上で、アカウント設定 \u0026gt; 表示 \u0026gt; 返信スレッドの折りたたみ (ベータ版) を On に設定することでアカウントごとに機能が有効になります。\n本機能はまだベータ版の段階のため、既知の問題を含め、問題が発生する可能性を考慮して利用した方が良さそうです。\nhttps://docs.mattermost.com/messaging/organizing-conversations.html#known-issues\nIncident Collaborationの改善 今月もMattermost Incident Collaboration Pluginの改善があります。\n全エディションで利用可能に 今までMattermost CloudとEnterprise E20プランでしか利用できなかったIncident CollaborationがOSS版のTeam Edition(Enterprise E0)を含む全エディションで利用可能になりました。 Team EditionではPlaybookが1つしか作成できないなど制限はありますが、機能の使用感の確認などはできるようになります。\nhttps://mattermost.com/pricing-self-managed/\nIncident Collaborationプラグインは、メインメニュー \u0026gt; マーケットプレース から簡単にインストールできます。\nインストールが完了すると、上記画像中のInstallボタンがConfigureボタンに変わるので、Configureボタンをクリックして設定画面へ移動し、プラグインを有効にする を 有効 にすることでプラグインが利用可能になります。\nプラグインを有効にすると メインメニュー \u0026gt; Incident CollaborationからIncident Collaborationプラグインを利用することができるようになります。\nプレイブックキーワードの監視 プレイブックに関するキーワードを設定することができるようになり、Mattermost上で設定されたキーワードを含むメッセージが投稿された際にプレイブックの開始を促すメッセージを自動で表示できるようになりました。\nキーワードを設定するには、メインメニュー \u0026gt; Incident Collaboration \u0026gt; Playbooksタブからキーワードを設定したいプレイブックを選び、Edit \u0026gt; Actions \u0026gt; Prompt to run the playbook when a user posts a message \u0026gt; Containing any of these keywordsにキーワードを入力します。\n設定したキーワードを含む投稿を行うと、Playbook Botがプレイブックの開始を促すメッセージを投稿します。\nYes, run playbookを選択すると、作成するプレイブックの内容を指定するモーダルが開きます。\n内容を入力し、Start runボタンを押すとインシデント作成のきっかけとなった投稿とともにプレイブックを開始できます。\n(E10/E20/Cloud) Retrospectiveレポート 作成したプレイブックに関するRetrospective(振り返り)レポートを作成できるようになりました。RetrospectiveレポートをPublishすると、チャンネルに内容が投稿されます。\nPlaybookの設定から、Retrospectiveレポートのテンプレート等を設定できます。\n(E20/Clout) Playbookダッシュボード プレイブックの過去の実行結果を把握するためのダッシュボードを表示できるようになりました。インシデントの発生頻度やインシデント対応の参加者数、対応にかかった時間などを俯瞰することで、インシデント対応方針の改善やリソース割り当ての見直し等に役立てることができます。\n絵文字のスキントーン選択 Emoji 13.0に基づく絵文字を利用できるようになり、絵文字ピッカーから絵文字を選択する際にスキントーン（肌の色）を選択できるようになりました。\n(画像は公式ブログから)\nFocalboard Plugin Focalboardにも改善があります。\n現在、Mattermost Pluginとして利用できるFocalboardの最新バージョンは v0.7.0 で、このバージョンのインストール方法については以下の公式ドキュメントを参照してください。　https://www.focalboard.com/download/mattermost/latest-plugin/\nFocalboard自体は先日v0.8.0がリリースされています。\nプロパティ値によるテーブルのグルーピング 作成したタスクをテーブル表示する際に、タスクに設定したプロパティの値ごとにグループ化して表示することができるようになりました。 以下の例では、Priorityプロパティをグルーピングの対象とした場合に、Priority無し、High、Medium、Low でグループ化されたタスクを表示しています。\nプロパティタイプの追加 タスクに設定するプロパティのタイプに、マルチセレクト、人物、チェックボックスが追加されました。\nその他の変更 チャンネル切替ダイアログの改善 Mattermost上で Ctrl(Cmd) + K を入力することで開く チャンネル切替 ダイアログに、最近開いたチャンネルが表示されるようになりました。\nカスタムステータスの有効期限設定 カスタムステータスを設定する際に、ステータスの有効期限を設定できるようになりました。\nplatform バイナリの廃止 以前、Mattermostサーバーは mattermost/platform というリポジトリで管理されており、当時の名残でMattermostサーバー管理用のCLIツールとしてplatformバイナリというものが残っていました。今回のリリースでこのplatformバイナリや--platformオプションが利用できなくなりました。 現在では、リポジトリはmattermost/mattermost-serverに移行され、Mattermostサーバー管理用のCLIツールとしてmattermostバイナリが利用可能になっているため、今後はmattermostバイナリを使用することが推奨されています。\nその他のトピック Mattermost Dockathon Mattermostの公式ドキュメントサイトである https://docs.mattermost.com の構成などを改善する作業を開始しているようで、それに伴い、今月下旬から Mattermost Docathon というドキュメント改善のためのイベントを開催するようです。\nJoin Us for our First Mattermost \u0026lsquo;Docathon\u0026rsquo; and win swag and more!\nこのイベント期間中のコントリビュートが多かった上位5名にMattermostロゴ入りAirPod Proがプレゼントされるようです。1件のみのコントリビュートでもグッズがもらえるようです。\nMattermost v6.0 先月の記事で少し触れたMattermot v6.0について、公式ブログで紹介がありました。\nLooking ahead to Mattermost v6.0, which ships Fall 2021\nベータ版からGA(Generally Available)に昇格予定の機能や、廃止予定の機能などが紹介されています。\nおわりに 次のv5.38のリリースは 2021/08/16(Mon)を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter で Mattermost に関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.36/","title":"Mattermost 5.36の新機能","section":"post","date":"2021.06.18","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2021/06/16 に Mattermost v5.36.0 がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。　変更内容の詳細については公式のリリースを確認してください。\n Mattermost v5.36 is now available - Upgrade today to try the new features Mattermost Changelog  MatterCon 2021 MatterCon 2021 - Learn about the latest and greatest from Mattermost!\nMattermostのVirtualコミュニティイベントであるMatterConが来週6/22-24の間で開催されます。 誰でも無料で参加できるイベントのようで、上記のサイトから参加登録できます。\nMatterConは、今までもコミュニティメンバ限定で年に一回オフラインで開催されていたイベントでしたが、コロナ禍ということもありVirtual開催でパブリックなイベントになったようです。(過去のMatterCons)\nMattermostはフルリモートの会社のため、社員やコミュニティメンバーが同期的なコミュニケーションを行う場というのがMatterConの主な目的ですが、その他にもフルリモートの会社ならではの知見の紹介や、新機能のデモ、ロードマップ、Mattermost内のOpen Source Fridayプロジェクトについての紹介などもあるようです。\n 各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Cloud: Mattermost Cloud E20/E10: Enterprise E20/E10  見出しの前に何もない場合、Team Edition(OSS 版)でも利用可能な機能です。\nFocalboard Plugin 以前から開発が進められているNotion, Trello, AsanaクローンのKanbanツールであるFocalboardが、Mattermost Pluginとして利用できるようになりました。\nFocalboard Mattermost Pluginについては、以下の記事に使ってみた感想を書いています。 FocalboardのMattermostプラグインについて\n上記の記事では、プラグインをインストールする方法として.tar.gzファイルをアップロードする方法を紹介していましたが、Marketplaceから数クリックでインストールする手順が公式のYouTubeチャンネルで1分程度の動画として紹介されています。\nhttps://youtu.be/V_pLVc4K-1g\nMattermostへのプロキシとしてnginxやApacheを使用している場合は、追加の設定が必要になります。\nHow to configure the NGINX or Apache web proxy to enable the Focalboard plugin · Discussion #566 · mattermost/focalboard\n(E20/Cloud) Incident Collaborationの改善 今月もMattermost Incident Collaboration Pluginの改善があります。\nチーム全体に対するPlaybookアクセス権設定 作成されたPlaybookに対するアクセス権を設定する際に、メンバー単位のアクセス権設定だけでなく、チーム全体に対するアクセス権を設定できるようになりました。\nPlaybook作成権限の管理 Playbookを作成できる権限をメンバー単位で設定できるようになりました。\nWelcomeメッセージ PlaybookにWelcomeメッセージを設定できるようになりました。 Welcomeメッセージは、Playbookを元に作成されたチャンネルに始めた参加した時に表示されるメッセージです。インシデント対応時に意識しておいて欲しいことや、見ておいてほしいサイトへのリンクなどを指定しておくことで、無駄なコミュニケーションを削減することが期待できます。\n破壊的変更 高可用モードの通信がゴシッププロトコルに 商用版を利用しているユーザーで、可用性を高めるためのクラスタリング機能を利用している場合に、クラスタ間の通信がゴシッププロトコルで行われるようになりました。今まではゴシッププロトコルの使用はオプションでしたが、そのオプションが廃止され、ゴシッププロトコルのみが用いられるようになります。クラスタ構成では、全てのノードが同じプロトコルを利用して通信している必要があるため、現在ゴシッププロトコルを利用していない場合は、ゴシッププロトコルを使用したアップグレードを行うか、一度全てのノードをシャットダウンしてからアプグレードする必要があるそうです。\nhttps://docs.mattermost.com/administration/changelog.html#important-upgrade-notes\nその他のトピック Collapsed Reply Thread 要望の多い返信の折り畳み機能(Collapsed Reply Thread)が、来月リリースされるバージョンからベータ版の機能として利用可能になる予定です。また、クラウド版では今月のリリースから利用可能になる予定です。\nMattermostコミュニティ用のチャットではすでに利用可能になっています。アカウント設定 \u0026gt; 表示 \u0026gt; 返信スレッドの折りたたみ から有効にすることができます。\nhttps://community.mattermost.com\nMattermost 6.0? MattermostのJIRAを見ると、v6.0(Sep 15)というバージョンが見えます。9月にメジャーバージョンアップが行われるのかもしれません。\nhttps://mattermost.atlassian.net/browse/MM-36539?jql=project%20%3D%20%22MM%22%20AND%20fixVersion%20%3D%20%22v6.0%20(Sep%2015)%22\nおわりに 次のv5.37のリリースは 2021/07/16(Fri)を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter で Mattermost に関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.35/","title":"Mattermost 5.35の新機能","section":"post","date":"2021.05.18","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに (最近Qiitaでの体験があまり良くないので、来月の記事からZennに移行しようと思っています。既存の記事も移行し、Qiitaの記事内容をZennの記事へのリンクに更新する予定です。https://zenn.dev/kaakaa)\n2021/05/14 に Mattermost v5.35.0 がリリースされました。\nv5.35へのマイグレーション時に、MySQL を使用している場合にデータベースに対するreadTimeout時間が短すぎることが原因で、MySQL へのコネクションが正常に貼れなくなるという問題が確認されています。アップグレードを行う場合は、まもなくリリース予定のv5.35.1の利用をおすすめします。\nhttps://docs.mattermost.com/administration/changelog.html#release-v5-35-feature-release\n v5.35.1, release day TBD Fixing an issue where 5.35.0 migration is failing on MySQL installations with an “invalid connection” error due to an issue with the readTimeout parameter in SqlSettings.DataSource (default is 30 seconds). To mitigate this, readTimeout can be either removed or increased to a high enough value to allow the migration to happen. MM-35767\n 本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。　変更内容の詳細については公式のリリースを確認してください。\n Mattermost v5.35 is now available - Upgrade today to try the new features Mattermost Changelog   アップグレード時の注意事項 v5.35へのアップグレードに関連するいくつかの注意事項があります。\n Mattermost v5.35では、今後リリース予定の共有チャンネル機能や、返信スレッドの折り畳み機能に必要なデータベースのマイグレーションが行われており、アップグレードに時間がかかることがあります。データベースのサイズにもよりますが、数分から、MySQL 5.x系を利用している場合は数時間かかることもあります。パフォーマンスへの影響については5.35 Migrationも確認ください。 v5.35から導入されたファイル検索機能は、デフォルトではすでにアップロード済みのファイルに対してはファイル名のみの検索しか動作しません。アップロード済みのファイルの内容で検索を行いたい場合、mattermost extract-documents-contentコマンドを実行する必要があります。また、検索にElasticsearchもしくはBleveを利用している場合は、mattermost extract-documents-contentが完了した後で、検索インデックスの再構築を行う必要があります。ファイル検索機能については、Search for files and document contents in Mattermostでも説明されています。 Bulk Importにより追加されたユーザーに設定されるパスワードは、比較的脆弱なパスワードとなっていたため、Bulk Import後に一度もパスワードを変更していないユーザーがいた場合、そのユーザーのパスワードをリセットすることをおすすめします。 v5.38にて、config.jsonファイルを監視し、変更を自動でリロードする config watcherの機能が廃止されます。   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Cloud: Mattermost Cloud E20/E10: Enterprise E20/E10  見出しの前に何もない場合、Team Edition(OSS 版)でも利用可能な機能です。\nファイル/ドキュメント内容検索 Mattermostにアップロードされたファイルの内容を検索できるようになりました。\n検索対象となるファイルの形式は、.pdf, .pptx, .odt, .html と plain textドキュメントです。 Cloud版では、さらに.docx も検索対象になります。 Team Edition(OSS版)でも、下記の依存ライブラリをインストールすることで、.docx, .rtf, .pagesファイルを検索対象とすることもできるようです。(Linuxのみ？)\n$ sudo apt-get install poppler-utils wv unrtf tidy $ go get github.com/JalfResi/justext sajari/docconv: Converts PDF, DOC, DOCX, XML, HTML, RTF, etc to plain text\nまた、Team Edition(OSS版)においてMattermsotサーバーの設定ファイルconfig.jsonのFileSettings.ArchiveRecursionをtrueに設定することで、ZIPファイルの内容も検索できるようになるようです。\n記事冒頭のImport Upgrade Notesにもあるように、ファイル内容についてのインデックスが作成されるまではファイル名での検索しか動作しません。v5.35にアップデートする前にアップロード済みのファイルの内容に対するインデックスを作成するには mattermost extract-documents-contentコマンドを実行する必要があります。\nファイル検索について、詳細は以下の公式ブログを参照ください。 Search for files and document contents in Mattermost\n(E20/Cloud) Incident Collaborationの改善 Ad hoc tasks インシデント対応時のタスクは、事前にPlaybookに定義されているものしか使えませんでしたが、新しいバージョンではインシデント対応中にアドホックでタスクの追加、編集、削除ができるようになりました。\n(※画像は公式ブログから)\nStakeholder overview Incident Collaborationサイドバーの下部に表示されている Overview ボタンを押すことで、インシデント対応に当たっているユーザー等を確認できるようになっているようです。\n詳細なアクセス管理 インシデントに対するアクセス権限をMattermostチーム単位?に設定できるようになりました。Mattermostインスタンスにユーザー用のチームと管理者用のチームに分けていた場合、管理者側のチームの人だけがインシデントにアクセスできるようにするなどの対応を取れるようになったのだと思います。 また、Incident Collaborationの設定の中に Experimental Featuresに関する設定も見えるようです。これを有効にすると、インシデント対応に関するメトリクス一覧の画面を表示できるようになったりするらしいです。\nインシデント開始に係る処理の自動化 先月のリリース時点と比較すると、Playbookの設定にAnnounce in another channelとSend a webhookという項目が追加されているようです。 この設定により、(おそらく)Incidentに関するイベントを他のチャンネルに通知したり、Webhook経由で別のサーバーへ通知して他サービスと連携するなどができるようになっているようです。\n(E20/Cloud) システムコンソールページに対する詳細な権限設定 システムコンソールの各設定ページに対する編集/閲覧権限に関する設定項目が細分化されました。 新たに Experimental(実験的な機能), About(エディションとライセンス),Environment(環境),Site Configuration(サイト設定),Authemtication(認可),Integration(統合機能),Compliance(コンプライアンス)のセクションが追加され、それぞれのサブセクションごとの権限設定が可能になっています。\n(E20/Cloud) 共有チャンネル Mattermostインスタンス間でチャンネルを共有できる機能が実験的な機能として追加されました。Enterprise E20ライセンスが必要です。また、共有チャンネル機能はデフォルトでは無効化されています。\nシステムコンソール \u0026gt; 実験的機能 \u0026gt; 機能 から有効にでき、スラッシュコマンド /share で共有チャンネルを管理するようです。\n共有するインスタンスを持っていないので実際の動作は確かめられませんでしたが、共有チャンネルは以下のような見た目になるそうです。(※画像は公式ブログから)\nApps Framework (Developer Preview) Mattermostの統合機能の新たな形式として、Mattermost Appsが利用できるようになります。(現時点ではDeveloper Previewのため、プロダクション環境では利用できません。)\nMattermost Appsはどんな言語でも記述することができ、モバイルアプリやデスクトップアプリでも動作します。\n公式リリースブログでは、AWS LambdaによるAppsのサーバーレスホスティング、ServiceNowとの連携、Zendeskとの連携、について紹介されています。\n mattermost/mattermost-app-servicenow: Service Now app for Mattermost mattermost/mattermost-app-zendesk: Zendesk App for Mattermost  Mattermost Appsについて詳しくは、公式ドキュメントApps (Developers Preview)を参照してください。\nまた、日本語で書かれた記事もいくつかあります。\n Mattermost Apps Framework をJava (JAX-RS)で試してみた – maruTA(Bis5)\u0026rsquo;s Weblog – Side T:echnology Mattermost Apps Frameworkを触ってみた  その他の機能 (E20) Entrepriseトライアルの改善 Enterprise E20トライアルの開始時、終了３日前、終了日にシステム管理者に対してバナー警告が表示されるようになりました。\n履歴からカスタムステータスを設定 最近設定したカスタムステータスを選択することができるようになりました。\nリンクプレビュー表示を無効化するドメインの設定 URLを含むメッセージが投稿された場合、MattermostはリンクのOGPプレビューを表示しようとしますが、プレビューの表示をドメインによってに抑制する設定ができるようになりました。特定のサイトのプレビューを表示したくない場合などに利用できます。\nサイドバーにプロフィール画像が表示されるように チャンネルサイドバーのダイレクトメッセージのセクションに、DM相手のプロフィール画像が表示されるようになりました。\nその他のトピック Mattermost-Focalboard 連携 Mattermost が開発している a self-hosted alternative to Trello, Notion, and Asana なFocalboardとMattermostとの連携機能の開発が進められています。\nFocalboard-Mattermost Integration · Discussion #118 · mattermost/focalboard\nまだEarly Preview段階であり、かつ誰でも利用できるというわけではなく、MattermostコミュニティサーバーのFocalboardチャンネルからしか利用できませんが、以下のGitHub Discussionsで意見を募集しています。\nMattermost-Focalboard - Early Preview · Discussion #349 · mattermost/focalboard\nFocalboardに関するYouTube動画も公開されています。\nFocalboard - YouTube Focalboard - YouTube\nまた、Focalboard の開発者がMattermost社のPodcastである What Mattersに出演しています。\nWhat Matters, Episode 18: Meet the Focalboard Team\nE2E Cypress Test Automation Hackfest 5月中、MattermostではCypressでE2Eのテストを記述するHackfestを開催しているようです。Top 3になったコントリビューターはSpecial Awardを受け取れるようです。\nE2E Test Automation Hackfest 2021 🚀 · Issue #17555 · mattermost/mattermost-server Join the 2021 Mattermost E2E Cypress Test Automation Hackfest!\nおわりに 次のv5.36のリリースは 2021/06/16(Wed)を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter で Mattermost に関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/apps-sample/","title":"Mattermost Apps Frameworkを触ってみた","section":"post","date":"2021.05.08","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに Mattermost の新たな統合機能である Apps Framework が Developer Preview になりました。\nhttps://twitter.com/Mattermost/status/1390333864820813831\n既存の統合機能やプラグイン機能との違いを確かめるべく、公式開発者向けドキュメントにある Quick start guide (Go) を動かしてみました。\n注: Mattermost Apps Framework は、記事執筆時点では Developer Preview 段階のためプロダクションリリースには含まれていません。Apps Framework を利用するには、Mattermost 開発環境を用意する必要があります。\nMattermost Apps の開発・インストール Mattermost Apps は、Mattermost インスタンスとは別の Mattermot Apps 用のアプリケーションサーバーとして起動します。\nここでは、そのアプリケーションサーバーの開発方法と、Mattermost Apps のインストール・利用方法について書いています。以下にある内容は、公式ドキュメントのQuick start guide (Go)の内容に沿ったものです。\n0. 環境設定 Mattermost Apps Framework は、まだ Developer Preview 段階ということで、Mattermost のプロダクションリリースには含まれていません。\nMattermost Apps Framework を動かすには、Mattermost 開発環境を構築した上で、以下の環境変数を設定してから Mattermost 開発環境を起動する必要があります。\n$ export MM_FEATUREFLAGS_AppsEnabled=true また、Mattermost Apps Framework は Bot アカウント機能と OAuth 2.0 Service Provider 機能を利用しています。そのため、起動した Mattermost インスタンスのシステムコンソール \u0026gt; 統合機能 \u0026gt; 統合機能管理から、これらの機能を有効化しておく必要があります。\n1. Mattermpst Apps Plugin のインストール Mattermost Apps は mattermost-plugin-apps で管理されるため、まず mattermost-plugin-apps をインストールする必要があります。\n以下のコマンドで mattermost-plugin-apps を Mattermost インスタンスにインストールします。\n$ git clone https://github.com/mattermost/mattermost-plugin-apps.git $ cd mattermost-plugin-apps $ export MM_SERVICESETTINGS_SITEURL=http://localhost:8065 $ export MM_ADMIN_USERNAME=kaaka $ export MM_ADMIN_PASSWORD=PASSWORD $ make deploy 環境変数に指定しているのは、Mattermost インスタンス の SiteURL と、管理者権限を持つユーザーのユーザー名/パスワードです。\n2. サンプル Mattermost Apps の作成 ここまでで Mattermost Apps を動作させる準備ができました。ここからは Mattermost Apps 本体を開発していきます。\nMattermost Apps サーバーと Mattermost インスタンスは、(恐らく)以下のように連携して動作しています。(以下のシーケンス図は、公式ドキュメントの図に少し手を加えたものです)\n一番右にある Apps Server が、これから開発する Mattermost Apps 本体です。\nシーケンス図の一番下の post bot message の部分に関しては、 Mattermost Apps から Mattermost にメッセージを投稿するロジックを書く必要がありますが、それ以外の部分は Mattermost からのリクエストに対して JSON ファイルを返しているだけです。\n 今回は Go 言語で Mattermost Apps を開発するため、go mod init で Go プロジェクトを作成し、github.com/mattermost/mattermost-plugin-apps/appsを依存関係に加えます。（github.com/mattermost/mattermost-plugin-apps/apps には、Mattermost Apps を開発する際に利用可能なユーティリティライブラリが含まれています） ）\n$ go mod init $ go get github.com/mattermost/mattermost-plugin-apps/apps@master 以下のドキュメントにもあるように、github.com/mattermost/mattermost-plugin-apps/apps@masterを通じて、Mattermost REST API を実行したり、Apps 用の Key-Value Store を利用できるようになります。\nApps APIs\nmanifest.json Go プロジェクトのルートディレクトリに以下の内容でmanifest.jsonというファイルを作成します。\n{ \u0026#34;app_id\u0026#34;: \u0026#34;hello-world\u0026#34;, \u0026#34;display_name\u0026#34;: \u0026#34;Hello, world!\u0026#34;, \u0026#34;app_type\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;root_url\u0026#34;: \u0026#34;http://localhost:8080\u0026#34;, \u0026#34;requested_permissions\u0026#34;: [\u0026#34;act_as_bot\u0026#34;], \u0026#34;requested_locations\u0026#34;: [\u0026#34;/channel_header\u0026#34;, \u0026#34;/command\u0026#34;] } このmanifest.jsonは、Mattermost Apps の概要や種別、Apps が要求する Permission、Apps が表示される箇所などを表すファイルです。\n app_id、display_nameはそれぞれ Apps の ID と表示名を表します。app_idは Apps をインストールする際に使用されます。 app_typeは Apps の種別を表します。http、aws_lambda、builtinの中から 1 つを選ぶようですが、http以外を指定した場合の動作についてはまだわかっていません。 app_typeにhttpを指定した場合には、root_urlに Apps が起動しているサーバーの URL を記述します。 requested_permissionsには、Apps の動作に必要な権限を指定します。 記述できる内容についてはPermissionsを参照。 requested_locationsには、Apps が干渉する Mattermost UI 上の箇所を指定します。次のbindings.jsonの記述内容と関連します。 記述できる内容についてはLocationsを参照。  Manifest ファイルに記述できる内容については以下の公式ドキュメントで紹介されています。\nManifest\nbindings.json 次に、Mattermost 上のどこに・どんな機能を配置するかについて記述したbindings.jsonというファイルを以下の内容で作成します。\n{ \u0026#34;type\u0026#34;: \u0026#34;ok\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;location\u0026#34;: \u0026#34;/channel_header\u0026#34;, \u0026#34;bindings\u0026#34;: [ { \u0026#34;location\u0026#34;: \u0026#34;send-button\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;http://localhost:8080/static/icon.png\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;send hello message\u0026#34;, \u0026#34;call\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;/send-modal\u0026#34; } } ] }, { \u0026#34;location\u0026#34;: \u0026#34;/command\u0026#34;, \u0026#34;bindings\u0026#34;: [ { \u0026#34;icon\u0026#34;: \u0026#34;http://localhost:8080/static/icon.png\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;helloworld\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Hello World app\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;[send]\u0026#34;, \u0026#34;bindings\u0026#34;: [ { \u0026#34;location\u0026#34;: \u0026#34;send\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;send\u0026#34;, \u0026#34;call\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;/send\u0026#34; } } ] } ] } ] } bindings.jsonには、manifest.jsonのrequested_locationsに記述したlocationsに対する詳細な定義を記述していきます。 例えば、\u0026quot;location\u0026quot;: \u0026quot;/channel_header\u0026quot;は、Mattermost のチャンネルヘッダー部分に表示されるボタンを表しています。bindings.jsonには、このチャンネルヘッダーに表示されるボタンの概要(アイコン、ラベル)や、ボタンが押された時の動作を定義します。\n... { \u0026#34;location\u0026#34;: \u0026#34;/channel_header\u0026#34;, \u0026#34;bindings\u0026#34;: [ { \u0026#34;location\u0026#34;: \u0026#34;send-button\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;http://localhost:8080/static/icon.png\u0026#34;, \u0026#34;label\u0026#34;:\u0026#34;send hello message\u0026#34;, \u0026#34;call\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;/send-modal\u0026#34; } } ] }, ... 上記の定義により、http://localhost:8080/static/icon.pngをアイコンとし、send hello messageをラベルとするボタンがチャンネルヘッダーに表示されます。\nこのボタンを押した時の動作はbindings.callに書かれます。\n\u0026#34;call\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;/send-modal\u0026#34; } この定義により、manifest.jsonのroot_urlに書かれた URL をベースとした/send-modalのパス、すなわちhttp://localhost:8080/send-modal/submitに Mattermost からのリクエストが送信されます。(末尾の/submitが何故つくのか分かっていませんが、サンプルコード上では/submitが末尾に付いた URL へリクエストが送信されているようです)\nこのbindings.callには他にも様々なパラメータを指定でき、指定したパラメータの内容によって Mattermost から様々な情報を Apps に対して送信するよう要求できます。\nCall\nModal Forms 前述の http://localhost:8080/send-modal/submit へ送信されたリクエストに対しては、今回のサンプル Apps ではモーダルを表示するための JSON ファイルを返却しています。(この Go プログラムの全容は以降のセクションで紹介しています)\n... //go:embed send_form.json var formData []byte func main() { ... http.HandleFunc(\u0026#34;/send-modal/submit\u0026#34;, writeJSON(formData)) ... この時、返却する JSON の内容は下記の通りです。\n{ \u0026#34;type\u0026#34;: \u0026#34;form\u0026#34;, \u0026#34;form\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Hello, world!\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;http://localhost:8080/static/icon.png\u0026#34;, \u0026#34;fields\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;message\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;message\u0026#34; } ], \u0026#34;call\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;/send\u0026#34; } } } Mattermost が、上記の JSON を Apps サーバーから受け取ると、以下のようなモーダルウィンドウを表示します。\n返却した JSON のformフィールドの内容が、表示されるモーダルの内容となります。\n今回はfields配列に\u0026quot;type\u0026quot;: \u0026quot;text\u0026quot;のオブジェクト 1 つしかないため、1 つのテキストボックスのみを持つモーダルが表示されました。fields内には他にもtext、static_select、dynamic_select、bool、user、channelなど、様々なタイプの要素を指定できます。\n詳細については以下のドキュメントに記載があります。\nInteractivity\nモーダルの送信ボタンを押した場合、send_form.jsonのform.callに書かれたパス (http://localhost:8080/send/submit) へ Mattermost からリクエストが送信されます。（この場合も末尾に/submitが自動で付与されるようです）\n送信されたリクエストは、再び Apps サーバーで扱われます。Apps サーバーの内容は、後述のセクションで紹介します。\nアイコンファイル 上記で作成してきた JSON ファイル内で参照されているアイコンファイルを取得しておきます。 公式ドキュメントでは、以下のコマンドでダウンロードするよう紹介されていますが、大きすぎるファイルでなければ恐らくどんな画像ファイルでも大丈夫です。\n$ wget https://github.com/mattermost/mattermost-plugin-apps/raw/master/examples/go/helloworld/icon.png Go サーバーアプリケーション 今回開発している Apps サーバーの本体であるサーバーアプリケーションは、下記の Go コードになります。Go 1.16 から導入されたGo embedを使って、今まで作成してきた JSON ファイルを直接読み込んでいます。\npackage main import ( _ \u0026#34;embed\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/mattermost/mattermost-plugin-apps/apps\u0026#34; \u0026#34;github.com/mattermost/mattermost-plugin-apps/apps/mmclient\u0026#34; ) //go:embed icon.png var iconData []byte //go:embed manifest.json var manifestData []byte //go:embed bindings.json var bindingsData []byte //go:embed send_form.json var formData []byte func main() { http.HandleFunc(\u0026#34;/manifest.json\u0026#34;, writeJSON(manifestData)) http.HandleFunc(\u0026#34;/bindings\u0026#34;, writeJSON(bindingsData)) http.HandleFunc(\u0026#34;/send/form\u0026#34;, writeJSON(formData)) http.HandleFunc(\u0026#34;/send/submit\u0026#34;, send) http.HandleFunc(\u0026#34;/send-modal/submit\u0026#34;, writeJSON(formData)) http.HandleFunc(\u0026#34;/static/icon.png\u0026#34;, writeData(\u0026#34;image/png\u0026#34;, iconData)) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } func send(w http.ResponseWriter, r *http.Request) { c := apps.CallRequest{} json.NewDecoder(r.Body).Decode(\u0026amp;c) message := \u0026#34;Hello, world!\u0026#34; v, ok := c.Values[\u0026#34;message\u0026#34;] if ok \u0026amp;\u0026amp; v != nil { message += fmt.Sprintf(\u0026#34; ... and %s!\u0026#34;, v) } mmclient.AsBot(c.Context).DM(c.Context.ActingUserID, message) json.NewEncoder(w).Encode(apps.CallResponse{}) } func writeData(ct string, data []byte) func(w http.ResponseWriter, r *http.Request) { return func(w http.ResponseWriter, req *http.Request) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, ct) w.Write(data) } } func writeJSON(data []byte) func(w http.ResponseWriter, r *http.Request) { return writeData(\u0026#34;application/json\u0026#34;, data) } 前述のモーダルウィンドウの送信ボタンをした際に Mattermost から送信される http://localhost:8080/send/submit へのリクエストは、上記のsend関数で処理されます。send関数では、モーダルの入力内容を元にメッセージを作成し、github.com/mattermost/mattermost-plugin-apps/apps/mmclientの関数を使って、Bot として Mattermost にダイレクトメッセージを投稿しています。\n... func send(w http.ResponseWriter, r *http.Request) { c := apps.CallRequest{} json.NewDecoder(r.Body).Decode(\u0026amp;c) message := \u0026#34;Hello, world!\u0026#34; v, ok := c.Values[\u0026#34;message\u0026#34;] if ok \u0026amp;\u0026amp; v != nil { message += fmt.Sprintf(\u0026#34; ... and %s!\u0026#34;, v) } mmclient.AsBot(c.Context).DM(c.Context.ActingUserID, message) json.NewEncoder(w).Encode(apps.CallResponse{}) } ... 以上で Mattermost Apps サーバーの開発は完了です。早速 Mattermost Apps をインストールしてみましょう。\n3. サンプル Mattermost Apps のインストール go run .コマンドで Mattermost Apps サーバーを立ち上げます。\n次に、mattermost-plugin-appsをインストールした Mattermost をブラウザで開き、/appsコマンドを使って Mattermost Apps をインストールします。\n/apps debug-add-manifest --url http://localhost:8080/manifest.json /apps install hello-world /apps debug-add-manifestで、Mattermost Apps サーバーからmanifest.jsonを取得し、その内容を検証します。問題がなければ/apps installコマンドで Apps ID を指定してインストールを実行します。\nインストール実行時に、インストールしようとしている Apps が要求する Permission と Locations が表示され、App Secret の入力を促されます。App Secret の内容はなんでも良いらしいです。\nApp Secret を入力して、Approve and Installボタンをクリックすると、Apps のインストールが完了します。Apps をインストールした後、ページをリロードすると、チャンネルヘッダー部分にボタンが表示されているはずです。\nまた、Apps インストール後に/apps listコマンドを実行すると、インストールされている Mattermost Apps の一覧を確認できます。\n4. サンプル Mattermost Apps の実行 チャンネルヘッダー部分のボタンをクリックすると、モーダルウィンドウが開きます。\nメッセージを入力し、送信ボタンを押すと、Bot からダイレクトメッセージが届きます。\nさいごに Developer Preview 版として公開された Mattermost Apps Framework を動かしてみました。\nMattermost Apps Framework は、既存の統合機能(WebHook、Slash Command)とプラグインの中間のような位置付けのものという印象を受けましたが、使用できるパラメータの数も多く、どのような場面で使うべきかはもう少し触ってみないとなんとも言えません。 ただ、AWS Lambda と連携するタイプの Apps が現段階で利用できることから、FaaS 基盤と連携可能という点がポイントになるような気がしています。実際、Apps のインストールや Mattermost UI に関わる部分は Apps サーバーから JSON を返すだけで実現できるため、フルスタックなサーバーアプリケーションを立てておくことなく、必要な部分の処理だけをコードとして書けば良いという形式になっています。この点より、プラグインより軽量であり、かつプラグインのように Mattermost と密接に連携した機能を開発できる基盤なのかなという印象があります。また、FaaS 的な基盤としてn8nなんかと上手く連携する方法が見つかルト、いろいろ幅が広がりそうです。\n以下は妄想です。\n今回実装したようなサンプル Apps ぐらいなら、プラグインとして実装できますが、プラグインは Mattermost インスタンスと密接に連携して動作するため、Mattermost インスタンスの動作に意図しない影響を与えてしまう可能性もあります。また、マルチクラスタ構成を組んでいる場合、プラグインによる機能追加を全てのインスタンスで同一の状態に揃えることが難しいということも、背景としてあったのでは無いかと考えられます（妄想ですが）。Mattermost プラグイン自体は Mattermost を自組織向けにカスタマイズするための強力な仕組みですが、やはり統合機能は別のサーバーで管理した方が利用しやすいという考えもあったのではないかと思われます。ただ、既存の統合機能では HTTP リクエストのやり取りぐらいしかできないため、もう少し踏み込んだ統合機能の実装として Mattermost Apps Framework が生まれたのではないかと想像しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/plugin_reacji/","title":"Mattermost Reacji Channeler plugin","section":"post","date":"2021.05.02","body":"Mattermost Reacji Channeler Plugin Mattermost 上で動くReacji Channeler的なプラグインを作った。 まだ動くところまで作ったというレベルで、まだまだ破壊的な変更も必要そうな気がするけど、作ってる最中にいろいろ悩んでた部分を書き残しておきたいということで書いておく。\n使い方等については README で。どういう風に動作するかについても、README にスクリーンキャストを載せてる。\nkaakaa/mattermost-plugin-reacji\nSlack の Reacji Channeler が数年前に日本で話題になってた時から面白そうな機能だなと思っていて、Mattermost v5.30 からReactionHasBeenAddedというリアクションが付与された時に処理を差し込める Hook が追加されたので、勢いで作ってみた。（その少し前から WebSocket API 使った形である程度の形はできてたけど）\nOverview 悩んだ箇所は下記で、それぞれのセクションで細かなところを書き残している。\n (1) SlashCommand - Plugin KeyValue Store の Key 長制約について (2) (PluginHook) ReactionHasBeenAdded - 絵文字エイリアスについて (3) Store shared info - Plugin KeyValue Store の Key 長制約について  (1) SlashCommand Reacji Channeler Plugin を有効にすると、/reacjiというスラッシュコマンドが使えるようになる。 プラグインごとのスラッシュコマンドの実装は、API.reagisterCommandでコマンドを登録して、コマンド実行時の処理をHooks.ExecuteCommandに記述する。\n/reacji add というサブコマンドが実行されると、新たな Reacji をReacjiListというインスタンスに格納する。その他にも参照や削除系のサブコマンドがあるが、使い方の話はREADMEで。\nスラッシュコマンドのサブコマンドの実装についてははswitch文で地道に書く必要がある。\n以下のコードのようにスラッシュコマンドにサブコマンド的な実装を追加することもできるけど、これはスラッシュコマンド実行時の候補提示用の機能のため、実行時の処理についてはサポートしてくれない。\nfunc createAutoCompleteData() *model.AutocompleteData { suggestions := model.NewAutocompleteData(\u0026#34;reacji\u0026#34;, \u0026#34;[command]\u0026#34;, \u0026#34;Available commands: add, list, remove, remove-all, help\u0026#34;) suggestions.AddCommand(model.NewAutocompleteData(\u0026#34;add\u0026#34;, \u0026#34;:EMOJI: ~CHANNEL\u0026#34;, \u0026#34;Register new reacji. If you attach EMOJI to the post in any channels except for DM/GM, the post will share to CHANNEL.\u0026#34;)) suggestions.AddCommand(model.NewAutocompleteData(\u0026#34;add-from-here\u0026#34;, \u0026#34;:EMOJI: ~CHANNEL\u0026#34;, \u0026#34;Register new reacji. If you attach EMOJI to the post in the channel where this command is executed, the post will share to CHANNEL.\u0026#34;)) suggestions.AddCommand(model.NewAutocompleteData(\u0026#34;list\u0026#34;, \u0026#34;[--all]\u0026#34;, \u0026#34;List reacjis in this channel. With `--all` list all registered reacjis in this server.\u0026#34;)) suggestions.AddCommand(model.NewAutocompleteData(\u0026#34;remove\u0026#34;, \u0026#34;[DeleteKey...]\u0026#34;, \u0026#34;[CREATOR or SYSTEM_ADMIN only] Remove reacji by DeleteKey. You can see `DeleteKey` by `/reacji list`\u0026#34;)) suggestions.AddCommand(model.NewAutocompleteData(\u0026#34;remove-all\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;[SYSTEM_ADMIN only] Remove all reacjis in this server.\u0026#34;)) suggestions.AddCommand(model.NewAutocompleteData(\u0026#34;refresh-caches\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;[SYSTEM_ADMIN only] Delete all caches. Reacji plugin caches data about shared post for a certain period in order to prevent duplicate sharing.\u0026#34;)) suggestions.AddCommand(model.NewAutocompleteData(\u0026#34;help\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Show help\u0026#34;)) return suggestions } https://github.com/kaakaa/mattermost-plugin-reacji/blob/3fe45b50563c912b783a0f120c18faec82e47ae9/server/plugin/command.go#L418\n登録された Reacji をどう管理するかで、いろいろ悩んだ。\nReacji はReacjiListというまとまった形で管理するより、登録された Reacji 1 つが KeyValue Store の 1 データの対応するように作るのが無難だとは思うけど、Plugin 用に用意されている KeyValue Store はKey の最大長が 50 文字までという制限があるため、Mattermost のチャンネル ID が 26 文字、カスタム絵文字名の最大長が 64 文字という 2 つの情報を上手く 1 つの Key で表現することができなかった。 具体的なシーンとしては、あるチャンネルの投稿に絵文字が付与された場合、この情報を元に KeyValue Store からデータを取り出したいが、その場合、Key が最短でも${CHANNEL_ID}${EMOJI_NAME} (26+64=90文字)となってしまい、Key の最大長を超えてしまう。チャンネル ID と絵文字名からハッシュ値を作って管理することも考えたが、チャンネル ID と絵文字が一緒でも、共有先のチャンネルが違う Reacji というのも存在することがあり、そのようなデータの CRUD をどう管理すれば良いかいい案がなかったため、それならプラグイン起動時に全 Reacji を保持するReacjiListのようなインスタンスを作って管理した方が I/O 少なくなって良いかと思った。その分、メモリを圧迫するので、プラグインの設定として登録できる Reacji の最大数を指定できるようにしてある。\nそんな作りなのでマルチクラスタ構成で複数インスタンスで Mattermost が動いていると意図しない動きをしそうな気がする。マルチクラスタの時に KeyValue Store はどういう同期方法になっているんだろうか\u0026hellip;.\n(2) (Plugin Hook) ReactionHasBeenAdded 冒頭でも触れたけど、Mattermost v5.30 から追加された投稿にリアクションが付けられた時に実行される処理を登録することができる Hook。 ReactionHasBeenAdded\nこの Hook 自体はわかりやすいものだったけど、Mattermost の絵文字エイリアスの扱いにちょっとハマったので少し書く Mattermost デフォルトの絵文字リアクションには、1 つの絵文字に対して本来の絵文字名とは別の名前(絵文字エイリアス) を持っている絵文字がいくつか存在する。例えば、Mattermost の絵文字リアクション選択ダイアログで、:uk:と入力すると、:gb: :uk: という 2 つの名前で同じ絵文字を参照できることがわかる。ここで、この絵文字を選択すると :gb: でリアクションされたことになる。\nReacji の観点からすると、/reacji add :uk: ~CHANNEL という感じで:uk:を使った Reacji を登録し、絵文字選択ダイアログから:uk:を入力しても、実際に指定されるのは:gb:のため、:uk:で登録された Reacji は反応しないことになる。\n絵文字エイリアスのデータはmattermost-webapp に登録されており、このデータから絵文字エイリアスについてまとめたのが下記のドキュメント。aliases列にある絵文字はあまり使わない方が良さそう。\nhttps://github.com/kaakaa/mattermost-plugin-reacji/blob/master/notes-alias.md\n絵文字エイリアスは Mattermost デフォルト絵文字のみの機能で、カスタム絵文字では使えないのでカスタム絵文字の方は気にする必要はない。\n さらに話をややこしくすると、Mattermost 上で+:uk:というような投稿を行うと、直前の投稿に:uk:の絵文字リアクションを行うという機能があり、これで絵文字リアクションをすると、絵文字エイリアスは機能せず、:uk:という絵文字でリアクションできる。\nまた、Mattermost の画面上からは存在が確認できないが、実際は使用できる絵文字というのもあり、Mattermost 上で本当に使用できる全絵文字のデータは mattermost-server 内に書かれている。例えば、:older_man_medium_light_skin_tone:などは Mattermost 上で補完などが効かないため存在を確認することはできないが、実際に投稿してみると存在することがわかる。\nとりあえず絵文字エイリアスには気をつけてというぐらいしかない。\n(3) Store shared info 1 度 Reacji によって共有されたメッセージを再度同じチャンネルに共有しないようにするという話。絵文字が付けられるたびに同じ投稿が何度もチャンネルに共有されるのは邪魔ですからね。\nClicking on the emoticon re-triggers the shared from · Issue #1 · kaakaa/mattermost-plugin-reacji\nすでに Reacji によって投稿が行われたかどうかは、Reacji の情報、投稿の PostID などから判断する必要があるため、これも(1)と同様に Plugin KeyValue Store の Key 長の制約が絡んでくる。ただ、今回はある条件を満たすデータが存在するかどうか(投稿が共有済みかどうか)を判断するだけでよく、Key に一意性もあるため、共有済みかどうかチェックするのに必要な情報からハッシュ値を求めて管理することにした。\nReacji によって共有されたという情報は KeyValue Store 上に格納されるが、デフォルトでは 30 日間経ったら格納された情報が消去されるようにしてある。30 日も前の投稿にリアクションすることはほぼ無いだろうという想定。この 30 日という期間については、プラグインの設定で変更することができる。また、システム管理者限定で共有されたという情報を削除するreacji refresh-cachesというサブコマンドも入れてある。\nとりあえず機能としては達成できたように見えるけど、もっと細かな要求があるような気がしている。\nまとめ リアクション扱う Hook が実装されたので勢いで作ってみたけど、やっぱり作り始めるといろんな制約によって窮屈になってくる。KeyValue Store の Key 長さの制約とか絵文字エイリアスとかは、実際に不具合に当たらないと真剣に見ようとは思わないところなので、やっぱりいろいろ動かしてみないと見えてこない部分はたくさんありますね。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.34/","title":"Mattermost 5.34の新機能","section":"post","date":"2021.04.17","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2021/04/15 に Mattermost v5.34.0 がリリースされました。\nその後、MySQL を使用している場合に発生する可能性のある問題に対応したパッチバージョンをリリースしており、MySQL を利用している場合は注意が必要そうです。以下の Changelog を確認し、最新のリリースを利用するようにしてください。\nhttps://docs.mattermost.com/administration/changelog.html#release-v5-34-feature-release\nv5.34.0 へのアップグレード時に実行される DB マイグレーションがタイムアウトすることがあり、この問題については v5.34.1 で解消されています。v5.34.1 にアップグレードする場合、大規模なインスタンスだとマイグレーションに時間がかかる可能性があります。\n v5.34.1, released 2021-04-15 Fixed an issue where upgrading to v5.34.0 runs a migration that could cause timeouts on MySQL installations. Upgrading to v5.34.1 may also execute missing migrations that were scheduled for v5.32.0. These additions can be lengthy on very big MySQL (version 5.x) installations.\n MySQL のパスワードに特殊文字を使用している場合、Mattermost の開始に失敗する問題への対処が v5.34.2 にて加えられています。\n v5.34.2, released 2021-04-17 Fixing an issue where installs with some special characters in the MySQL password will break and fail to start.\n 本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。（なので、Enterprise 版限定の機能などについてはリリースノート書いてあることの紹介程度となっています）\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost v5.34 is now available - Upgrade to the new edition today Mattermost Changelog — Mattermost 5.34 documentation   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Cloud: Mattermost Cloud E20/E10: Enterprise E20/E10  見出しの前に何もない場合、Team Edition(OSS 版)でも利用可能な機能です。\n(Cloud/E20) Incident Collaboration におけるインシデント開始時操作の自動化 ここ数ヶ月開発が活発なIncident Collaboration Pluginに、インシデント開始時の操作を自動化する機能が追加されました。\nIncident Collaboratoin Plugin では、インシデント対応手順を予め Playbook として登録しておき、インシデント発生時に Playbook を元にしたインシデント専用チャンネルを作成することで、インシデント対応の様子を 1 つのチャンネルにまとめることができます。\n今回追加されたのは、インシデント専用チャンネル作成時に自動でそのチャンネルに追加されるメンバを指定しておける機能です。\nその他の機能 新たなプラグイン (CircleCI / Dice Roller) 新たなプラグインが紹介されています。\nCircleCI Plugin Mattermost/CircleCI Plugin - Circle CI Plugin\nMattermost と CircleCI を連携するプラグインです。こちらは Mattermost 公式チームによって開発されているようです。\n パイプライン/ワークフローの実行 Mattermost への通知 環境変数の管理 ワークフローメトリクスの取得  などが Mattermost 上から行えるようです。\nDice Roller Dice Roller Plugin - Mattermost - Open-source collaboration, self-managed or SaaS\nDice Roller プラグインは、Mattermost 上でダイスを振ることのできるプラグインです。 システム管理者向け非公開チャンネル参加確認ダイアログ システム管理者が非公開チャンネルにそのリンクから参加しようとした際、確認のためのダイアログが表示されるようになりました。\nチームサイドバーのテーマカラー Mattermost UI のテーマカラー指定において、チームサイドバーの部分にもカラー設定が可能になりました。sidebarTeamBarBgという値でサイドバーの色を指定できるようです。\n以下で Mattermost のテーマ集が公開されています。ここで公開されているテーマは公式テーマではないため、今回追加されたsidebarTeamBarBgが設定されていない可能性があります。\nMattermost Themes\npprof によるパフォーマンスモニタリング 今まで有償版(E20)限定の機能だったパフォーマンスモニタリングの機能のうち、pprof によるモニタリング機能を Team Edition(OSS 版)でも利用できるようになりました。\npprof によるモニタリングを行うには、システムコンソール \u0026gt; パフォーマンスモニタリング \u0026gt; パフォーマンスモニタリングを有効にする を 有効 に設定する必要があります。\n設定を変更した後、同じ設定画面で指定してあるポート番号にpprofを使ってアクセスすることで、Mattermost インスタンスのメトリクスを確認できるようになります。\n$ go tool pprof http://localhost:8067/debug/pprof/profile Fetching profile over HTTP from http://localhost:8067/debug/pprof/profile channel: open channel: no such file or directory Fetched 1 source profiles out of 2 Saved profile in /Users/test/pprof/pprof.samples.cpu.001.pb.gz Type: cpu Time: Apr 16, 2021 at 5:30pm (JST) Duration: 30s, Total samples = 50ms ( 0.17%) Entering interactive mode (type \u0026quot;help\u0026quot; for commands, \u0026quot;o\u0026quot; for options) (pprof) top Showing nodes accounting for 50ms, 100% of 50ms total Showing top 10 nodes out of 13 flat flat% sum% cum cum% 20ms 40.00% 40.00% 30ms 60.00% runtime.scanobject 10ms 20.00% 60.00% 10ms 20.00% github.com/gorilla/websocket.(*Conn).write 10ms 20.00% 80.00% 10ms 20.00% runtime.greyobject 10ms 20.00% 100% 10ms 20.00% runtime.netpoll 0 0% 100% 10ms 20.00% github.com/gorilla/websocket.(*Conn).WriteMessage 0 0% 100% 10ms 20.00% github.com/gorilla/websocket.(*messageWriter).flushFrame 0 0% 100% 10ms 20.00% github.com/mattermost/mattermost-server/v5/app.(*WebConn).Pump.func1 0 0% 100% 10ms 20.00% github.com/mattermost/mattermost-server/v5/app.(*WebConn).writePump 0 0% 100% 40ms 80.00% runtime.gcBgMarkWorker 0 0% 100% 40ms 80.00% runtime.gcBgMarkWorker.func2 その他のトピック Mattermost CEO による振り返り Mattermost の公式ブログで、今までの Mattermost の活動をどのような思想で進めてきたかについて、Mattermost CEO によって綴られています。\nHow We’ve Built an Open Source Community at Mattermost\nこちらの記事では、Mattermost がどのようにオープンソースコミュニティを築くために、どのような思想を持って活動してきたのかについて語られています。\nBuilding a Go-to-Market Strategy for Developer Tools\nこちらの記事では、Mattermost を成長させるための戦略について語られています。\nおわりに 次のv5.35のリリースは 2021/05/14(Fri)を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter で Mattermost に関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/plugin_emojigen/","title":"Mattermost EmojiGen plugin","section":"post","date":"2021.03.20","body":"Mattermost EmojiGen Mattermost 上でテキストから絵文字を作成できるプラグインを作ってた。\n下記にスクリーンキャストを載せてる。\nkaakaa/mattermost-emojigen: Creating custom emoji from slash command\n2 年前ぐらいに作ってたやつだけど、久しぶりに引っ張り出してゴリゴリと。以前、何かができなくて諦めてた気がするけど、そんなに大きな問題なく手当て完了。\n主な変更点は、今まで 2x2 の 4 文字までの絵文字しか作れなかったけど、上限文字数を撤廃。3x3 の圧倒的当事者意識的な絵文字も作れるようにした。とはいえ、視認性的に 3x3 でも厳しいぐらいだと思うけど。\nGo 言語で文字画像作るのは、文字数と描画位置をどのように決めるかとの戦い。テストコード書いて画像出力させながらゴリゴリ調整。脳筋。\nhttps://github.com/kaakaa/mattermost-emojigen/commit/21fd13ada28106ca1b7fcd3d0279cfef1e90ed11#diff-285e170643d9e80db83915466e06d2269d66a6cd59a3140e9db79cf5b6d7f834R47\nNo bot\u0026hellip; Mattermost プラグインでは、Plugin 起動時にプラグイン専用の Bot アカウントを作成して、その Bot からPlugin APIを叩かせて処理をやらせるというのが一般的だけど、悲しいことに絵文字登録 API がPlugin APIとして実装されていなかったので、プラグインの設定画面にアクセストークンを入力して、絵文字登録は REST API 経由で実行するという方式を取っている。\nそのため、セットアップ手順がちょっと面倒臭くなっている。REST API のなかで、Plugin API に実装されているものとされていないものの違いがわからないんだよな。Contribute しますって言えばやらせてもらえるのかな。\nCircleCI 久しぶりに CircleCI 回したらビルドがコケる。\n... Warning: Permanently added the RSA host key for IP address '140.82.112.3' to the list of known hosts. Permission denied (publickey). fatal: Could not read from remote repository. ... Deploy Key を作り直せば良かったらしい。\nCircleCI で checkout 時に「fatal: Could not read from remote repository.」出る（長く放置していた時に発生） - nwtgck / Ryo Ota\nGitHub Release tag 打っても Release Job が走らない。\n基本、Mattermost Plugin 関連のファイルは mattermost-plugin-starter-template から取って来るけど、このリポジトリにある Circle の設定ファイルには Release Job が定義されていなかった。\n使い慣れた？ Matterpoll の方の設定ファイルを持ってくる。\nhttps://github.com/matterpoll/matterpoll/blob/master/.circleci/config.yml\nmattermost/plugin-ciの Circle CI Orb は、最新バージョンv0.1.6まで進んでるんだけど、新しめのやつ(v0.1.2とかだったかな?)になると Mattermost 社の S3 インスタンスとかにアクセスしようとするので、認証情報設定しておかないとエラーになるのよね。なので一般コントリビュータはv0.1.0を使うしかない（と思う）。 ここら辺、ちゃんとドキュメント化されてないから手探りなのよね。\nまとめ Go で画像生成できるのが面白くて作り始めた気がするけど、まぁとりあえず形にはなったかな。ちゃんとテスト書いてないし、ちょっと操作性が微妙な気はするけど。\n言葉の絵文字が流行るのは日本的、というか漢字文化だよなぁ。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.33/","title":"Mattermost 5.33の新機能","section":"post","date":"2021.03.20","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2021/03/17 に Mattermost v5.33.0 がリリースされました。\nまた、近いうちに TLS 接続をしている際に WebSocket 通信が失敗する問題の修正を加えた v5.33.1 がリリースされるようです。\n[MM-34000] Websockets fail with TLS connections - Mattermost\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。（なので、Enterprise 版限定の機能などについてはリリースノート書いてあることの紹介程度となっています）\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost v5.33 is now available - Upgrade to the new release today Mattermost Changelog — Mattermost 5.33 documentation   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Cloud: Mattermost Cloud E20/E10: Enterprise E20/E10  見出しの前に何もない場合、Team Edition(OSS 版)でも利用可能な機能です。\nカスタムステータス Mattermost 上に表示されるステータスを自由に設定できるようになりました。\n今までのバージョンで設定できるステータスは、システム固有のオンライン(Online)、離席中(Away)、取り込み中(Do Not Disturb)、オフライン(Offline)の 4 種別でしたが、 これらのステータスとは別に、自由にメッセージや絵文字を指定できるカスタムステータスを設定できるようになりました。\nMattermost 画面左上のアイコン部分をクリックするとステータス設定メニューが表示され、その中にカスタムステータス設定メニューがあります。\nカスタムステータス設定メニューでは、絵文字とメッセージを指定することができます。絵文字にはユーザーが登録したカスタム絵文字も指定することができます。\n設定されたステータスは、投稿に表示される名前の横などに現れます。\nまた、スラッシュコマンドを使ってカスタムステータスを設定することもできます。\nカスタムステータスを設定しても、システム固有のステータス(オンライン等)は別に設定することができるため、システム固有ステータスによる通知のコントロール機能は引き続き使用することができます。\nカスタムステータスについて、詳しくは下記のエントリでも紹介されています。 Introducing custom statuses for Mattermost users | Mattermost\n(Cloud/E20) OpenID Connect OpenID Connect 仕様に基づいた全ての OAuth 2.0 プロバイダを Mattermost の認証に使用できるようになりました。\n今までのバージョンでは、GitLab、Google Apps、Office 365 による OAuth 2.0 認証が使用できましたが、OpenID Connect のサポートにより、Keycloak、Atlassian Crows、Apple、Microsoft、Salesforce、Auth0、Ory.sh、Facebook、Okta、OneLogin、Azure AD などが認証に使用できるようになります。\n(Cloud/E20) インシデントタイムライン ここ数ヶ月開発が活発なIncident Management Pluginにタイムライン機能が追加されました(呼び方がIncident Collaboration Pluginに変わった?)。\nタイムライン機能では、インシデント対応におけるステータスを更新や重要なイベントの記録を時系列で確認できる機能です。タイムライン機能により、インシデント対応後のレポート作成や、対応中インシデントの状況確認などがやりやすくなります。さらに、タイムラインに表示されたイベントをクリックすることで、そのイベントが行われた際の投稿にジャンプできるため、イベントに関連する会話を見返すのも容易になります。\nIncident Collaboration 機能のアップデートの詳細については、以下のエントリで詳しく紹介されています。\nMattermost Incident Collaboration for faster incident response\n(Cloud/E10/E20) サポートパケット生成機能 Mattermost インスタンスの設定の詳細や、ログ、その他のデプロイ情報などをダウンロードできるようになりました。これは、Mattermost の商用サポートチームが、トラブルシューティングを円滑に行うための機能です。\nその他のトピック Focalboard Mattermost が開発している a self-hosted alternative to Trello, Notion, and Asana なFocalboardが Reddit や HackerNews に取り上げられ、話題になっています。\n https://www.reddit.com/r/selfhosted/comments/m72mes/focalboard_open_source_selfhosted_project/ https://news.ycombinator.com/item?id=26499062  注目されたことで開発も活発になり、Docker サポートや翻訳サポートなどが進んでいます。\nちょうど私も先週 Focalboard を動かしていて、その時の感想を Zenn の方に書いていました。\n Notion のような UI の Trello っぽい Kanban ツールの OSS の Focalboard を触ってみた  まだバージョンが v0.6.1 ということもあり開発段階ではありますが、面白そうなプロジェクトのため今後もチェックしていきたいと思います。\nMattermost リポジトリのスター数が 20,000 に Mattermost Server の GitHub リポジトリのスター数が 20,000 を超えたようです。\nThe Mattermost server repo surpasses 20,000 stars on GitHub\nInternational Woman\u0026rsquo;s Day 3/8 の International Woman\u0026rsquo;s Day に合わせ、Mattermost に携わる女性にフィーチャーしたエントリが投稿されています。\nHappy International Women’s Day from Mattermost!\nおわりに 次のv5.34のリリースは 2021/04/16(Fri)を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter で Mattermost に関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.32/","title":"Mattermost5.32の新機能","section":"post","date":"2021.02.20","body":"Mattermost 記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2021/02/16 に Mattermost v5.32.0 がリリースされました。\nまた、02/17 に PostgreSQL を使用している際の検索機能に関する修正を行った v5.32.1 がリリースされています。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。（なので、Enterprise 版限定の機能などについてはリリースノート書いてあることの紹介程度となっています）\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost v5.32 is now available - Upgrade to the new release today Mattermost Changelog — Mattermost 5.32 documentation   各機能の見出し前の記号は、その機能が利用可能なエディションを表しています。\n Cloud: Mattermost Cloud E20/E10: Enterprise E20/E10  見出しの前に何もない場合、Team Edition(OSS 版)でも利用可能な機能です。\nカスタムチャンネルカテゴリ 以前より実験的な機能として公開されていた、チャンネルリストのカスタムカテゴリ作成機能が一般公開されました。このアップデートにより、チャンネルサイドバーで以下のような操作を行えるようになりました。\n サイドバーのチャンネルをグループ化するための任意のカテゴリを作成できます。カテゴリ内のチャンネルのソート順として、手動・アルファベット順・更新履歴順をカテゴリごとに設定できます。また、カテゴリを折り畳んだり、カテゴリ単位でミュートしたりできます。 1 クリックで未読チャンネルのみを表示するよう切り替えることができます。その他のオプションとして、未読チャンネルをサイドバー上部にグループ化するよう設定することもできます。 チャンネルに対する共通の操作（ミュート、既読にする、移動、お気に入り）をサイドバーから行うことができます。  チャンネルサイドバーの改善について、詳しくは下記を参照ください。\nOrganize your sidebar with custom, collapsible channel categories\n  (Cloud/E20) Incident Management プラグインの改善 v5.30 から導入された Mattermost 上でインシデント管理ができる Incident Mangement プラグインについて、登録したインシデントのステータスを細かく設定できるようになりました。以前までのバージョンではOngoing(進行中)かEnded(完了)の 2 つのステータスを設定できましたが、ステータスが以下の 4 つに増えました。\n Reported: インシデントが発生したが、まだ調査用のリソース等が登録されていない状態 Active: 報告された事象が責任者によりインシデントと認められ、調査が進行している状態 Resolved: インシデントによるリスクは緩和されたが、まだ作業が残っている状態 Archived: インシデント対応が完了し、関連するチャンネルや履歴がアーカイブされた状態。  また、完了済み・進行中の全インシデントを、リストとして一覧表示できるようになりました。\n(画像は公式ブログより)\n(Cloud/E20) Microsoft Teams ミーティングプラグイン Microsoft Teams と連携し、1 クリックで Teams ミーティングを作成・参加することができるプラグインが一般公開されました。\n(E10/E20) サブスクリプション更新のオンライン化 E10/E20 を利用している場合、サブスクリプションの更新手続きをオンラインで行えるようになりました。 更新作業はカスタマーポータルで行うことができ、カスタマーポータルでは、過去のサブスクリプション購入履歴も確認できます。\n(画像は公式ブログより)\n更新手続きについて、以下の動画で手順が説明されています。\n  その他の変更点 破壊的変更   既存のチャンネルサイドバー関連の設定は EnableLegacySidebar の設定を true にしない限り、有効にはならなくなりました。\n ExperimentalChannelOrganization EnableXToLeaveChannelsFromLHS CloseUnusedDirectMessages ExperimentalHideTownSquareinLHS    Go 言語 API クライアントの以下の API の必須パラメータ collapsedThread bool が追加されました。以下の API を利用している場合、修正が必要です。\n GetPostThread GetPostsForChannel GetPostsSince GetPostsAfter GetPostsBefore GetPostsAroundLastUnread    破壊的変更について詳しくは Changelog を参照してください。\nその他のトピック Sponsored Rocky Linux Project CentOS に関する RedHad の方針変更を受けて生まれた Rocky Linux プロジェクトについて、Mattermost がスポンサーとしてコミュニケーション基盤を提供しています。\nRocky Linux\nWhat Matterst - A Podcast from Mattermost Mattermost 主催の Podcast にエピソードが追加されています。最新のエピソードでは、前述の Rocky Linux のコミュニティマネージャーがゲストです。\nWhat Matters - A Podcast from Mattermost\nMattermost MVP 昨年 12 月に書いていたMattermost Integration Advent Calendarを評価していただき、2 度目の MVP を受賞いたしました。\n Thanks for all community contributions this month and, in particular, our v5.32 Most Valued Professional (MVP), Yusuke Nemoto, who published 25 blog posts as a “Mattermost Integrations Advent Calendar” in December 2020. Thank you for your continued contributions, Yusuke Nemoto!\n おわりに 次のv5.33のリリースは 2021/03/16(Tue)を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter で Mattermost に関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.31/","title":"Mattermost5.31の新機能","section":"post","date":"2021.01.17","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2021/01/16にMattermost v5.31.0がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。（なので、Enterprise版限定の機能などについてはリリースノート書いてあることの紹介程度となっています）\n今回のリリースから毎バージョン新機能が追加されることになったため、新機能紹介記事も毎月書いていきます。 (v5.30までは、新機能リリースと機能改善リリースを交互にリリースしていたため、新機能紹介記事も隔月で書いていました)\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost v5.31 is now available - Mattermost Extended Support Release Mattermost Changelog — Mattermost 5.31 documentation   (E20) Incident Managementプラグインの改善 v5.30から導入されたMattermost上でインシデント管理ができるIncident Mangementプラグインについて、機能改善が行われました。(Incident Managementプラグインについては、前回の記事で無償版でも使えそうと書いていましたが、やはりEnterprise版限定のプラグインのようです)\n新しいバージョンのプラグインでは、インシデント対応のテンプレートを定義するPlaybookを作成する際の設定項目が追加されています。\n インシデントに対する更新があった場合に、更新内容を通知するチャンネルを指定 インシデントに関するリマインダを通知する時間を指定 メッセージのテンプレートを追加  プラグインの紹介 GitLabプラグインのアップデート MattermostでGitLabの更新内容を受け取れるGitLabプラグインがアップデートされ、セットアップが簡単にできるようになったようです。\nMattermost/GitLab Integration - GitLab Plugin\nIcebreakerプラグイン コロナ禍のコミュニケーション対策として、アイスブレイクとなる質問を投稿するBotを追加するプラグインの紹介です。 monsdar/mattermost-icebreaker-plugin: A Mattermost plugin that asks Icebreaker questions\nGIF コマンドプラグイン Mattermost上にGIPHYからGifアニメーションを投稿するプラグインの紹介です。過去にGiphyプラグインとして公開されていたプラグインの名前が変わったもののようです。 moussetc/mattermost-plugin-giphy: A Giphy/Gfycat/Tenor plugin for Mattermost (/gif\u0026amp;/gifs commands)\nその他の更新 実験的なチャンネルサイドバーの改善 Mattermost v5.26より実験的な機能としてチャンネルサイドバーに独自のカテゴリを作成できるようになりましたが、作成したカテゴリ単位でチャンネルのミュートを指定できるようになりました。\nまた、ドラッグ＆ドロップでチャンネルを移動する際に、Ctrl + クリックやShift + クリックでチャンネルを複数選択することで、同時に複数のチャンネルを移動できるようになりました。\n今後のリリース予定 返信の折畳み機能 以前より開発が進められていた、返信スレッドをチャンネル上に表示しないようにできるCollapsed Reply Thread(返信スレッドの折畳み)機能が2021年1~3月中に追加される予定です。Mattermost v5.29.1で、Collapsed Reply Thread向けのデータベースの更新が行われているため、このバージョンより前のバージョンを使用している場合は、アップデートしておくことが推奨されています。 Dev Sneak Peek: Collapsed Reply Threads in Mattermost\nmmctlコマンドのTLS 1.0, 1.1接続の無効化 リモート環境からMattermostを操作するコマンドラインツールmmctlを使用する際、接続先のMattermostサーバーがTLS 1.0, 1.1を使用している場合、明示的にオプションを指定しない限りエラーとなるようになります。\nplatformコマンドがdeprecatedに Mattermostサーバーを操作するコマンドラインツールとしてplatformコマンドがありましたが、platformコマンドは過去のコマンドであり、今後のリリースでdeprecatedとなる予定のため使用しないことが推奨されています。代わりにmattermostコマンドを使用してください。\nおわりに 次のv5.32のリリースは2021/02/16(Tue)を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/tech/make-gif-for-post/","title":"ブログ用のgifファイルを作るコマンドの備忘録","section":"post","date":"2021.01.09","body":"何かの解説記事を書く時とかに、デスクトップをキャプチャした操作動画などを載せたいことがある。 そんな時は、普段Macを使っているので Shift + Cmd + 5 のショートカットで動画を撮り、生成された.movファイルをffmpegで適当に.gifファイル化していたんだけど、どうも生成した.gifのサイズがMB単位になっていたようで、圧縮したいなと思った。\n↓の記事を参考に試行。 ffmpegでとにかく綺麗なGIFを作りたい - Qiita\nそしてできたのがこちらのコマンド。\n$ NAME=incident $ ffmpeg -i ${NAME}.mov -filter:v \u0026#34;setpts=PTS/2.0,scale=trunc(iw/2)*2:trunc(ih/2)*2\u0026#34; ${NAME}_refine.mov $ ffmpeg -i ${NAME}_refine.mov -filter_complex \u0026#34;[0:v] fps=10,scale=640:-1 [r];[r] split [a][b];[b]fifo[bb]; [a] palettegen [p];[bb][p] paletteuse\u0026#34; ${NAME}.gif 1つ目のffmpegコマンドでは.movファイルに手を加えている。等速の操作動画だとモタモタしすぎなので setpts=PTS/2.0 で倍速にしているのと、サイズを2の倍数にしている(はず)。サイズを2の倍数にするのは.gif化するときに width not divisible by 2 というエラーで怒られたから（だったはず。記憶曖昧）。\n2つ目のffmpegコマンドで、1つ目のコマンドで出力した.movファイルを.gifファイル化。\n途中で Buffer queue overflow, dropping. という警告メッセージが出ている場合、最終成果物の.gifファイルが途中でフリーズした感じで生成されてしまうので注意。一応、これの対処も入ったコマンドのはずだけど。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day25-contribute/","title":"Mattermostへの貢献","section":"post","date":"2020.12.25","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第25日目の記事です。\n最終日の記事は、これまでの記事執筆にあたって見つけた問題を修正した記録について紹介します。と言っても、簡単なドキュメントの修正が主です。（昨日までのMattermost Pluginの記事が重かったため力尽きました\u0026hellip;。）\nMattermostへのコントリビュート MattermostはOSSとして開発が進められており、そのコードやドキュメントなどはGitHubで公開されているため、誰でもPullRequestを送ることができます。\nhttps://github.com/mattermost\nコントリビューションの仕方などは本日の記事では紹介しませんが、以下のページにMattermostとしてのコントリビューションのやり方などについてまとめてあります。コントリビューションを続けることで様々なギフトを貰うことができるので、興味のある方は是非コントリビューションしてみてください。\nhttps://mattermost.com/contribute/\nコントリビューション記録 ドキュメントのフォーマット修正 Specify required language in code blocks by kaakaa · Pull Request #726 · mattermost/mattermost-developer-documentation\n開発者向けのドキュメントサイトで、フォーマットが正しくされていない点がいくつかあったため修正しました。\nTooltipテキストの修正 Fix tooltip text for copying incoming webhook url by kaakaa · Pull Request #6996 · mattermost/mattermost-webapp\nIncoming WebHook作成時のコピーアイコンに設定されているTooltipテキストに誤った値が設定されていたのを修正しました。\nドキュメントのパラメータ型誤りの修正 Fix incorrect type of `notify_on_cancel` by kaakaa · Pull Request #4193 · mattermost/docs\nこれもドキュメントの修正で、パラメータの型が誤っていたのを修正（併せて簡単なインデントの修正も）。\nデッドリンクの修正 fix invalid link for js websocket client by kaakaa · Pull Request #596 · mattermost/mattermost-api-reference\nAPIドキュメントのJavaScript WebSocket Clientへのリンクが404だったので修正。\nさいごに これまで25日に渡ってOSSのSlack Alternativeなチャットツール Mattermostの外部連携を行うための統合機能について紹介してきました。 チャットと言えばユーザー数の面からSlackやMicrosoft Teamsが有名ですが、オンプレミスなどのプライベートな環境にも構築可能なチャットツールとして、Mattermostも着実に進化を続けています。Mattermostは、最近ではDevOps Command Centerという方針を打ち出しており、ただのチャットだけではなくDevOpsを進める上でのコミュニケーションの中心となるべく機能が追加されています。2020/12/16にリリースされたMattermost v5.30に同梱されている、Mattermost上でインシデント管理を行える Mattermost Incident Management Plugin などはその最たるものだと思います。 これらの外部サービスと連携するコミュニケーション基盤は、今回のアドベントカレンダーで紹介してきたMattermost Integrationsの機能をベースに構築されるため、DevOpsに限らずMattermostのユースケースを広げようとする際に参考になる情報になるのではないかと思います。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day24-matterpoll-development/","title":"[Mattermost Integrations] Matterpoll Plugin (Development)","section":"post","date":"2020.12.24","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第24日目の記事です。\n以前から開発に参加しているMatterpollがMattermost公式のPlugin MarketplaceでCommunity Pluginとして公開されました。\n昨日までの記事でMatterpoll PluginのServer側・Webapp側の実装について紹介しましたが、本日の記事ではMatterpoll PluginのテストやCIなどの開発周りの話を紹介します。\nMattermost Pluginのテスト Server側のテスト Mattermost PluginのServer側の機能をMattermostを実際に起動することなくテストするには、plugintestパッケージを使用します。\n[plugintest]https://github.com/mattermost/mattermost-server/tree/master/plugin/plugintest](https://github.com/mattermost/mattermost-server/tree/master/plugin/plugintest)パッケージを使用してテストを記述していく方法について、Mattermost本体にあるプラグインテストのサンプルコードを元に紹介します。Matterpollプラグインも大部分はこれと同じ方式でテストが記述されています。\n... type HelloUserPlugin struct { plugin.MattermostPlugin } func (p *HelloUserPlugin) ServeHTTP(context *plugin.Context, w http.ResponseWriter, r *http.Request) { userID := r.Header.Get(\u0026#34;Mattermost-User-Id\u0026#34;) user, err := p.API.GetUser(userID) if err != nil { w.WriteHeader(http.StatusBadRequest) p.API.LogError(err.Error()) return } fmt.Fprintf(w, \u0026#34;Welcome back, %s!\u0026#34;, user.Username) } ... https://github.com/mattermost/mattermost-server/blob/5122b9e2929dbf84e22f496ee97d007fa18f2d2e/plugin/plugintest/example_hello_user_test.go#L21\nMattermostプラグインの本体は、plugin.MattermostPluginがembeddedされた構造体です。ここでは、HelloUserPlugin 構造体がそれにあたります。この構造体を通じてプラグイン用のAPIを実行したり、Hookとなるメソッドを実装したりすることで、サーバー側の動作を定義することができます。HelloUserPlugin では、プラグイン独自のエンドポイントを追加する ServeHTTP Hooksが実装され、その処理の中で GetUser API を実行してエンドポイントへアクセスしたユーザーの情報を取得し、そのユーザー名をレスポンスとして返しています。\nこのServeHTTP Hooksをテストする場合、単にHelloUserPlugin構造体を生成してServeHTTPメソッドを実行しただけだと、プラグインAPI (GetUser) の実行部分で実際のMattermostサーバーの機能を呼び出そうとしてしまいエラーとなってしまいます。\nuser, err := p.API.GetUser(userID) HelloUserPlugin の API フィールドは、plugin.MattermostPlugin 構造体が持っていたフィールドであり、このフィールドを通して呼び出されるメソッドはMattermostサーバーの処理に依存しているからです。Mattermostサーバーがない状態でテストを実行する場合、このAPIフィールドを入れ替える必要があります。\nここで、プラグイン用のテストメソッドとして定義されている Example メソッドをみてみましょう。\n... func Example() { t := \u0026amp;testing.T{} user :\u0026amp;model.User{ ... (1) Id: model.NewId(), Username: \u0026#34;billybob\u0026#34;, } api := \u0026amp;plugintest.API{} ... (2) api.On(\u0026#34;GetUser\u0026#34;, user.Id).Return(user, nil) ... (3) defer api.AssertExpectations(t) ... (4) helpers := \u0026amp;plugintest.Helpers{} defer helpers.AssertExpectations(t) p := \u0026amp;HelloUserPlugin{} p.SetAPI(api) ... (5) p.SetHelpers(helpers) w := httptest.NewRecorder() r := httptest.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/\u0026#34;, nil) r.Header.Add(\u0026#34;Mattermost-User-Id\u0026#34;, user.Id) p.ServeHTTP(\u0026amp;plugin.Context{}, w, r) ... (6) body, err := ioutil.ReadAll(w.Result().Body) require.NoError(t, err) assert.Equal(t, \u0026#34;Welcome back, billybob!\u0026#34;, string(body)) } https://github.com/mattermost/mattermost-server/blob/5122b9e2929dbf84e22f496ee97d007fa18f2d2e/plugin/plugintest/example_hello_user_test.go#L37\n**(2)**で plugintest.API という構造体のインスタンスを生成し、生成されたインスタンスをテスト対象のプラグイン構造体 HelloUserPlugin へ SetAPI 関数を通じてセット (5) しています。 plugintest.API自体は、そのままでは何も処理を行わないため、api.On で特定の引数が与えられた時の処理をテスト側で実装しています (3)。\n... user :\u0026amp;model.User{ ... (1) Id: model.NewId(), Username: \u0026#34;billybob\u0026#34;, } ... api.On(\u0026#34;GetUser\u0026#34;, user.Id).Return(user, nil) ... (3) defer api.AssertExpectations(t) ... (4) ... 上記のコードの場合、user.Id を引数として GetUser メソッドが呼び出された場合に (1) で定義された user を返却するようモックを定義しています。また、defer api.AssertExpectations(t) (4) を書いておくことで、テスト実行が終了した時に api.On で定義したモックが実行されていなかった場合にテストを失敗させることができます。\nHelloUserPlugin では Helpers関数を利用していませんでしたが、Helpersのメソッドを利用している場合も API と同様に関数をモックすることができます。\n最後に httptest パッケージを使って ServeHTTP Hook を呼び出し、レスポンスが想定通りであることをチェックしています。\nw := httptest.NewRecorder() r := httptest.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/\u0026#34;, nil) r.Header.Add(\u0026#34;Mattermost-User-Id\u0026#34;, user.Id) p.ServeHTTP(\u0026amp;plugin.Context{}, w, r) ... (6) このように plugintest パッケージを使うことで 、Mattermostサーバーがない状況でもMattermostプラグインの処理をテストできるようになります。あとは、とにかくパターンを網羅するケースを書き出すだけです。筋力です。\nServer側のテスト(Store) Matterpollでは Mattermost PluginのKey Valueストアへのアクセスを抽象化した store パッケージを用意しています。テスト対象のメソッド内で Key Value ストアへのアクセスが必要な処理があった場合、プラグインAPIの KVSet、KVGet などのメソッドを plugintest パッケージでモックすることも可能ですが、テスト記述が煩雑になるため、Matterpollでは vektra/mockery を使って store.Store インタフェースからモックを生成してテストを記述しています。この vektra/mockery は、Mattermost本体の plugintest パッケージを生成するのにも使われているものです。\nWebapp側のテスト ここについては、Mattermost Plugin特有のトピックというものはなく、開発したReact Componentに対してJest を使ったsnapshotテストを実装しています。\nCI CIはCircleCIを使っており、Mattermostプラグイン用のCircleCI Orbを使って lint / build/ coverage / deploy を行っています。\nhttps://github.com/matterpoll/matterpoll/blob/master/.circleci/config.yml\nカバレッジは Codecov によるPRへのコメントフィードバックを実施しています。\nChecks 静的解析系のツールはMattermostプラグインのテンプレートリポジトリ mattermost/mattermost-plugin-starter-template: Build scripts and templates for writing Mattermost plugins. で定義されているものとベースは同じで、採用しているlinterやルールが少し異なるという感じです。\nサーバー側は golangci-lint を使っており設定ファイルは下記の通りです。\nrun: timeout: 5m modules-download-mode: readonly linters-settings: goconst: min-len: 2 min-occurrences: 2 gofmt: simplify: true goimports: local-prefixes: github.com/matterpoll/matterpoll golint: min-confidence: 0.0 govet: check-shadowing: true enable-all: true misspell: locale: US maligned: suggest-new: true linters: disable-all: true enable: - bodyclose - deadcode - dogsled - errcheck - goconst - gocritic - gofmt - goimports - golint - gosec - gosimple - govet - ineffassign - interfacer - maligned - misspell - nakedret - scopelint - staticcheck - structcheck - stylecheck - typecheck - unconvert - unparam - unused - varcheck - whitespace issues: exclude-rules: # Exclude some linters from running on tests files. - path: _test\\.go linters: - dupl - goconst - scopelint # https://github.com/kyoh86/scopelint/issues/4 https://github.com/matterpoll/matterpoll/blob/d4ffdbfd6dcdea359b7419e0baa3ab8aaa32e420/.golangci.yml\nクライアント側は ESLint を使っており、設定ファイルは下記の通りです。（長いためリンク先参照）\nhttps://github.com/matterpoll/matterpoll/blob/0b797025cfbf319c43464fcf457d4cdfe5086188/webapp/.eslintrc.json\n翻訳 Matterpollのメッセージは翻訳可能な形式で管理されており、現在、下記の言語が利用可能です。\n English France German Japanese Korean Polish Simplified Chinese Spanish Traditional Chinese  言語の切り替えは、Mattermost本体の設定に応じて実施されます。\nMattermost Pluginにおける翻訳処理の詳細については、Matterpollの共同開発者であるHanzei による下記の記事で紹介されています。\nhttps://developers.mattermost.com/blog/localizing-matterpoll/\nServer側の翻訳 Server側の翻訳機能はgo-i18nを使用しています。\n翻訳対象のメッセージは、コード上では以下のようにgo-i18nのi18nパッケージの構造体として書かれています。\n... HelpText: p.LocalizeWithConfig(l, \u0026amp;i18n.LocalizeConfig{ DefaultMessage: \u0026amp;i18n.Message{ ID: \u0026#34;dialog.createPoll.setting.multi\u0026#34;, Other: \u0026#34;The number of options that an user can vote on.\u0026#34;, }}), ... https://github.com/matterpoll/matterpoll/blob/45f095875a98fb1d4f3f166851c86f41b987493e/server/plugin/command.go#L265\n実際の翻訳を行う場合は、go-i18nのコマンドラインツールを使って、上記のようなi18nの構造体として宣言されたメッセージをjsonファイルに集約します。その辺りの手順については以下のドキュメントにまとめられています。\nhttps://github.com/matterpoll/matterpoll/blob/master/CONTRIBUTING.md#translating-strings\ngo-i18nによって集約されたメッセージを各国のコントリビュータにローカライズしてもらうことで、翻訳されたメッセージが表示されるようになっています。 https://github.com/matterpoll/matterpoll/tree/45f095875a98fb1d4f3f166851c86f41b987493e/assets/i18n\nWebapp側の翻訳 Matterpoll Pluginでは、まだWebapp側の翻訳機能は実装されていませんが、Mattermost Pluginの機能としては実装できるようになっています。\nWebapp側の翻訳は、react-intlを使用しています。\n... import {FormattedMessage} from \u0026#39;react-intl\u0026#39;; ... \u0026lt;FormattedMessage id=\u0026#39;rootModal.message\u0026#39; defaultMessage=\u0026#39;Root Modal2\u0026#39; /\u0026gt; ... 上記のようにコード内で使用されている翻訳対象のメッセージは、make i18n-extractで集約することができます。\n... ## Extract strings for translation from the source code. .PHONY: i18n-extract i18n-extract: ifneq ($(HAS_WEBAPP),) ifeq ($(HAS_MM_UTILITIES),) @echo \u0026#34;You must clone github.com/mattermost/mattermost-utilities repo in .. to use this command\u0026#34; else cd $(MM_UTILITIES_DIR) \u0026amp;\u0026amp; npm install \u0026amp;\u0026amp; npm run babel \u0026amp;\u0026amp; node mmjstool/build/index.js i18n extract-webapp --webapp-dir $(PWD)/webapp endif endif ... https://github.com/matterpoll/matterpoll/blob/master/Makefile#L205\n集約されたメッセージファイルをMattermost Webapp Plugin APIのregisterTranslationsで登録することで、Webapp側のメッセージの翻訳ができるようになります。\nさいごに 本日は、Matterpoll PluginのテストやCIなどの開発に関する事柄について紹介しました。 Mattermost Integractionsに関する紹介は本日の記事で終了です。\n明日は、本記事を執筆する中で見つかった問題に対するIssue/PRについて紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day23-matterpoll-webapp/","title":"[Mattermost Integrations] Matterpoll Plugin (Webapp)","section":"post","date":"2020.12.23","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第23日目の記事です。\n以前から開発に参加しているMatterpollがMattermost公式のPlugin MarketplaceでCommunity Pluginとして公開されました。\n昨日の記事ではMatterpoll PluginのServer側の実装について紹介しましたが、本日の記事ではMatterpoll PluginのWebapp側の機能について紹介します。\nWebapp側の処理 Webapp側では、ユーザー毎に投票の見え方を変えるための処理を実装しています。\n独自のPostTypeによる投票済み回答のハイライト Mattermosで投稿したメッセージは、Mattermost上では Post 構造体のデータとして扱われています。そして、Post構造体のType フィールドの値によって投稿の種別を判別しています。Post.Typeはデフォルトでは大きく分けて二つの種類があり、一つは通常ユーザーが投稿するメッセージ（ Post.Type が空文字（POST_DEFAULT）。もう一つは、チャンネル参加時などにシステムによって投稿されるメッセージ（Post.Type は system_ で始まる）です。\nMattermost上のメッセージの見た目は Message Attachements の機能を使う事である程度変更することはできますが、 Message AttachmentsではMattermostユーザー全員に対して同じ見た目しか提供できないため、ユーザー毎にメッセージの一部を変更したい場合などはプラグインで処理する必要があります。Matterpollの場合「自分が投票した回答がどれなのか表示したい」というようなユーザー毎に表示を変更する要求があったため、この部分をプラグインで処理しています。\nプラグインで投稿の見た目を変えたい場合、まずServer側で投稿を作成する際に、独自のPost.Typeを設定する必要があります。Matterpollではスラッシュコマンド /poll が実装された際に投票用の投稿 (Post) を作成するのですが、その際に Post.Type に custom_matterpoll という値を設定しています。\n... const ( ... // MatterpollPostType is post_type of posts generated by Matterpoll \tMatterpollPostType = \u0026#34;custom_matterpoll\u0026#34; ) ... https://github.com/matterpoll/matterpoll/blob/45f095875a98fb1d4f3f166851c86f41b987493e/server/plugin/plugin.go#L53\n... post := \u0026amp;model.Post{ UserId: p.botUserID, ChannelId: args.ChannelId, RootId: args.RootId, Type: MatterpollPostType, Props: map[string]interface{}{ \u0026#34;poll_id\u0026#34;: newPoll.ID, }, } model.ParseSlackAttachment(post, actions) rPost, appErr := p.API.CreatePost(post) ... https://github.com/matterpoll/matterpoll/blob/45f095875a98fb1d4f3f166851c86f41b987493e/server/plugin/command.go#L191\n上記のようにPost.Type にプラグイン独自の値を設定しましたが、Webapp側でcustom_matterpollというPost.Typeに対する処理を追加しない限り、通常の投稿と同じように表示されてしまいます。Mattermostプラグインでは、WebApp プラグインAPIのregisterPostTypeComponent を使い Post.Type に custom_matterpoll が設定された場合のレンダリング方法を指定しています。\nregisterPostTypeComponent は第一引数にPost.Type の文字列を指定し、第二引数にReactコンポーネントを指定します。Matterpollの場合は、Server側で Post.Type に custom_matterpoll を指定しているため、下記のように第一引数に custom_matterpoll を、第二引数に独自のReactコンポーネントを指定して registerPostTypeComponent を呼び出しています。\nimport PostType from \u0026#39;components/post_type\u0026#39;; ... if (data.experimentalui) { registeredComponentId = registry.registerPostTypeComponent(\u0026#39;custom_matterpoll\u0026#39;, PostType); } else { registry.unregisterPostTypeComponent(registeredComponentId); registeredComponentId = \u0026#39;\u0026#39;; } ... https://github.com/matterpoll/matterpoll/blob/fa1f3aa8489deb24706937beac7d9976b0528ed7/webapp/src/actions/config.js#L11\nregisterPostTypeComponent は戻り値として登録されたReactコンポーネントに対応するID文字列を返しますが、これは登録したコンポーネントをunregisterPostTypeComponentを利用して解除する場合に必要なためstateに保持しています。\nMatterpollでは、Webapp側の機能はまだExperimentalな機能として設定でOn/Offを切り替えられるようにしているため、設定変更によってコンポーネントを登録/解除できるようにしています。\nこのように、プラグイン独自に投稿の見た目を変えたい場合、自作のReactコンポーネントを作成する必要があります。この時、Mattermost本体が構築する投稿に関するDOMの一部だけ表示を変更するなどができると良いのですが、MattermostのReactコンポーネントは外部から参照できる形で公開されていないため、一から自分で作る必要がありなかなか難儀しています\u0026hellip;。ただ、Reactコンポーネントを開発する際のユーティリティ関数がいくつか利用可能なため、この辺りを使っいます。\nhttps://developers.mattermost.com/extend/plugins/webapp/reference/#post-utils\nプラグイン独自のWebSocketイベント MattermostのServerとWebappの間はWebSocketによりやり取りが行われています。\nWebapp側でWebSocketイベントを受信した時の独自処理を登録するのが registerWebSocketEventHandlerメソッドです。このメソッドは、第一引数にWebSocketイベント名、第二引数にWebSocketイベントを受け取ったときに実行される処理を関数として登録します。\nMattermostがデフォルトでPublishしているWebSocketイベントはAPIドキュメントに一覧でまとめられており、メッセージの投稿/削除/編集やチャンネルの作成/削除、参加/脱退など、ユーザー操作に対するイベントが一通り網羅されています。また、Server側からプラグインごとに独自のWebSocketイベントをPublishすることもでき、Matterpollでは、Matterpollプラグインの設定が変更された時と、ユーザーが投票に回答したときに独自のWebSocketイベントを送信しています。\nプラグイン独自のWebSocketイベントをPublishするには、Server側でプラグインAPIのPublishWebSocketEventを実行するだけでよく、Matterpollでは下記のようなメソッドを作成し、投票データに変更があった時にこの処理を呼び出すことで、投票に関する最新のデータをWebappに送信しています。\nfunc (p *MatterpollPlugin) publishPollMetadata(poll *poll.Poll, userID string) { hasAdminPermission, appErr := p.HasAdminPermission(poll, userID) if appErr != nil { p.API.LogWarn(\u0026#34;Failed to check admin permission\u0026#34;, \u0026#34;userID\u0026#34;, userID, \u0026#34;pollID\u0026#34;, poll.ID, \u0026#34;error\u0026#34;, appErr.Error()) hasAdminPermission = false } metadata := poll.GetMetadata(userID, hasAdminPermission) p.API.PublishWebSocketEvent(\u0026#34;has_voted\u0026#34;, metadata.ToMap(), \u0026amp;model.WebsocketBroadcast{UserId: userID}) } https://github.com/matterpoll/matterpoll/blob/45f095875a98fb1d4f3f166851c86f41b987493e/server/plugin/api.go#L411\nプラグインAPIである PublishWebSocketEvent は3つの引数を取り、第一引数でPublishするWebSocketイベントのイベント名を指定します。実際には、ここで指定されたイベント名の先頭に custom_\u0026lt;pluginid\u0026gt;_ を付与したイベント名としてやり取りされるため、第1引数を \u0026ldquo;has_voted\u0026rdquo; としている今回の例では custom_com.github.matterpoll.matterpoll_has_votedというWebSocketイベント名となります。イベント名にプラグインIDが入っているため、プラグイン間のイベント名の競合については考慮する必要がありません。\n第2引数にはPublishするデータを指定します。map 形式でvalueには interface{} 型が指定できますが、この値にはGoのプリミティブ型か mattermost-server/model しか指定できません。それ以外の値を指定してしまうと、実行時にエンコードエラーとなります。（Mattermostサーバーのログを確認しないと分からないためハマりがちです）\n第3引数では、このWebSocketイベントをどのユーザーに対して送信するかを決定します。model.WebsocketBroadcastの定義を見ると、ユーザー単位以外にもチャンネルやチーム単位で指定することもできそうです（試したことはないですが）。\n次に、Server側からPublishされたWebSocketイベント custome_com.github.matterpoll.matterpoll_has_voted をWebapp側で処理するために、前述の registerWebSocketEventHandler を実行します。\nexport default class MatterPollPlugin { async initialize(registry, store) { ... registry.registerWebSocketEventHandler( \u0026#39;custom_\u0026#39; + pluginId + \u0026#39;_has_voted\u0026#39;, (message) =\u0026gt; { store.dispatch(websocketHasVoted(message.data)); }, ); ... } https://github.com/matterpoll/matterpoll/blob/0b797025cfbf319c43464fcf457d4cdfe5086188/webapp/src/plugin.jsx#L17\n上記のように、Webapp側のプラグイン起動時にWebSocketを受信した時のHandlerを登録しておくことで、Mattermost上の操作に応じてWebapp側の表示を変えるなどの処理を行えるようになります。\nさいごに 本日は、Mattermost上で投票を行えるようにするMatterpoll PluginのWebapp側の実装について紹介しました。 明日は、Matterpoll Plugin開発におけるテストやCIについて紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day22-matterpoll-server/","title":"[Mattermost Integrations] Matterpoll Plugin (Server)","section":"post","date":"2020.12.22","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第22日目の記事です。\n以前から開発に参加しているMatterpollがMattermost公式のPlugin MarketplaceでCommunity Pluginとして公開されました。\n公式のPlugin Marketplaceで公開されたことにより、プラグインをアップロードする必要なくメインメニュー \u0026gt; プラグインマーケットプレースからボタン一つでインストールできるようになりました。\nMatterpollはMattermost上で投票を行うことができるPluginであり、Mattermost社の開発者である Hanzei と私を中心に開発が進められています。\n以前よりMattermostに投票機能を付けるという提案はMattermostのFeature Request Forumでも票数を集めていたため、以前は絵文字で投票を促すような統合機能を開発していました。\nhttps://github.com/matterpoll/matterpoll-emoji\nただその当時はMattermostにPlugin機能がなかったため、この統合機能を利用するにはMattermostとは別にサーバーアプリを起動しておく必要があるのが難点でした。\nその後、MattermostにPlugin機能が付いたことで、Mattermostのプロセスの上で統合機能を動作させることができるようになり、matterpoll-emoji もPluginとして開発し直すこととなりました。そこで出来たプラグインが、今回Plugin Marketplaceで公開されたMatterpoll Pluginになります。\nこの記事では、まだ日本語ではあまり情報のないMattermost Pluginについて、Matterpoll Pluginの構造を元に紹介していきたいと思います。\n本記事では、MattermostプラグインのGetting Started的な部分についてはあまり触れません。Mattermost Pluginの基本的な部分については、アドベントカレンダーの他の記事や、公式ドキュメントを参照いただければと思います。\nhttps://developers.mattermost.com/extend/plugins/\nまた、実際に開発を始める場合はGitHubで公開されているMattermost Plugin用のテンプレートリポジトリ https://github.com/mattermost/mattermost-plugin-starter-template を使用するのがおすすめです。テンプレートリポジトリを使った開発の始め方については、下記の記事で紹介しています。（少し情報が古いかもしれません\u0026hellip;）\nMattermostプラグイン用のリポジトリテンプレート · kaakaa blog\n概要 Matterpoll PluginはServer側の機能とWebapp側の機能が連携して動作しています。\nServer側の機能は投票作成コマンド(/poll)を処理したり、投票が実行のHTTPリクエストを受け取って処理をしたり、投票に関するデータを管理したりしています。Webapp側ではユーザー毎に表示を変えたい場合など、クライアント側の処理を実装しています。Server側はGo言語、WebApp側はReact.js(JavaScript/TypeScript)で書かれています。\nMattermostの基本的な処理の流れは下記のようになります。\nユーザーがMattermost上でスラッシュコマンド /poll を実行する (1) と、そのコマンドをMatterpoll Server側が受け取り (2)、投票データ(Poll)を作成します (3)。作成された Poll のデータは、プラグイン用のKey-Value Storeに格納されます (4)。そして、Mattermostの投稿形式 (Post)へ変換され (5)、通常の投稿と同様にMattermostのデータベースに格納され (6)、WebappへWebSocketを通じてPublishされます (7)。(実際には、諸事情により投稿が作成 (6) されてから投票データをKey-Valueストア に格納 (4) していますが、話を簡単にするため上記の順で話をしています)\nMatterpoll Pluginにより作成されたメッセージは、Mattermost Webapp側の処理によってユーザー毎に見た目が変わります (8)。具体的には、自分が投票した回答のボタンの色が変わったり、投票管理系のボタンが権限のないユーザーから見えなくなったりします。このWebApp側の機能は、現在実験的な機能として提供されており、デフォルトではOffになっています。MattermostのSystem ConsoleのMatterpollプラグインの設定からOnにすることが出来ます。(設定がOffでも、投票機能自体は利用可能)\nServer側の処理 MatterpollプラグインはServer側で投票の作成、実行、データの管理などの投票に関わる基本的な処理を実装しています。ここでは、Mattermost Pluginの機能により、以下の処理をどのように実装しているかについて紹介していきます。\n プラグイン専用のスラッシュコマンドを追加し、投票作成コマンドを実行できるようにする プラグイン専用のエンドポイントを追加し、ユーザーからの投票を受け付ける プラグイン専用のKey-Valueストアで投票データを管理する  投票作成用の独自スラッシュコマンドの追加 Matterpollは専用のスラッシュコマンド /poll を実行することで投票を作成します。この /poll コマンドは、プラグイン起動時に登録されます。\nMattermostプラグインでは、プラグインAPIの RegisterCommand を実行することで新たなスラッシュコマンドを登録することができます。\n実際のコードでは下記のようになります。\n... // OnConfigurationChange loads the plugin configuration, validates it and saves it. func (p *MatterpollPlugin) OnConfigurationChange() error { ... // This require a loaded i18n bundle \tif p.isActivated() { command, err := p.getCommand(configuration.Trigger) if err != nil { return errors.Wrap(err, \u0026#34;failed to get command\u0026#34;) } ... if err := p.API.RegisterCommand(command); err != nil { return errors.Wrap(err, \u0026#34;failed to register new command\u0026#34;) } ... } ... } ... https://github.com/matterpoll/matterpoll/blob/45f095875a98fb1d4f3f166851c86f41b987493e/server/plugin/configuration.go#L43\nRegisterCommandの引数には、getCommandメソッドの戻り値 command を指定していますが、getCommandはSlash Commandのモデルであるmodel.Commandを生成するための内部メソッドです。\nfunc (p *MatterpollPlugin) getCommand(trigger string) (*model.Command, error) { ... return \u0026amp;model.Command{ Trigger: trigger, AutoComplete: true, AutoCompleteDesc: p.LocalizeDefaultMessage(localizer, commandAutoCompleteDesc), AutoCompleteHint: p.LocalizeDefaultMessage(localizer, commandAutoCompleteHint), AutocompleteIconData: iconData, }, nil } https://github.com/matterpoll/matterpoll/blob/45f095875a98fb1d4f3f166851c86f41b987493e/server/plugin/command.go#L215\nまた、getCommandの引数 (configuration.Trigger)はSlash Commandのトリガーワード(スラッシュコマンド名)ですが、Matterpollではスラッシュコマンド名を設定から変更できるようにしてあるため、設定画面で入力された値を使用するためにconfiguration.Triggerを指定しています。\nそのため、設定が変更された際に実行される OnConfigurationChange Hook の中で、RegisterCommand を実行しています。\n プラグインにより登録されたスラッシュコマンド(/poll)が実行された場合の処理は、ExecuteCommand Hookとして実装します。\n// ExecuteCommand parses a given input and creates a poll if the input is correct func (p *MatterpollPlugin) ExecuteCommand(c *plugin.Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) { msg, appErr := p.executeCommand(args) if msg != \u0026#34;\u0026#34; { p.SendEphemeralPost(args.ChannelId, args.UserId, args.RootId, msg) } return \u0026amp;model.CommandResponse{}, appErr } https://github.com/matterpoll/matterpoll/blob/45f095875a98fb1d4f3f166851c86f41b987493e/server/plugin/command.go#L84\nExecuteCommandの第二引数である *model.CommandArgs 型の変数にコマンド実行時の引数や、コマンド実行したユーザーのユーザーID、コマンドが実行されたチャンネルのIDなどの情報が格納されているため、これらの値を使ってスラッシュコマンドが実行された時の処理を実装していきます。\nexecuteCommand メソッドで引数を解析して投票を作成する処理が実行されますが、細かい処理が多いためこれ以上の説明は割愛します。\n投票リクエストを受け付けるための独自エンドポイントの追加 Matterpollにより作成された投稿では、メッセージに埋め込まれたボタンをクリックすることで投票を行うことができます。\nこのボタンはMattermostの Interacitve Message 機能を利用して実装されています (Interactive Messageについては第14日目、第15日目の記事で紹介しています)。Matterpollでは https://github.com/matterpoll/matterpoll/blob/45f095875a98fb1d4f3f166851c86f41b987493e/server/plugin/command.go#L186 のあたりで実装されています。）\nMatterpollが作成する投稿に表示されているボタンは、クリックするとそれぞれ異なるURLへHTTPリクエストが送信されます。このHTTPリクエストをMatterpollのServer側が受け取り、どのユーザーがどの回答に投票したかを解析し、データベースに保存されている投票のデータを更新することで投票処理を実行しています。\nリクエストを受け取るためにはMatterpollプラグイン用のエンドポイントをMattermost上に定義する必要がありますが、これはMattermostプラグインの機能である ServeHTTP Hookにより実現しています。ServeHTTPを実装すると、Mattermostに /plugins/{pluginid} というエンドポイントが生成され、このエンドポイントに送信されたリクエストをプラグインで処理することができるようになります。例えば、Mattermostに https://example.com:8065 というURLでアクセスできるとすると、https://example.com:8065/plugins/com.github.matterpoll.matterpollがMatterpollプラグイン専用のエンドポイントになります。\nMatterpollでは、さらにgorilla/mux を使用して Router を生成し、ServeHTTP の引数をそのままRouterへ流し込むことで、投票の作成/削除/終了や投票の管理など様々なリクエストに対応するエンドポイントを生成して処理を実装しています。\n... // InitAPI initializes the REST API func (p *MatterpollPlugin) InitAPI() *mux.Router { r := mux.NewRouter() r.HandleFunc(\u0026#34;/\u0026#34;, p.handleInfo).Methods(http.MethodGet) r.HandleFunc(\u0026#34;/\u0026#34;+iconFilename, p.handleLogo).Methods(http.MethodGet) apiV1 := r.PathPrefix(\u0026#34;/api/v1\u0026#34;).Subrouter() apiV1.Use(checkAuthenticity) apiV1.HandleFunc(\u0026#34;/configuration\u0026#34;, p.handlePluginConfiguration).Methods(http.MethodGet) apiV1.HandleFunc(\u0026#34;/polls/create\u0026#34;, p.handleSubmitDialogRequest(p.handleCreatePoll)).Methods(http.MethodPost) pollRouter := apiV1.PathPrefix(\u0026#34;/polls/{id:[a-z0-9]+}\u0026#34;).Subrouter() pollRouter.HandleFunc(\u0026#34;/vote/{optionNumber:[0-9]+}\u0026#34;, p.handlePostActionIntegrationRequest(p.handleVote)).Methods(http.MethodPost) pollRouter.HandleFunc(\u0026#34;/votes/reset\u0026#34;, p.handlePostActionIntegrationRequest(p.handleResetVotes)).Methods(http.MethodPost) pollRouter.HandleFunc(\u0026#34;/option/add/request\u0026#34;, p.handlePostActionIntegrationRequest(p.handleAddOption)).Methods(http.MethodPost) pollRouter.HandleFunc(\u0026#34;/option/add\u0026#34;, p.handleSubmitDialogRequest(p.handleAddOptionConfirm)).Methods(http.MethodPost) pollRouter.HandleFunc(\u0026#34;/end\u0026#34;, p.handlePostActionIntegrationRequest(p.handleEndPoll)).Methods(http.MethodPost) pollRouter.HandleFunc(\u0026#34;/end/confirm\u0026#34;, p.handleSubmitDialogRequest(p.handleEndPollConfirm)).Methods(http.MethodPost) pollRouter.HandleFunc(\u0026#34;/delete\u0026#34;, p.handlePostActionIntegrationRequest(p.handleDeletePoll)).Methods(http.MethodPost) pollRouter.HandleFunc(\u0026#34;/delete/confirm\u0026#34;, p.handleSubmitDialogRequest(p.handleDeletePollConfirm)).Methods(http.MethodPost) pollRouter.HandleFunc(\u0026#34;/metadata\u0026#34;, p.handlePollMetadata).Methods(http.MethodGet) return r } func (p *MatterpollPlugin) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request) { p.API.LogDebug(\u0026#34;New request:\u0026#34;, \u0026#34;Host\u0026#34;, r.Host, \u0026#34;RequestURI\u0026#34;, r.RequestURI, \u0026#34;Method\u0026#34;, r.Method) p.router.ServeHTTP(w, r) } ... https://github.com/matterpoll/matterpoll/blob/45f095875a98fb1d4f3f166851c86f41b987493e/server/plugin/api.go#L70\nKey-Valueストア による投票データの管理 ここまで、スラッシュコマンドによる投票の作成、Interactive Messageによる投票処理について説明してきましたが、投票機能を実現するには、これらの投票に関するユーザーの操作を記録しておく必要があります。Mattermostプラグインでは各プラグイン毎に専用のKey Valueストアが用意されており、Matterpollでは投票に関するデータの保存にこのKey-Valueストアを利用しています。\n投票データのKeyは poll_ を接頭辞にもつ投票IDであり、投票IDは投票が作成されるごとに Mattermost本体のmodel.NewIDメソッドを使って乱数を生成しています。Mattermost PluginのKey Valueストアには[]byte型のデータのみ格納できるため、投票状態を持つPoll構造体をJSON形式の []byte に変換した値を格納しています。\n... // Poll stores all needed information for a poll type Poll struct { ID string PostID string `json:\u0026#34;post_id,omitempty\u0026#34;` CreatedAt int64 Creator string Question string AnswerOptions []*AnswerOption Settings Settings } ... // EncodeToByte returns a poll as a byte array func (p *Poll) EncodeToByte() []byte { b, _ := json.Marshal(p) return b } ... https://github.com/matterpoll/matterpoll/blob/45f095875a98fb1d4f3f166851c86f41b987493e/server/poll/poll.go#L23\nKey Valueストアは、単純にKVSet で値の格納、KVGetで値の取得を行うことができますが、Matterpollでは同時に投票操作が行われた場合などに不整合が起きないようにするため、データを格納する際はAtomicオプションを付けて実行しています。\n... // Update updates an existing a poll in the KV Store. func (s *PollStore) Update(prev *poll.Poll, new *poll.Poll) error { opt := model.PluginKVSetOptions{ Atomic: true, OldValue: prev.EncodeToByte(), } ok, err := s.api.KVSetWithOptions(pollPrefix+prev.ID, new.EncodeToByte(), opt) if err != nil { return err } ... } ... また、Matterpollでは、Key Valueストア への処理は全てinterfaceを用意していますが、これはテスト用に mockery でモックオブジェクトを自動で作成するためです。\nさいごに 本日は、Mattermost上で投票を行えるようにするMatterpoll Pluginの概要とServer側の実装について紹介しました。 明日は、Matterpoll PluginのWebapp側の実装について紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day21-plugin-webapp2/","title":"[Mattermost Integrations] Plugin (Webapp 2)","section":"post","date":"2020.12.21","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第21日目の記事です。\n昨日に引き続き、Mattermost上の様々な操作に対応した処理を追加できるMattermost PluginのWebappサイドの機能を紹介していきます。。\nMattermost Pluginについての公式ドキュメントは下記になります。 https://developers.mattermost.com/extend/plugins/overview/\nサンプルコードは下記リポジトリにコミットしています。 https://github.com/kaakaa/mattermost-plugin-api-sample\nWebapp Plugin API registerWebSocketEventHandler registerWebSocketEventHandlerは、Mattermost Serverから送信されるWebSocketイベントを処理するHandlerを登録します。\nregisterWebSocketEventHandlerは2つの引数を取ります。\n event: 処理するWebSocketイベントの種別 handler: WebSocketイベントのデータを引数に取る関数。引数のデータはイベントによって異なります。  ServerプラグインのPublishWebSocketEventと組み合わせて使用すると強力ですが、その辺りの例については22日目以降の記事で紹介します。\nここでは、MattermostデフォルトのWebSocketイベントである投稿が作成された際に送信されるpostedイベントを受信した際に、投稿内容にopen modalという文言が入っていた場合にモーダルを開く例を以下に示します。\n... import {openRootModal, createPluginPost} from \u0026#39;./actions\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // \u0026#39;open modal\u0026#39;を含む投稿を受信するとモーダルを開く  registry.registerWebSocketEventHandler( \u0026#39;posted\u0026#39;, (event) =\u0026gt; { const post = JSON.parse(event.data.post); if (post \u0026amp;\u0026amp; post.message \u0026amp;\u0026amp; post.message.includes(\u0026#39;open modal\u0026#39;)) { store.dispatch(openRootModal()); } } ); } } unregisterWebSocketEventHandler unregisterWebSocketEventHandlerは、registerWebSocketEventHandlerによってWebSocketイベントに対して設定されたHandlerを登録から除外します。\n例は省略します。\nregisterReconnectHandler registerReconnectHandlerは、一度インターネット接続が失われた後に再びMattermostへ接続した際に実行されるHandlerです。\nregisterReconnectHandlerは引数のない関数を引数に取ります。\n handler: Mattermostへ再接続した際に実行される関数  例は省略します。\nunregisterReconnectHandler unregisterReconnectHandlerは、registerReconnectHandlerで登録したHandlerを登録から除外します。引数は取りません。\nこちらも例は省略します。\nregisterMessageWillBePostedHook registerMessageWillBePostedHookは、ユーザーが投稿を送信した際、その投稿がサーバーに送信される前に実行される処理を登録します。\nregisterMessageWillBePostedHookは、引数を1つ取ります。\n hook: ユーザーによって投稿処理が実行された際、その投稿がサーバーに送信される直前に実行される処理  hooksは、引数を一つ取ります。\n post: 投稿の情報  hookの返り値として、投稿情報を持つerrorフィールドを含む値を返却した場合、投稿はrejectされます。投稿情報を持つpostフィールドのを含むオブジェクトを返却した場合は、postフィールドの値で投稿が作成されます。\n忙しいという文言を含む投稿を作成するとrejectされ、帰りたいという文言を含む投稿を作成すると仕事したいに変換される例を以下に示します。\n... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // 投稿がサーバーに送信される前にrejectしたり内容を変換したりする  registry.registerMessageWillBePostedHook( (post) =\u0026gt; { if (post.message \u0026amp;\u0026amp; post.message.includes(\u0026#39;忙しい\u0026#39;)) { return {error: {message: \u0026#39;忙しくはないはずです\u0026#39;}}; } post.message = post.message.replace(/帰りたい/gi, \u0026#39;仕事したい\u0026#39;); return {post: post}; } ); } } registerSlashCommandWillBePostedHook registerSlashCommandWillBePostedHookは、ユーザーがSlash Commandを実行した際、その投稿がサーバーに送信される前に実行される処理を登録します。\nregisterSlashCommandWillBePostedHookは、引数を1つ取ります。\n hook: Slash Commandが実行された際に、その内容がサーバーに送信される直前に実行される処理  hookは、引数を2つ取ります。\n message: 投稿されたメッセージ args: Slash Command実行情報(channel_id, team_id, root_id, parent_id)  /awayをreject、/helpを/shrugに書き換え、/leaveをエラーメッセージなしでrejectするような処理を実行する例を以下に示します。\n... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // Slash Commandがサーバーに送信される前に実行される処理を追加する  registry.registerSlashCommandWillBePostedHook( (message, args) =\u0026gt; { console.log(message); if (message.startsWith(\u0026#39;/away\u0026#39;)) { return {error: {message: \u0026#39;rejected\u0026#39;}}; } if (message.startsWith(\u0026#39;/help\u0026#39;)) { console.log(\u0026#39;help\u0026#39;); return {message: \u0026#39;/shrug converted from help command\u0026#39;, args}; } if (message.startsWith(\u0026#39;/leave\u0026#39;)) { console.log(\u0026#39;leave\u0026#39;); return {}; } } ); } } registerMessageWillFormatHook registerMessageWillFormatHookは、投稿したメッセージがMarkdownテキストとして変換される直前に実行される処理を登録します。\nregisterMessageWillFormatHookは、引数を1つ取ります。\n hook: 投稿がMarkdownテキストとして変換される直前に実行される処理  hookは、引数を2つ取ります。\n post: 変換されていない投稿情報 message: 投稿されたメッセージ（プラグインによって変換されている可能性あり）  hookの返却値として返された文字列が投稿として表示されます。\nregisterMessageWillBePostedHookは、投稿がサーバーに送信される前に投稿内容を編集するものでしたが、このregisterMessageWillFormatHookは、投稿がサーバーに送信・保存された後にレンダリングされる際にメッセージを編集するものだと思われます。\n良い利用方法が思いつかないので例は省略します。\nregisterFilePreviewComponent registerFilePreviewComponentは、ファイルプレビュー用の独自のComponentを登録します。\nregisterFilePreviewComponentは、2つの関数を引数に取ります。\n override: 独自のファイルプレビューComponentを使用するかどうかを決定するための関数。以下の2つを引数に取ります。 component: ファイルプレビュー用のComponent  overrideは、引数を2つ取ります。\n fileInfo: ファイルの情報 post: 投稿の情報  debugで始まるメッセージを持つ投稿の添付ファイルをプレビューする際に、独自のコンポーネントを使用する例を以下に示します。\n... import CustomFilePreview from \u0026#39;./components/custom_file_preview\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // `debug`で始まるメッセージを持つ投稿の添付ファイルを独自コンポーネントでプレビューする  registry.registerFilePreviewComponent( (fileInfo, post) =\u0026gt; { return post.message \u0026amp;\u0026amp; post.message.startsWith(\u0026#39;debug\u0026#39;); }, CustomFilePreview ); } } import React from \u0026#39;react\u0026#39;; import PropTypes from \u0026#39;prop-types\u0026#39;; const {formatText, messageHtmlToComponent} = window.PostUtils; const CustomFilePreviewComponent = ({fileInfo, post}) =\u0026gt; { const formattedText = messageHtmlToComponent(formatText(post.message)); return ( \u0026lt;div style={{backgroundColor: \u0026#39;#ffcccc\u0026#39;}}\u0026gt; {formattedText} \u0026lt;pre\u0026gt; {JSON.stringify(fileInfo, null, 4)} \u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; ) } CustomFilePreviewComponent.propTypes = { fileInfo: PropTypes.object.isRequired, post: PropTypes.object.isRequired, }; export default CustomFilePreviewComponent; registerTranslations registerTranslationsは、プラグイン内で使用しているメッセージの翻訳データを登録します。\nregisterTranslationsは、localeを引数にとり、そのlocaleに対する翻訳データを返す関数を引数に取ります。\nRootModal内のメッセージを日本語に翻訳する例を作ってみましたが、どうやら翻訳が正常に動作していない模様？\n... import ja from \u0026#39;i18n/\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // 翻訳メッセージを登録する  registry.registerTranslations((locale) =\u0026gt; { switch (locale) { case \u0026#39;en\u0026#39;: return en; case \u0026#39;ja\u0026#39;: return ja; } return {}; }); } } { \u0026#34;rootModal.message\u0026#34;: \u0026#34;ルートモーダル\u0026#34; } import React from \u0026#39;react\u0026#39;; import {FormattedMessage} from \u0026#39;react-intl\u0026#39;; const Root = ({visible, close}) =\u0026gt; { if (!visible) { return null; } const style = getStyle(); return ( \u0026lt;div style={style.backdrop} onClick={close} \u0026gt; \u0026lt;div style={style.modal}\u0026gt; \u0026lt;FormattedMessage id=\u0026#39;rootModal.message\u0026#39; defaultMessage=\u0026#39;Root Modal2\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); }; Root.propTypes = { visible: PropTypes.bool.isRequired, close: PropTypes.func.isRequired, }; const getStyle = () =\u0026gt; ({ backdrop: { position: \u0026#39;absolute\u0026#39;, display: \u0026#39;flex\u0026#39;, top: 0, left: 0, right: 0, bottom: 0, backgroundColor: \u0026#39;rgba(0, 0, 0, 0.50)\u0026#39;, zIndex: 2000, alignItems: \u0026#39;center\u0026#39;, justifyContent: \u0026#39;center\u0026#39;, }, modal: { height: \u0026#39;300px\u0026#39;, width: \u0026#39;500px\u0026#39;, padding: \u0026#39;1em\u0026#39;, color: \u0026#39;black\u0026#39;, backgroundColor: \u0026#39;white\u0026#39;, }, }); export default Root; registerAdminConsolePlugin registerAdminConsolePluginは、AdminConsole(システムコンソール?)の内容を上書きするための関数を登録します。\nMattermost内部での利用が主目的であり、ユーザープラグインによる使用は推奨されていないようなので例は省略します。（使い方がよく分からない）\nunregisterAdminConsolePlugin unregisterAdminConsolePluginは、registerAdminConsolePluginで登録した　AdminConsole上書き用関数を登録から除外します。 registerAdminConsolePluginがMattermost内部での利用が主目的のため、こちらも説明、例は省略します。\nregisterAdminConsoleCustomSetting registerAdminConsoleCustomSettingは、プラグイン用の設定画面に独自のコンポーネントを追加します。 このプラグインAPIについては、公式ドキュメントのBest Practicesのページに詳細にまとめられています。\nMattermost Pluginでは、マニフェストファイルのsettings_schemaという項目を指定することで、プラグイン専用の設定項目を作成することができます。\nhttps://developers.mattermost.com/extend/plugins/manifest-reference/\nデフォルトでは、下記のtypeを持つ設定項目を追加することができます。\n \u0026ldquo;bool\u0026rdquo;: ラジオボタン (2値) \u0026ldquo;dropdown\u0026rdquo;: ドロップダウンメニュー \u0026ldquo;generated\u0026rdquo;: 自動生成テキスト \u0026ldquo;radio\u0026rdquo;: ラジオボタン (任意) \u0026ldquo;text\u0026rdquo;: インプットボックス \u0026ldquo;longtext\u0026rdquo;: 複数行テキスト \u0026ldquo;number\u0026rdquo;: 数値入力欄 \u0026ldquo;username\u0026rdquo;:ユーザー名入力欄  デフォルトのtype以外の設定項目を指定したい場合にregisterAdminConsoleCustomSettingを使用します。\nregisterAdminConsoleCustomSettingは、3つの引数を取ります。\n key: 上書きする設定項目のkey。keyは、マニフェストファイルに設定項目ごとに任意で指定する値です。 component: 設定画面に表示されるComponent。 options: 設定項目の表示方法についてのオプション  showTitle: trueを指定した場合、マニフェストファイルのdisplay_nameが設定項目の左側に表示されます    パスワードなどを入力する際に、入力項目をUI上に表示しないような設定項目を追加する例を以下に示します。\n{ ... \u0026#34;settings_schema\u0026#34;: { \u0026#34;settings\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;SampleSetting\u0026#34;, \u0026#34;display_name\u0026#34;: \u0026#34;Sample Setings Value\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;help_text\u0026#34;: \u0026#34;Sample\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;sample\u0026#34; } ] } } ... import CustomSettings from \u0026#39;./components/custom_settings\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // 独自の設定画面項目を追加する  registry.registerAdminConsoleCustomSetting( \u0026#39;SampleSetting\u0026#39;, CustomSettings, {showTitle: true} ); } } import React from \u0026#39;react\u0026#39;; import PropTypes from \u0026#39;prop-types\u0026#39;; const CustomSettingsComponent = ({helpText, id, onChange, value}) =\u0026gt; { const handleChange = (e) =\u0026gt; { onChange(id, e.target.value); } return ( \u0026lt;div style={{backgroundColor: \u0026#39;#ffcccc\u0026#39;}}\u0026gt; \u0026lt;input type={\u0026#39;password\u0026#39;} value={value} onChange={handleChange} /\u0026gt; \u0026lt;pre\u0026gt; {JSON.stringify(helpText.props, null, 4)} \u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; ) } CustomSettingsComponent.propTypes = { helpText: PropTypes.shape ({ props: PropTypes.object, }), id: PropTypes.string, onChange: PropTypes.func, value: PropTypes.any, }; export default CustomSettingsComponent; registerRightHandSidebarComponent registerRightHandSidebarComponentは、Mattermostの右サイドバーに表示する独自のComponentを登録します。\nregisterRightHandSidebarComponentは、2つの引数を取ります。\n component: 右サイドバーに表示されるComponent title: 右サイドバーのタイトル部分に表示されるテキスト  また、registerRightHandSidebarComponentは4つの引数を返却します。\n id: 登録されたComponentのID showRHSPlugin: 登録したComponentを表示するためのアクション hideRHSPlugin: 登録したComponentを非表示にするためのアクション toggleRHSPlugin: 登録したComponentの表示/非表示を切り替えるアクション  登録したComponentは、他のプラグインAPIからshorRHSPlugin、hideRHSPlugin、toggleRHSPluginのアクションを実行することで表示されるようになります。RHSはRightHandSideberの略です。\n右サイドバーに独自のComponentを表示するためのメニューをメインメニューに追加する例を以下に示します。\n... import CustomRightHandSideber from \u0026#39;./components/custom_rhs\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // 右サイドバーに表示される独自Componentを登録する  const {toggleRHSPlugin} = registry.registerRightHandSidebarComponent(CustomRightHandSideber, \u0026#34;Sample RHS\u0026#34;) // 右サイドバーを表示するためのメインメニューを追加する  registry.registerMainMenuAction( \u0026#39;Open RHS\u0026#39;, () =\u0026gt; store.dispatch(toggleRHSPlugin), () =\u0026gt; (\u0026lt;i/\u0026gt;) ); } } import React from \u0026#39;react\u0026#39;; import PropTypes from \u0026#39;prop-types\u0026#39;; const ComponentRightHandSidebar = ({theme}) =\u0026gt; { return ( \u0026lt;div style={{backgroundColor: \u0026#39;#ffcccc\u0026#39;}}\u0026gt; \u0026lt;pre\u0026gt; {JSON.stringify(theme, null, 4)} \u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; ) } ComponentRightHandSidebar.propTypes = { PluggableId: PropTypes.string.isRequired, theme: PropTypes.object.isRequired, }; export default ComponentRightHandSidebar; registerNeedsTeamRoute registerNeedsTeamRouteは、チームごとにプラグイン専用のRouteを追加します。プラグイン専用のエラー画面を作成したい場合などに使用するものだと思います。\nregisterNeedsTeamRouteは、2つの引数を取ります。\n route: ルート文字列 comopnent: routeにアクセスされた際に呼び出されるComponent  http://localhost:8065でMattermostが起動していて、testというチーム名のチームがあり、sample.pluginというプラグインIDを持つプラグインがインストールされており、その中でregisterNeedsTeamRouteの引数としてroute=\u0026quot;/subpath\u0026quot;が指定されていた場合、http://localhost:8065/test/sample.plugin/subpathにアクセスすると、componentに指定したコンポーネントが呼び出されます。\n以下に例を示します。\n... import CustomTeamRoute from \u0026#39;./components/custom_team_route\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // 独自のRouteを追加する  registry.registerNeedsTeamRoute(\u0026#39;/\u0026#39;, CustomTeamRoute) } } import React from \u0026#39;react\u0026#39;; import PropTypes from \u0026#39;prop-types\u0026#39;; import {Switch, Route} from \u0026#39;react-router-dom\u0026#39;; import {getCurrentTeam} from \u0026#39;mattermost-redux/selectors/entities/teams\u0026#39;; import {useSelector} from \u0026#39;react-redux\u0026#39;; import {id} from \u0026#39;src/manifest\u0026#39;; const CustomTeamRouteComponent = () =\u0026gt; { const currentTeam = useSelector(getCurrentTeam); return ( \u0026lt;Switch\u0026gt; \u0026lt;Route path={`/${currentTeam.name}/${id}/error`}\u0026gt; \u0026lt;h3\u0026gt;{\u0026#39;This is error page!\u0026#39;}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href={`/${currentTeam.name}`}\u0026gt;Back to Top\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;Route\u0026gt; \u0026lt;h3\u0026gt;{\u0026#39;404 Not Found\u0026#39;}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href={`/${currentTeam.name}`}\u0026gt;Back to Top\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Switch\u0026gt; ) } CustomTeamRouteComponent.propTypes = { pluggableId: PropTypes.object.isRequired, theme: PropTypes.object.isRequired, }; export default CustomTeamRouteComponent; registerCustomRoute registerCustomRouteは、プラグイン専用のRouteを追加します。\nregisterNeedsTeamRouteは、/${team_name}/${plugin_id}/${route}のようにチームごとにRouteを追加するAPIでしたが、registerCustomRouteは/plug/${plugin_id}/${route}のように、Mattermost全体としてプラグインごとに一つのRouteを追加するAPIです。\n使い方はregisterNeedsTeamRouteとほぼ同じのため、例は省略します。\nその他 Mattermost Plugin Webapp開発中に使えるPlugin開発用の便利機能がいくつかあります。その概要だけ紹介します。\nTheme Mattermost Plugin APIの中でも何度か出てきましたが、Webapp PluginではMattermostのテーマカラーを参照することができます。Mattermostではユーザーごとにテーマカラーを変更することができるため、Webapp PluginでUIの色を指定する場合は、ユーザーごとに見え方が異なることを考慮に入れる必要があります。\n参考: Mattermostのテーマ集 - Qiita\nMattermostで扱われるテーマカラー一覧は以下で紹介されています。\nhttps://developers.mattermost.com/extend/plugins/webapp/reference/#theme\nExported Libraries and Functions Mattermost Webapp PluginはReact.jsを使用して開発しますが、React開発によく使われるいくつかのライブラリはMattermost本体からwindowオブジェクトを介して取得できるようになっています。 取得できるライブラリは以下で紹介されています。\nhttps://developers.mattermost.com/extend/plugins/webapp/reference/#exported-libraries-and-functions\nまた、windowオブジェクトから参照できるライブラリとしてwindow.PostUtilsというのがありますが、これはMattermostフォーマットのテキストを扱うための便利関数を持つオブジェクトです。\n以下のようにすることで、@メンションなどを含むMarkdownテキスト(text)をフォーマットして扱うことができます。\nconst {formatText, messageHtmlToComponent} = window.PostUtils; const text = \u0026#39;...\u0026#39;; const formattedText = messageHtmlToComponent(formatText(text)); https://developers.mattermost.com/extend/plugins/webapp/reference/#post-utils\nRedux Action) Webapp上で投稿やユーザー情報の取得などのMattermostに対する何かしらの処理を実行する場合、mattermost-reduxというReduxライブラリがあります。これはMattermost本体のWebappでも利用されている公式のJavascript APIのような位置付けのものです。\nmattermost-reduxはもちろんMattermost Plugin開発でも使用することができ、下記のページで使い方について紹介されています。\nhttps://developers.mattermost.com/extend/plugins/webapp/actions/\nさいごに 本日は、Mattermost PluginのWebappサイドの実装について紹介しました。 明日からは、Mattermost上で投票機能を使うことができるMatterPollプラグインの実装について紹介していきます。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day20-plugin-webapp1/","title":"[Mattermost Integrations] Plugin (Webapp)","section":"post","date":"2020.12.20","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第20日目の記事です。\n本記事では、Mattermost上の様々な操作に対応した処理を追加できるMattermost PluginのWebappサイドの機能を紹介していきます。\n記事が長いので2日に分けて紹介していきます。それでも長いです。\nMattermost Pluginについての公式ドキュメントは下記になります。 https://developers.mattermost.com/extend/plugins/overview/\nサンプルコードは下記リポジトリにコミットしています。 https://github.com/kaakaa/mattermost-plugin-api-sample\nMattermost Plugin (Webapp) について Mattermost Plugin (Webapp) の本体について紹介します。\nMattermostのWebappサイドのPluginを実装する場合、プラグイン本体はregistryとstoreを引数にとるinitializeメソッドを持つクラスです。registryはMattermost Plugin (Webapp)の機能を呼び出すためのメソッドを持つオブジェクトで、storeはMattermostのデータにアクセスするためのインターフェースです。\n公式ドキュメントでは、以下のようなPluginClassが紹介されています。 https://developers.mattermost.com/extend/plugins/webapp/reference/\nclass PluginClass { /** * initialize is called by the webapp when the plugin is first loaded. * Receives the following: * - registry - an instance of the registry tied to your plugin id * - store - the Redux store of the web app. */ initialize(registry, store) /** * uninitialize is called by the webapp if your plugin is uninstalled */ uninitialize() } このPluginClassのインスタンスをwindowオブジェクトが持つregisterPlugin関数にPlugin IDと共に与えることで、Pluginが有効になります。\nwindow.registerPlugin(\u0026#39;myplugin\u0026#39;, new PluginClass()); Webapp Plugin API registerRootComponent registerRootComponentは、画面全体に表示されるモーダルのReact Componentを登録するAPIです。Componentが登録されると、Componentを一意に識別するためのIDが返却されます。\nここで登録したRoot Componentは、登録するだけで表示されるわけではなく、別のアクションから起動されることで表示されます。\n登録されたComponentで使用できるpropsは特にありません。channel_controller.jsx\n今回は、チャンネルのヘッダー部分にボタンを追加するregisterChannelHeaderButtonAction APIを使ってRoot Componentを表示する例を以下に示します。全てのプログラムを記述すると非常に長くなってしまうため、Reduxによるデータのやりとりなど部分については本記事では割愛します。プログラム全体について知りたい場合は、kaakaa/mattermost-plugin-api-sample また、Mattermost公式チームにより作成されているデモ用プラグインmattermost-plugin-demoの実装も参考になります。\n... import {openRootModal} from \u0026#39;./actions\u0026#39; import reducer from \u0026#39;./reducer\u0026#39;; import Root from \u0026#39;./components/root\u0026#39;; ... export default class Plugin { initialize(registry, store) { // (1) Root Componentの登録  registry.registerRootComponent(Root) // (2) Root Componentを呼び出すアクションの登録  registry.registerChannelHeaderButtonAction( channelHeaderButtonIcon, () =\u0026gt; store.dispatch(openRootModal()), \u0026#34;Open Root modal\u0026#34;,\u0026#34;Open Root modal\u0026#34; ); registry.registerReducer(reducer); } } 上記の例では、(1)でRoot ComponentとなるReact Componentを登録し、(2)でRoot Componentを表示するアクションをチャンネルヘッダーボタンに与えています。(2)のstore.dispatch(openRootModal())がRoot Componentを表示する処理ですが、これはRoot Componentを表示するstateを流す処理になります。\nRoot Componentは以下のようなコードであり、visible = trueとなることで画面に表示されます。\nimport React from \u0026#39;react\u0026#39;; const Root = ({visible, close}) =\u0026gt; { if (!visible) { return null; } const style = getStyle(); return ( \u0026lt;div style={style.backdrop} onClick={close} \u0026gt; \u0026lt;div style={style.modal}\u0026gt; \u0026lt;p\u0026gt;Root modal\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); }; Root.propTypes = { visible: PropTypes.bool.isRequired, close: PropTypes.func.isRequired, }; const getStyle = () =\u0026gt; ({ backdrop: { position: \u0026#39;absolute\u0026#39;, display: \u0026#39;flex\u0026#39;, top: 0, left: 0, right: 0, bottom: 0, backgroundColor: \u0026#39;rgba(0, 0, 0, 0.50)\u0026#39;, zIndex: 2000, alignItems: \u0026#39;center\u0026#39;, justifyContent: \u0026#39;center\u0026#39;, }, modal: { height: \u0026#39;300px\u0026#39;, width: \u0026#39;500px\u0026#39;, padding: \u0026#39;1em\u0026#39;, color: \u0026#39;black\u0026#39;, backgroundColor: \u0026#39;white\u0026#39;, }, }); export default Root; Root ComponentはReact Componentのため、様々な要素を表示することができますが、基本的には通知のために利用し、ユーザーに入力を促すようなユースケースの場合はInteractive Dialogを使用すべきだと思います。\nregisterPopoverUserAttributesComponent registerPopoverUserAttributesComponentは、ユーザーアイコンをクリックすると表示されるpopover内に表示されるComponentを登録します。\nMattermost外からユーザーの情報を取得して表示する際に使用できます。所属の名称がコロコロ変わる会社などでLDAPから所属を引いて表示しておくと便利です。\n登録したComponentは以下のpropsを受け取れます。profile_popover.jsx\n user: popoverで表示しているユーザーのオブジェクト  アクセスできるのはUserモデルで定義されている情報になると思います Userモデルでomitemptyとなっているものは空の場合除外されるため、値がある場合のみアクセスできます   hide: popoverを閉じる関数 status: popoverで表示しているユーザーのstatus  online, offlineなどの単なる文字列のようです    ここでは、固定文字列を表示する例を示します。\n... import UserAttributes from \u0026#39;./components/user_attributes\u0026#39; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // (1) User Popoverに説明を追加するComponentの登録 \tregistry.registerPopoverUserAttributesComponent(UserAttributes) ... } } import React from \u0026#39;react\u0026#39;; import PropTypes from \u0026#39;prop-types\u0026#39;; const UserAttributes = ({user, hide, status}) =\u0026gt; { console.log(\u0026#34;user\u0026#34;, user.id); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;UserId: \u0026#39; + user.id}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } UserAttributes.propTypes = { user: PropTypes.object.isRequired, hide: PropTypes.func.isRequired, status: PropTypes.object.isRequired, }; export default UserAttributes; registerPopoverUserActionsComponent registerPopoverUserActionsComponentは、ユーザーアイコンをクリックすると表示されるpopover内に表示されるComponentを登録します。registerPopoverUserAttributesComponentと似ていますが、表示される位置が異なるだけの違いだと思います。\n登録したComponentは、registerPopoverUserAttributesComponentと同じく以下のpropsを受け取れます。profile_popover.jsx\n user: popoverで表示しているユーザーのオブジェクト hide: popoverを閉じる関数 status: popoverで表示しているユーザーのstatus  registerPopoverUserActionsComponentで、RootComponentを表示する例は以下のようになります。（処理を一部割愛しているため、プログラム全体は https://github.com/kaakaa/mattermost-plugin-api-sample から確認してください）\n... import UserAction from \u0026#39;./components/user_action\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // User Popoverにアクションを追加するComponentの登録 \tregistry.registerPopoverUserActionsComponent(UserAction) ... } } import React from \u0026#39;react\u0026#39;; import PropTypes from \u0026#39;prop-types\u0026#39;; const UserActionComponent = ({openRootModal, user, hide, status}) =\u0026gt; { const onClick = () =\u0026gt; { openRootModal(); hide(); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;User Action \u0026lt;button onClick={onClick}\u0026gt;Action\u0026lt;/button\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ) }; UserActionComponent.PropTypes = { openRootModal: PropTypes.func.isRequired, user: PropTypes.object.isRequired, hide: PropTypes.func.isRequired, status: PropTypes.object.isRequired, }; export default UserActionComponent; registerLeftSidebarHeaderComponent registerLeftSidebarHeaderComponentは、Mattermost画面の左サイドバーに表示するComponentを登録します。\n登録されたComponentで使用できるpropsは特にありません。sidebar.tsx\n常に表示されている部分のため、職場の室温やCO2濃度などを表示するなどの利用方法があるかと思います。\n... import LeftSidebarHeader from \u0026#39;./components/left_sidebar_header\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // User Popoverにアクションを追加するComponentの登録 \tregistry.registerLeftSidebarHeaderComponent(LeftSidebarHeader) ... } } import React from \u0026#39;react\u0026#39;; const LeftSidebarHeaderComponent = () =\u0026gt; { const style = { color: \u0026#39;white\u0026#39;, }; return ( \u0026lt;div style={style}\u0026gt; \u0026lt;p\u0026gt;left sidear header\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } export default LeftSidebarHeader; registerBottomTeamSidebarComponent registerBottomTeamSidebarComponentは、チーム選択サイドバーの下部に表示されるComponentを登録します。１つのチームにしか参加していない場合、チーム選択サイドバー自体が表示されないため、ここで登録したComponentも表示されません。\n登録されたComponentで使用できるpropsは特にありません。legacy_team_sidebar_controller.tsx\n... import BottomTeamSidebar from \u0026#39;./components/bottom_team_sidebar\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // User Popoverにアクションを追加するComponentの登録 \tregistry.registerLeftSidebarHeaderComponent(BottomTeamSidebar) ... } } import React from \u0026#39;react\u0026#39;; const BottomTeamSidebarComponent = () =\u0026gt; ( \u0026lt;\u0026gt; \u0026lt;a href=\u0026#34;https://github.com/\u0026#34;\u0026gt; \u0026lt;i className=\u0026#39;icon fa fa-github\u0026#39; style={{color: \u0026#39;white\u0026#39;}} /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/\u0026gt; ); export default BottomTeamSidebarComponent; registerLinkTooltipComponent registerLinkTooltipComponentは、リンクをhoverした時に表示されるtooltipのComponentを登録します。\n登録したComponentは以下のpropsを受け取れます。link_tooltip.tsx\n href: hoverしているリンクのURL show: tooltipが表示されているかどうかのフラグ  以下の例では単にhoverしているリンクのURLを表示しているだけですが、リンク先から情報を取得して表示するようなこともできます。\n... import LinkTooltip from \u0026#39;./components/link_tooltip\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // User Popoverにアクションを追加するComponentの登録 \tregistry.registerLinkTooltipComponent(LinkTooltip) ... } } import React from \u0026#39;react\u0026#39;; import PropTypes from \u0026#39;prop-types\u0026#39;; const LinkTooltipComponent = ({href}) =\u0026gt; { return ( \u0026lt;\u0026gt; \u0026lt;p style={{ backgroundColor: \u0026#39;white\u0026#39;, color: \u0026#39;black\u0026#39;, padding: \u0026#39;25px\u0026#39;, border: \u0026#39;1px solid red\u0026#39;, }}\u0026gt; {href} \u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; ) } LinkTooltipComponent.propTypes = { href: PropTypes.string.isRequired, }; export default LinkTooltipComponent; registerChannelHeaderButtonAction registerChannelHeaderButtonActionは、registerRootComponentのところでも使用しましたが、チャンネルのヘッダ部分にアクション付きのボタンを登録します。\nregisterChannelHeaderButtonActionは、(icon, action, dropdownText, tooltipText)の４つの引数を取ります。\n icon: ボタンのアイコンを表すReact Element action: ボタンがクリックされたときに実行されるアクション  ボタンが押されたチャンネルの情報を持つchannelと、ボタンを押したユーザーのchannelMemberを引数に取ることができます   dropdown_text: ボタンが複数登録されると一つのアイコンにまとめられ、ドロップダウンメニューから選ぶ形式になりますが、その時のドロップダウンメニューに表示される文字列 tooltip_text: ボタンをhoverした時にtooltipとして表示される文字列  ボタン形式\nドロップダウン形式\nここでは、先ほどのRoot Comopnentを開くButtonと、クリックすると投稿を作成するButtonの2つのButtonを表示する例を示します。投稿の作成はmattermost-reduxを使って投稿を作成するactionsを作成し、Channel Header Buttonのactionから呼び出しています。\nimport {openRootModal, createPluginPost} from \u0026#39;./actions\u0026#39;; import reducer from \u0026#39;./reducer\u0026#39;; import Root from \u0026#39;./components/root\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { // Root Componentの登録  const rootComponentId = registry.registerRootComponent(Root) // Root Componentを呼び出すアクションの登録  registry.registerChannelHeaderButtonAction( () =\u0026gt; (\u0026lt;i className=\u0026#39;icon fa fa-commenting-o\u0026#39; style={{fontSize: \u0026#39;15px\u0026#39;, position: \u0026#39;relative\u0026#39;, top: \u0026#39;-1px\u0026#39;}}/\u0026gt;), () =\u0026gt; store.dispatch(openRootModal()), \u0026#34;Open Root modal\u0026#34;,\u0026#34;Open Root modal\u0026#34; ); ... // 投稿を作成するチャンネルヘッダボタンを登録  registry.registerChannelHeaderButtonAction( () =\u0026gt; (\u0026lt;i className=\u0026#39;icon fa fa-commenting-o\u0026#39; style={{fontSize: \u0026#39;15px\u0026#39;, position: \u0026#39;relative\u0026#39;, top: \u0026#39;-1px\u0026#39;}}/\u0026gt;), (channel, channelMembers) =\u0026gt; store.dispatch(createPluginPost(channel.id)), \u0026#34;Create Sample Post\u0026#34;, \u0026#34;Create Sample Post\u0026#34; ); registry.registerReducer(reducer); } } import {createPost} from \u0026#39;mattermost-redux/actions/posts\u0026#39;; import {getCurrentUserId} from \u0026#39;mattermost-redux/selectors/entities/users\u0026#39;; ... export function createPluginPost(channelId) { return async (dispatch, getState) =\u0026gt; { const state = getState(); const userId = getCurrentUserId(state) const post = { channel_id: channelId, user_id: userId, message: \u0026#34;Post from webapp plugin\u0026#34;, } return await dispatch(createPost(post)); } } registerPostTypeComponent registerPostTypeComponentは、特定のtypeを持つ投稿をレンダリングする時に使用されるComponentを登録します。投稿（Post）に独自のtypeを指定する場合、そのtypeはcustom_で始まる必要があります。\n登録したComponentは以下のpropsを受け取れます。\n post: 投稿の内容 post.go theme: Mattermost画面の配色テーマ constants.jsx  typeにcustom_sample_postを持つ投稿が作成された場合、背景色が赤の投稿をレンダリングする例を以下に示します。今回は、Incoming Webhookで投稿を作成する際のパラメータとしてcustom_sample_postの独自typeを指定しています。\ncurl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#39;{\u0026#34;type\u0026#34;: \u0026#34;custom_sample_post\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Sample Message\u0026#34;, \u0026#34;props\u0026#34;: {\u0026#34;card\u0026#34;: \u0026#34;## Sample\\n* foo\\n* bar\u0026#34;}}\u0026#39; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr ... import CustomPost from \u0026#39;./components/custom_post\u0026#39;; export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // type: custom_sample_post を持つ投稿をレンダリングするComponentの登録 \tregistry.registerPostTypeComponent(\u0026#39;custom_sample_post\u0026#39;, CustomPost); } } ... import React from \u0026#39;react\u0026#39;; import PropTypes from \u0026#39;prop-types\u0026#39;; const {formatText, messageHtmlToComponent} = window.PostUtils; const CustomPostComponent = ({post, theme}) =\u0026gt; { const formattedText = messageHtmlToComponent(formatText(post.message)); console.log(\u0026#39;theme\u0026#39;, theme); return ( \u0026lt;div style={{backgroundColor: \u0026#39;#ffcccc\u0026#39;}}\u0026gt; {formattedText} \u0026lt;pre\u0026gt; {JSON.stringify(post.props, null, 4)} \u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; ) } CustomPostComponent.propTypes = { post: PropTypes.object.isRequired, theme: PropTypes.object.isRequired, }; export default CustomPostComponent; 独自のtypeを指定した投稿を作成した後にPluginを無効にするなど、typeに対応したComponentが登録されていない場合は、通常の投稿と同じようにレンダリングされます。\nregisterPostCardTypeComponent registerPostCardTypeComponentは、特定のtypeを持つ投稿のcard要素をレンダリングする時に使用されるComponentを登録します。投稿（Post）に独自のtypeを指定する場合、そのtypeはcustom_で始まる必要があります。\n登録したComponentは以下のpropsを受け取れます。\n post: 投稿の内容 post.go theme: Mattermost画面の配色テーマ constants.jsx  typeにcustom_sample_cardを持つ投稿が作成された場合、背景色が青のカード要素を持つ投稿をレンダリングする例を以下に示します。custom_sample_cardという独自typeはIncoming Webhookのパラメータとして指定しています。\ncurl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#39;{\u0026#34;type\u0026#34;: \u0026#34;custom_sample_card\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Sample Message\u0026#34;, \u0026#34;props\u0026#34;: {\u0026#34;card\u0026#34;: \u0026#34;## Sample\\n* foo\\n* bar\u0026#34;}}\u0026#39; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr 作成する投稿にprops.cardプロパティがない場合、card要素を表示するためのiボタンが表示されないためカード要素を表示することができません。必ずprops.card要素を指定する必要があります。\n... import CustomCard from \u0026#39;./components/custom_card\u0026#39;; export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // type: custom_sample_card を持つ投稿をレンダリングするComponentの登録  registry.registerPostCardTypeComponent(\u0026#39;custom_sample_card\u0026#39;, CustomCard); } } ... import React from \u0026#39;react\u0026#39;; import PropTypes from \u0026#39;prop-types\u0026#39;; const {formatText, messageHtmlToComponent} = window.PostUtils; const CustomCardComponent = ({post, theme}) =\u0026gt; { const formattedText = messageHtmlToComponent(formatText(post.message)); console.log(\u0026#39;theme\u0026#39;, theme); return ( \u0026lt;div style={{backgroundColor: \u0026#39;#ccccff\u0026#39;}}\u0026gt; {formattedText} \u0026lt;pre\u0026gt; {JSON.stringify(post.props, null, 4)} \u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; ) } CustomCardComponent.propTypes = { post: PropTypes.object.isRequired, theme: PropTypes.object.isRequired, }; export default CustomCardComponent; 独自のtypeを指定した投稿を作成した後にPluginを無効にするなど、typeに対応したComponentが登録されていない場合は、通常の投稿と同じようにレンダリングされます。\nregisterPostWillRenderEmbedComponent  registerPostWillRenderEmbedComponentは、投稿内で最初に出現するURLの内容をプレビュー表示する部分のコンポーネントを登録します。OpenGraphの情報を表示するアレです。\nregisterPostWillRenderEmbedComponentは3つの引数を取ります。\n match: ここで指定したコンポーネントでプレビュー要素をレンダリングするかどうかを決定するための関数。プレビュー表示対象のURLや種別を使い、trueを返すとここで指定したコンポーネントを使用する。 component: プレビュー要素をレンダリングするコンポーネント toggleable: プレビュー要素を折り畳み可能にするかどうかのフラグ  また、登録したComponentは以下のpropsを受け取れます。\n embed: 投稿の内容 post.go  type: urlから取得できるプレビューの種別。opengraphやimageなどの値が入る url: 投稿ないで最初に出現するURL data: urlから取得できるプレビュー内容に関する情報が格納されるらしいが、試している中では値が取得できなかった    https://github.com/mattermostで始まるURLが指定された場合に、青い背景色のプレビューをレンダリングする例を以下に示します。\n... import CustomEmbed from \u0026#39;./components/custom_embed\u0026#39;; export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // 投稿に含まれるURLのプレビューをレンダリングするComponentの登録  registry.registerPostWillRenderEmbedComponent( (embed) =\u0026gt; embed.url \u0026amp;\u0026amp; embed.url.startsWith(`https://github.com/mattermost/`), CustomEmbed, true ); } } ... import React from \u0026#39;react\u0026#39;; import PropTypes from \u0026#39;prop-types\u0026#39;; const CustomEmbedComponent = ({embed}) =\u0026gt; { const {type, url, data} = embed; return ( \u0026lt;div style={{backgroundColor: \u0026#39;#ccffcc\u0026#39;}}\u0026gt; \u0026lt;p\u0026gt;{type}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{url}\u0026lt;/p\u0026gt; \u0026lt;pre\u0026gt; {JSON.stringify(data, null, 4)} \u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; ) } CustomEmbedComponent.propTypes = { embed: PropTypes.shape ({ type: PropTypes.string.isRequired, url: PropTypes.string.isRequired, data: PropTypes.object.isRequired, }) }; export default CustomEmbedComponent; 以下のリポジトリのoEmbed-pluginブランチに、Mattermost公式チームによるregisterPostWillRenderEmbedComponentを使用したプラグインの実装が残っています。（作りかけで止まっているようですが） https://github.com/mattermost/mattermost-plugin-oembed/tree/oEmbed-plugin\nregisterMainMenuAction registerMainMenuActionは、Mattermostのメインメニュー部分に独自のメニューを追加します。\nregisterPostWillRenderEmbedComponentは3つの引数を取ります。\n text: メインメニューに表示される文字列かReact Elementを指定します action: メインメニューが選択された際に実行されるアクションを登録します mobileIcon: モバイルアプリで表示されるアイコンを登録します（が、モバイルアプリだとメインメニュー表示されない\u0026hellip;?）  モーダルを開くアクションが登録されたメインメニューを追加する例を以下に示します。\n... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // メインメニューを追加する  registry.registerMainMenuAction( \u0026#39;Sample Main Menu\u0026#39;, () =\u0026gt; store.dispatch(openRootModal()), () =\u0026gt; (\u0026lt;i className=\u0026#39;icon fa fa-plug\u0026#39; style={{fontSize: \u0026#39;15px\u0026#39;, position: \u0026#39;relative\u0026#39;, top: \u0026#39;-1px\u0026#39;}}/\u0026gt;) ); } } ... registerChannelHeaderMenuAction registerChannelHeaderMenuActionは、チャンネル名の部分をクリックした時に表示されるメニューに独自のメニューを追加します。\nregisterPostWillRenderEmbedComponentは2つの引数を取ります。\n text: メニューに表示される文字列かReact Element action: メニューが選択された際に実行されるアクション。実行されたチャンネルのチャンネルIDが渡されます。  モーダルを開くアクションが登録されたチャンネルヘッダーメニューを追加する例を以下に示します。\n... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // チャンネル名をクリックした際に表示されるメニューに独自メニューを追加する  registry.registerChannelHeaderMenuAction( \u0026lt;i className=\u0026#39;icon fa fa-plug\u0026#39; style={{fontSize: \u0026#39;15px\u0026#39;, position: \u0026#39;relative\u0026#39;, top: \u0026#39;-1px\u0026#39;}}\u0026gt;{\u0026#39;Sample Menu\u0026#39;}\u0026lt;/i\u0026gt;, (chnnelId) =\u0026gt; store.dispatch(openRootModal()) ); } } ... registerPostDropdownMenuAction registerPostDropdownMenuActionは、投稿に対するドロップダウンメニューに独自のメニューを追加します。\nregisterPostDropdownMenuActionは3つの引数を取ります。\n text: メニューに表示される文字列かReact Element action: メニューが選択された際に実行されるアクション。メニューが実行された投稿のPostIDが渡されます。 filter: メニューを表示するかどうかを決定する関数。実行された投稿のPostIDが渡されます。  モーダルを開くアクションが登録されたドロップダウンメニューを追加する例を以下に示します。\n... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // 投稿に対するドロップダウンメニューに独自メニューを追加する  registry.registerPostDropdownMenuAction( \u0026lt;i className=\u0026#39;icon fa fa-plug\u0026#39; style={{fontSize: \u0026#39;15px\u0026#39;}}\u0026gt;{\u0026#39;Sample Post Menu\u0026#39;}\u0026lt;/i\u0026gt;, (postId) =\u0026gt; store.dispatch(openRootModal()), (postId) =\u0026gt; { return true; } ); } } ... registerPostDropdownSubMenuAction registerPostDropdownSubMenuActionは、投稿に対するドロップダウンメニューにサブメニュー付きの独自のメニューを追加します。\nまず、registerPostDropdownSubMenuActionは3つの引数を取ります。\n text: メニューに表示される文字列かReact Element action: メニューが選択された際に実行されるアクション。実行された投稿のPostIDが渡されます。(しかし、クリックしても何も実行されないようです) filter: メニューを表示するかどうかを決定する関数。メニューが実行された投稿のPostIDが渡されます。  registerPostDropdownSubMenuActionは、返り値として登録したアクションのIDと、サブメニューを登録するための関数を返します。ここで返される関数を使ってサブメニューを登録していきますが、この関数は2つの引数を取ります。\n text: メニューに表示される文字列かReact Element action: メニューが選択された際に実行されるアクション。メニューが実行された投稿のPostIDが渡されます。  （サブメニューを登録する関数の第3引数としてfilterとなる関数を渡しても、特に効果はないようです）\nモーダルを開くアクションが登録されたドロップダウンサブメニューを追加する例を以下に示します。\n... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // 投稿に対するサブメニュー付きのドロップダウンメニューを追加する  const {id, rootRegisterMenuItem} = registry.registerPostDropdownSubMenuAction( \u0026lt;i className=\u0026#39;icon fa fa-plug\u0026#39; style={{fontSize: \u0026#39;15px\u0026#39;}}\u0026gt;{\u0026#39;Sample SubMenu\u0026#39;}\u0026lt;/i\u0026gt;, (postId) =\u0026gt; store.dispatch(openRootModal()), // 実行されない  (postId) =\u0026gt; { return true; } ); rootRegisterMenuItem( \u0026lt;i className=\u0026#39;icon fa fa-plug\u0026#39; style={{fontSize: \u0026#39;15px\u0026#39;}}\u0026gt;{\u0026#39;SubMenu 1\u0026#39;}\u0026lt;/i\u0026gt;, (postId) =\u0026gt; store.dispatch(openRootModal()), ); rootRegisterMenuItem( \u0026lt;i className=\u0026#39;icon fa fa-plug\u0026#39; style={{fontSize: \u0026#39;15px\u0026#39;}}\u0026gt;{\u0026#39;SubMenu 2\u0026#39;}\u0026lt;/i\u0026gt;, (postId) =\u0026gt; store.dispatch(openRootModal()) ); } } ... registerPostDropdownMenuComponent registerPostDropdownMenuComponentは、投稿に対するドロップダウンメニューに独自のコンポーネントを追加します。\n登録したComponentは以下のpropsを受け取れます。\n postId: アクションが実行された投稿のPostID theme: Mattermost画面の配色テーマ constants.jsx dispatch: actionをdispatchするための関数  モーダルを開くアクションが登録されたドロップダウンメニューを追加する例を以下に示します。\n... import CustomPostDropdown from \u0026#39;./components/custom_post_dropdown\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // 投稿に対するドロップダウンメニューにコンポーネントを登録する  registry.registerPostDropdownMenuComponent(CustomPostDropdown); ... } } import React from \u0026#39;react\u0026#39;; import PropTypes from \u0026#39;prop-types\u0026#39;; import {openRootModal} from \u0026#39;actions\u0026#39;; const CustomPostDropdownComponent = ({postId, theme, dispatch}) =\u0026gt; { return ( \u0026lt;div style={{backgroundColor: \u0026#39;#ffcccc\u0026#39;}} onClick={() =\u0026gt; dispatch(openRootModal())} \u0026gt; {postId} \u0026lt;/div\u0026gt; ) } CustomPostDropdownComponent.propTypes = { postId: PropTypes.string.isRequired, theme: PropTypes.object.isRequired, dispatch: PropTypes.func.isRequired, }; export default CustomPostDropdownComponent; registerFileUploadMethod registerFileUploadMethodは、ファイルアップロードメニューに独自のメニューを追加します。\nregisterFileUploadMethodは3つの引数を取ります。(公式ドキュメントは引数の順序が違っているので注意)\n icon: JSX形式のメニューに表示されるアイコン action: メニューが選択された際に実行されるアクション。ファイルをアップロードするための関数が渡されます。 text: メニューに表示されるテキスト  メニューが選択されると、テキストファイルが2つアップロードされる例を以下に示します。\n... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // ファイルアップロードメニューを追加する  registry.registerFileUploadMethod( \u0026lt;i className=\u0026#39;icon fa fa-pencil-square-o\u0026#39; style={{fontSize: \u0026#39;15px\u0026#39;}}/\u0026gt;, (upload) =\u0026gt; upload([ new File([\u0026#34;test1\u0026#34;], \u0026#34;sample1.txt\u0026#34;), new File([\u0026#34;test2\u0026#34;], \u0026#39;sample2.txt\u0026#39;) ]), \u0026#39;Sample File Upload\u0026#39; ); } } ... registerFilesWillUploadHook registerFilesWillUploadHookは、ファイルアップロード時に実行される関数を登録できます。\nregisterFilesWillUploadHookは2つの引数を取る関数を引数に取ります。\n files: アップロードしようとしているファイルの配列 upload: ファイルをアップロードするための関数  この関数を使わなくとも、アップロードしたいファイルを返却値として指定することでファイルをアップロードできます    返り値として以下のフィールドを持つオブジェクトを返却する必要があります。\n message: 処理結果として画面に表示されるメッセージを指定します files: 処理結果としてアップロードするファイルを配列として指定します。nullを指定するとアップロードをrejectします。  2つ以上のファイルを同時にアップロードしようとするとアップロードをrejectする例を以下に示します。\n... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // ファイルアップロード時の処理を登録する  registry.registerFilesWillUploadHook((files, upload) =\u0026gt; { let msg = \u0026#39;\u0026#39;; if (files.length \u0026gt;= 2 ) { files = null; msg = \u0026#39;Must upload one by one.\u0026#39;; } return { message: msg, files: files, }; }); } } ... unregisterComponent unregisterComponentは、プラグインとして登録したComponentやHookを登録から除外します。\nregisterLeftSidebarHeaderComponentによって登録したコンポーネントを登録から除外するメインメニューの例を以下に示します。\n... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // 左サイドバーの上部に表示されるComponentの登録  const leftSidebarHeaderComponentId = registry.registerLeftSidebarHeaderComponent(LeftSidebarHeader); ... // プラグインによって登録されたコンポーネントを登録から除外する  registry.registerMainMenuAction( \u0026#39;Unregister LeftSideberHeader\u0026#39;, () =\u0026gt; registry.unregisterComponent(leftSidebarHeaderComponentId), () =\u0026gt; (\u0026lt;i className=\u0026#39;icon fa fa-plug\u0026#39; style={{fontSize: \u0026#39;15px\u0026#39;, position: \u0026#39;relative\u0026#39;, top: \u0026#39;-1px\u0026#39;}}/\u0026gt;) ); } } ... unregisterPostTypeComponent unregisterPostTypeComponentは、unregisterComponentと同様、独自のPostTypeに対して設定したComponentを登録から除外します。\n例は省略します。\nregisterReducer registerReducerは、プラグイン内で使用するReducerを登録します。\nここまでに紹介してきた例では、モーダルを開くアクションが実行された場合などにregisterReducerによって登録されたreducerを利用しています。\n... import reducer from \u0026#39;./reducer\u0026#39;; ... export default class Plugin { // eslint-disable-next-line no-unused-vars  initialize(registry, store) { ... // Reducerを登録する  registry.registerReducer(reducer); } } import {combineReducers} from \u0026#39;redux\u0026#39;; import {OPEN_ROOT_MODAL, CLOSE_ROOT_MODAL} from \u0026#39;./action_types\u0026#39;; const rootModalVisible = (state = false, action) =\u0026gt; { switch (action.type) { case OPEN_ROOT_MODAL: return true; case CLOSE_ROOT_MODAL: return false; default: return state; } }; export default combineReducers({ rootModalVisible, }); import {id as pluginId} from \u0026#39;./manifest\u0026#39;; export const OPEN_ROOT_MODAL = pluginId + \u0026#39;_open_root_modal\u0026#39;; export const CLOSE_ROOT_MODAL = pluginId + \u0026#39;_close_root_modal\u0026#39;; さいごに 本日は、Mattermost PluginのWebappサイドの実装について紹介しました。 明日は、残りのWebappサイドのAPIを紹介していきます。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.30/","title":"Mattermost5.30の新機能","section":"post","date":"2020.12.20","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2020/12/18にMattermost v5.30.0がリリースされました。また、現在v5.30.1もリリースされています。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。（なので、Enterprise版限定の機能などについてはリリースノート書いてあることの紹介程度となっています）\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost release v5.30 is now available Mattermost Changelog — Mattermost 5.30 documentation   Mattermostで投票機能 Mattermost上で投票機能を実現するMatterpoll Pluginが、公式のプラグインマーケットプレースからインストールできるようになりました。\nMatterpollプラグインについては、過去に自分が作り始めたものがプラグイン形式に変わって開発が進められているものです。 Mattermostで投票機能もどき - Qiita\nMatterpollプラグインについては、Mattermost Integrations Advent Calendar 2020 - Qiitaの第22日目以降の記事で内部構造等を紹介します。\n(E20) Mattermostでインシデント管理 Mattermost上でインシデントの管理を行うことができる機能が追加されたようです。 元々、Incident Management PluginとMattermost Channel Export Pluginとして公開されていたプラグインをMattermost本体に内蔵したということのようです。（E20版限定の機能として紹介されていますが、Team Editionでも使用できている気がします）\nインシデント管理方法 Incident Management Pluginが有効になっている場合、メインメニュー \u0026gt; Playbook \u0026amp; Incidentsからインシデント管理画面を表示できます。 インシデント管理画面では、インシデント対応の手順をまとめたPlaybookと、インシデント一覧を管理することができます。 Playbookタブで+ New PlaybookをクリックするとPlaybookの作成画面が表示され、インシデント対応プロセスとしてステージと各ステージにおけるタスクを入力することができます。\nまた、各タスクにはSlash Commandを指定することができるようですが、これは、例えばMattermost Jira Pluginのコマンドを指定してタスク完了時にJiraなどの外部サービスへの通知が必要なことを表示するための機能ではないかと思われます。Playbook内のタスクに存在しないSlash Commandを指定しても、新たなSlash Commandが作成されるわけではなさそうです。\nここで作成したPlaybookは、チャンネルヘッダーボタンのIncidentsメニューなどから+ Start Incidentを実行した際に、インシデント対応プロセスとして指定することができます。\nインシデントが作成されると、インシデント対応専用のチャンネルが作られ、右サイドバーではインシデントの進行状況を確認することができます。対応担当を指定したり、完了したタスクをクローズするなどしてインシデントを進めていくことになります。\nタスク完了後はMattermost Channel Export Pluginで、チャンネル内でのやりとりをCSV形式でエクスポートなどもできるようです。\nIncident Managementプラグインには、インシデント管理用のSlash Commandなどもあるようで、詳しくは下記の公式ドキュメントを参照ください。\nhttps://docs.mattermost.com/administration/devops-command-center.html\n(E20) Microsoft Teams会議プラグイン (Beta版) Mattermostのチャンネルヘッダーボタンから、Microsoft Teamsの会議を作成し、会議へ参加するためのボタンを含む投稿をMattermostチャンネルに作成するプラグインのようです。こちらは有償版Mattermost限定の昨日のようです。\n（※画像は公式ブログから）\n(E20) 新たに追加された管理者ロールの権限が設定可能に Mattermos v5.28で、システム管理者の一部の権限のみを持つSystem Manager、User Manager、Read-only Adminという役割が新たに追加されましたが、今回のv5.30から、これらの役割の権限を任意に設定できるようになりました。\n（※画像は公式ブログから）\nその他のトピック Mattermost Cloud 今までオンプレミス専門でやってきたMattermostのクラウドサービスが始まりました。\nIntroducing Mattermost Cloud - Open Source, Private Cloud Messaging\nユーザーとワークスペースを作成すると専用のMattermostのインスタンスが作成され、自分が作成したワークスペース内ならシステムコンソールにも普通にアクセスできるようです。\n10ユーザーまでは無償で利用でき、無償版でもセルフホスティング版の有償版相当の機能が使え流ように見えます。（システムコンソールで有償版の設定にもアクセスできる）\nhttps://mattermost.com/pricing-cloud/\nSlackのようにメッセージ履歴や統合機能数などでの制限ではなく、ユーザー数での制限のみのため、その辺りが一つの差異化ポイントのようです。\nリリースサイクルの見直し これまで、Mattermostは偶数バージョンは新機能を追加、奇数バージョンはバグ修正などの品質改善のみを追加、という\u0026quot;tick-tock\u0026quot;なリリースサイクルを採用していました。\nしかし、前記のMattermost Cloudの開始などを受け、リリースサイクルを早めるべきとの結論に至ったようで、2021/01/16リリースのv5.31からは各バージョンでの新機能の追加が行われるようになります。\nMattermost moves away from alternating release cycle\nWhat Matters - A Podcast from Mattermost 少し前になりますが、Mattermost主催のPodcastの配信が始まっています。 Mattermost社のメンバーや、外部からエンジニアを迎えて技術的な話や開発に関するトークなどを不定期で配信しているようです。\n https://mattermost.libsyn.com/ Announcing What Matters: A podcast from the folks at Mattermost  Mattermost Dev Sneak Peek (YouTube) 最近、MattermostのYouTubeチャンネルでDev Sneak Peekとして、開発中の新機能の紹介動画をよくアップロードしているようです。\n https://www.youtube.com/channel/UCNR05H72hi692y01bWaFXNA  Mattermost Integrations Advent Calendar Mattermost Integrationsに関する記事をQiita Advent Calendarに書いています。\nMattermost Integrations Advent Calendar 2020 - Qiita\nおわりに 次のv5.31のリリースは2021/01/15(Fri)を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day19-plugin-server-api/","title":"[Mattermost Integrations] Plugin (Server API)","section":"post","date":"2020.12.19","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第19日目の記事です。\n本記事では、Mattermost Server Pluginの開発に利用できるAPIについて紹介します。\nMattermost Pluginについての公式ドキュメントは下記になります。 https://developers.mattermost.com/extend/plugins/overview/\nMattermost Plugin API Mattermost Server Pluginの開発に利用できるAPIの一覧は下記にあります。\nhttps://developers.mattermost.com/extend/plugins/server/reference/\nユーザーやチャンネル、投稿などの操作についてはREST APIとほぼ同様の機能を有しています。数が多いため全ては紹介しませんが、Server Plugin特有の処理に関するAPIを紹介していこうと思います。\nGetConfig GetConfigは、Mattermost Serverのシステムコンソールの設定情報を取得します。\nsiteURL := p.API.GetConfig().ServiceSettings.SiteURL p.API.GetConfig()下記のOnConfigurationChange内で実行し、Plugin構造体のフィールドとして保持しておくのが良いそうです。 https://github.com/mattermost/mattermost-plugin-starter-template/blob/master/server/configuration.go\nOpenInteractiveDialog OpenInteractiveDialogは、第16日目の記事でも紹介したInteractive DialogをPluginから開くためのAPIです。Interactive Dialogを開くにはTriggerIdというパラメータが必須であり、TriggerIdはSlash Command実行時、もしくはInteractive Message Button/Menu実行時に送信されるリクエストからしか取得できません。\n以下の例はSlash Command実行時にInteractive Dialogを開き、入力された情報を整形して投稿を作成するコードです。\nfunc (p *SamplePlugin) ExecuteCommand(c *plugin.Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) { appErr := p.API.OpenInteractiveDialog(model.OpenDialogRequest{ TriggerId: args.TriggerId, URL: fmt.Sprintf(\u0026#34;%s/plugins/com.github.kaakaa.mattermost-plugin-starter-template/callback\u0026#34;, *p.API.GetConfig().ServiceSettings.SiteURL), Dialog: model.Dialog{ Title: \u0026#34;Sample Plugin Dialog\u0026#34;, SubmitLabel: \u0026#34;Submit\u0026#34;, Elements: []model.DialogElement{ { DisplayName: \u0026#34;タイトル\u0026#34;, Name: \u0026#34;title\u0026#34;, Placeholder: \u0026#34;Title\u0026#34;, Type: \u0026#34;text\u0026#34;, }, { DisplayName: \u0026#34;Snippet\u0026#34;, Name: \u0026#34;snippet\u0026#34;, Type: \u0026#34;textarea\u0026#34;, }, }, }, }) if appErr != nil { return nil, appErr } return \u0026amp;model.CommandResponse{}, nil } Interactive Dialogのリクエスト送信先を\nURL: fmt.Sprintf(\u0026#34;%s/plugins/com.github.kaakaa.mattermost-plugin-starter-template/callback\u0026#34;, *p.API.GetConfig().ServiceSettings.SiteURL), のようにすることで、Pluginから開いたInteractive DialogのリクエストをPluginで処理することもできます。このリクエストの受信先として、Mattermost Plugin Server HookであるServeHTTPを使って/callbackのエンドポイントを受け取る処理を追加します。\nfunc (p *SamplePlugin) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request) { if r.URL.Path == \u0026#34;/callback\u0026#34; { defer r.Body.Close() request := model.SubmitDialogRequestFromJson(r.Body) t := request.Submission[\u0026#34;title\u0026#34;] s := request.Submission[\u0026#34;snippet\u0026#34;] p.API.CreatePost(\u0026amp;model.Post{ UserId: request.UserId, ChannelId: request.ChannelId, Message: fmt.Sprintf(\u0026#34;## %s\\n\\n```\\n%s\\n```\u0026#34;, t, s), }) return } fmt.Fprint(w, \u0026#34;Hello, world!\u0026#34;) } このようにすることで、Interactive Dialogの起動からリクエストの処理までをPluginだけで完結させることができます。\nPublishWebSocketEvent PublishWebSocketEventは、プラグイン独自のWebSoketイベントを送信するAPIです。\nPublishWebSocketEventは、3つの引数を取ります。\n event string: WebSocketイベント名を指定します。実際に送信されるWebSocketイベントには接頭辞としてcustom_\u0026lt;PluginID\u0026gt;_が付与されます payload map[string]interface{}: 送信されるデータの内容を指定します broadcast *model.WebsocketBroadcast: WebSocketを送信する対象を指定します  model.WebsocketBroadcastで、ユーザー、チャンネル、チームを指定したり、受信対象から外すユーザーを指定したりできます    Webapp Plugin APIのregisterWebSocketEventHandlerと組み合わせることで、プラグイン内でWebSocketイベントに関する処理を完結させることができます。 この辺りの使用例は第22日目以降の記事で紹介する予定です。\nSendMail SendMailは、Mattermost PluginからHTMLメールを送信するAPIです。システムコンソールでSMTPの設定が完了している必要があります。\nSlash Commandを実行した際にメールを送信する例は以下のようになります。\nfunc (p *SamplePlugin) ExecuteCommand(c *plugin.Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) { appErr := p.API.SendMail( \u0026#34;test@example.com\u0026#34;, \u0026#34;Sample Title\u0026#34;, \u0026#34;\u0026lt;h1\u0026gt;Mail from plugin\u0026lt;/h1\u0026gt;\u0026lt;div\u0026gt;\u0026lt;p\u0026gt;Sample Mail\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;) if appErr != nil { return nil, appErr } return \u0026amp;model.CommandResponse{}, nil } KVGet / KVSet KVGet, KVSetは、プラグインごとに割り当てられたKey Valueストアから値を取得、または値を設定するAPIです。Key Valueストアには[]byte型のデータを格納できるため、格納用データの構造体を作成し、json.Marshalで[]byte型のデータ化したものを出し入れするのが主な使い方になるのではないかと思います。\nKey Valueストアを使用してカウンターを実装した例が以下になります。\ntype counter struct { Count int `json:\u0026#34;count\u0026#34;` CreatedAt string `json:\u0026#34;created_at\u0026#34;` } func (p *SamplePlugin) ExecuteCommand(c *plugin.Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) { // read data \tb, appErr := p.API.KVGet(\u0026#34;counter\u0026#34;) if appErr != nil { return nil, appErr } var ct counter if b == nil { // init if data is not found \tct = counter{ Count: 0, CreatedAt: time.Now().Format(time.RFC3339), } } else { if err := json.Unmarshal(b, \u0026amp;ct); err != nil { return nil, model.NewAppError(\u0026#34;where\u0026#34;, \u0026#34;id\u0026#34;, nil, err.Error(), http.StatusInternalServerError) } } // count up \tct.Count = ct.Count + 1 b, err := json.Marshal(ct) if err != nil { return nil, model.NewAppError(\u0026#34;where\u0026#34;, \u0026#34;id\u0026#34;, nil, err.Error(), http.StatusInternalServerError) } // set data \tif appErr := p.API.KVSet(\u0026#34;counter\u0026#34;, b); appErr != nil { return nil, appErr } return \u0026amp;model.CommandResponse{Text: fmt.Sprintf(\u0026#34;counter: %d\u0026#34;, ct.Count)}, nil } Key Valueストアを操作するAPIはKVGet, KVSet以外にも数多くあります。データを削除するKVDeleteや、プラグイン内で保存済みのデータのkeyを取得するKVList、期間を指定して値を格納できるKVSetWithExpiryなどがあります。また、同時にKVSetが実行された場合に不整合が起きないようにするため、AtomicなKey Valueストアの操作を強制するためのKVCompareAndSetなどもあります。\nAPIの一覧については公式ドキュメントを参照してください。 https://developers.mattermost.com/extend/plugins/server/reference/\nHelpers Mattermost Plugin APIは数多くあるため、Mattermostに対するほとんどの操作を実行することはできますが、より簡単にPlugin APIを実行するためのHelper関数がいくつか存在します。\nここでは、Helper関数のうち一部を紹介します。\nHelper関数の一覧は下記の公式ドキュメントにあります。 https://developers.mattermost.com/extend/plugins/server/reference/#Helpers\nKVGetJSON / KVSetJSON 先ほどのKVGet、KVSetのコードでは、構造体を[]byteに変換するためにKVSetを呼ぶ前にjson.Marshalを、KVGetを呼んだ後にjson.Unmarshalを呼んでいましたが、KVGetJSON、KVSetJSONを使用することで、その必要がなくなります。\nそのため、先ほどの処理を多少すっきりと書くことができます。\ntype counter struct { Count int `json:\u0026#34;count\u0026#34;` CreatedAt string `json:\u0026#34;created_at\u0026#34;` } func (p *SamplePlugin) ExecuteCommand(c *plugin.Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) { // read data \tvar ct counter exists, err := p.Helpers.KVGetJSON(\u0026#34;counter\u0026#34;, \u0026amp;ct) if err != nil { return nil, model.NewAppError(\u0026#34;where\u0026#34;, \u0026#34;id\u0026#34;, nil, err.Error(), http.StatusInternalServerError) } if !exists { ct = counter{ Count: 0, CreatedAt: time.Now().Format(time.RFC3339), } } // count up \tct.Count = ct.Count + 1 // set data \tif appErr := p.Helpers.KVSetJSON(\u0026#34;counter\u0026#34;, ct); appErr != nil { return nil, model.NewAppError(\u0026#34;where\u0026#34;, \u0026#34;id\u0026#34;, nil, err.Error(), http.StatusInternalServerError) } return \u0026amp;model.CommandResponse{Text: fmt.Sprintf(\u0026#34;counter: %d\u0026#34;, ct.Count)}, nil } CheckRequiredServerConfiguration CheckRequiredServerConfigurationは、システムコンソールの設定をチェックするためのHelper関数です。\n引数に指定したmodel.Configと同じ設定になっているかをチェックし、異なる設定だった場合はfalseを返します。\nシステムコンソール \u0026gt; Botアカウント \u0026gt; Botアカウントの作成を有効にするの設定が有効になっていない場合にプラグインの起動を停止するような例は以下のようになります。\nfunc toPtr(v bool) *bool { return \u0026amp;v } func (p *SamplePlugin) OnActivate() error { b, err := p.Helpers.CheckRequiredServerConfiguration(\u0026amp;model.Config{ ServiceSettings: model.ServiceSettings{ EnableBotAccountCreation: toPtr(true), }, }) if err != nil { return err } if !b { return errors.New(\u0026#34;EnableBotAccountCreation must be true.\u0026#34;) } ... プラグイン起動時、サーバーのログには以下のようなログが出力されます。\n2020-12-13T00:16:01.409+0900 error mlog/log.go:229 Unable to restart plugin on upgrade. {\u0026#34;path\u0026#34;: \u0026#34;/api/v4/plugins\u0026#34;, \u0026#34;request_id\u0026#34;: \u0026#34;u31bzwuyhbyibratzznjxgxzrr\u0026#34;, \u0026#34;ip_addr\u0026#34;: \u0026#34;::1\u0026#34;, \u0026#34;user_id\u0026#34;: \u0026#34;87x93uo8pfnzdro9ktcmobpa1r\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34;, \u0026#34;err_where\u0026#34;: \u0026#34;installExtractedPlugin\u0026#34;, \u0026#34;http_code\u0026#34;: 500, \u0026#34;err_details\u0026#34;: \u0026#34;EnableBotAccountCreation must be true.\u0026#34;} さいごに 本日は、Mattermost PluginのServer APIについて紹介しました。 明日からは、Mattermost PluginのWebappサイドの実装について紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day18-plugin-server-hooks/","title":"[Mattermost Integrations] Plugin (Server hooks)","section":"post","date":"2020.12.18","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第18日目の記事です。\n本記事では、Mattermost上の様々な操作に対応した処理を追加できるMattermost PluginのServerサイドの機能であるServer Hooksについて紹介します。\nMattermost Pluginについての公式ドキュメントは下記になります。 https://developers.mattermost.com/extend/plugins/overview/\nMattermost Plugin (Server) について Server Hooksの説明の前に、Mattermost Pluginの本体について紹介します。\nMattermostのServerサイドのPluginを実装する場合、plugin.MattermostPluginを埋め込んだ構造体がPlugin本体となります。plugin.MattermostPluginを埋め込んだ構造体は、APIとHelperというフィールドを持ち、これらのフィールドを経由してMattermostのリソースを処理する様々なメソッドを呼び出すことができます。また、plugin.MattermostPluginを埋め込んだ構造体に対してServer Hooksと同じインターフェースを持つメソッドを実装することで、Server Hooksを利用することができるようになります。\npackage main import ( \u0026#34;github.com/mattermost/mattermost-server/v5/plugin\u0026#34; ) type SamplePlugin struct { plugin.MattermostPlugin } // OnActivate Hooksの実装 func (p *SamplePlugin) OnActivate() error { // `API`フィールドを通じたPlugin APIの呼び出し \tif err := p.API.RegisterCommand(\u0026amp;model.Command{ Trigger: \u0026#34;sample-command\u0026#34;, }); err != nil { return errors.Wrap(err, \u0026#34;failed to register command\u0026#34;) } return nil } mainメソッドでplugin.MattermostPluginを埋め込んだ構造体を引数としてplugin.ClientMainメソッドを呼ぶことで、プラグインを起動することができます。\npackage main import ( \u0026#34;github.com/mattermost/mattermost-server/v5/plugin\u0026#34; ) func main() { plugin.ClientMain(\u0026amp;SamplePlugin{}) } Server Hooks Mattermost PluginのServer Hooksは、Mattermost上でユーザーがチャンネルに参加したときや、ユーザーがMattermostにログインしたときなど、何かのアクションに応じて実行される処理を追加できる機能です。 plugin.MattermostPluginを埋め込んだ構造体に、Server Hooksと同じインターフェースを持つメソッドを実装することで利用可能になります。\nServer Hooksの一覧は下記から確認できます。\nhttps://developers.mattermost.com/extend/plugins/server/reference/#Hooks\nOnActivate OnActivate\u001dはPluginが起動したときに呼ばれるHookです。Botを使うPluginの場合はこのHook内でBotユーザーを作成したり、Slash Commandを使うPluginならSlashCommandの登録などを行います。(Pluginから登録したSlash Commandは、通常の統合機能として作成したSlash Commandと違い外部アプリケーションにリクエストは送信されません。Slash Commandが実行された時の処理は、Server HooksのExecuteCommandで実装します。)\n`error``が返却された場合は、プラグインが起動されません。\nfunc (p *SamplePlugin) OnActivate() error { // Botの登録 \tbot := \u0026amp;model.Bot{ Username: \u0026#34;test-bot\u0026#34;, DisplayName: \u0026#34;Sample Bot\u0026#34;, } botUserID, appErr := p.Helpers.EnsureBot(bot) if appErr != nil { return errors.Wrap(appErr, \u0026#34;failed to ensure bot user\u0026#34;) } p.botUserID = botUserID // Slash Commandの登録 \tif err := p.API.RegisterCommand(\u0026amp;model.Command{ Trigger: \u0026#34;sample\u0026#34;, AutoComplete: true, }); err != nil { return errors.Wrap(err, \u0026#34;failed to register command\u0026#34;) } return nil } Implemented Implementedは、Pluginが実装しているHookの名前を返すためのHooksです。しかし、実装されているのを見たことがないので、用途はないかもしれません。\nfunc (p *MatterpollPlugin) Implemented() ([]string, error) { return []string{\u0026#34;OnActivate\u0026#34;, \u0026#34;Implemented\u0026#34;}, nil } OnDeactivate OnDeactivateはプラグインが停止された時に実行されます。\nfunc (p *MatterpollPlugin) OnDeactivate() error { p.clean() return nil } OnConfigurationChange Plugin専用の設定が変更された際に実行されます。 Mattermost PluginのManifestファイルにsettingsを記述することで、Plugin専用の設定画面を持つことができます。\nOnConfigurationChange周りの処理は下記のStarterテンプレートのコードを流用すると良いです。 https://github.com/mattermost/mattermost-plugin-starter-template/blob/master/server/configuration.go\ntype configuration struct { SampleSetting string } func (p *SamplePlugin) OnConfigurationChange() error { var configuration = new(configuration) // Load the public configuration fields from the Mattermost server configuration. \tif err := p.API.LoadPluginConfiguration(configuration); err != nil { return errors.Wrap(err, \u0026#34;failed to load plugin configuration\u0026#34;) } p.setConfiguration(configuration) return nil } ServeHTTP Mattermost Plugin専用のエンドポイントに対してリクエストが送信された時に実行されます。\nMattermost PluginにはPluginごとにエンドポイントが存在します。Mattermostがhttps://example.com:8065で起動していたとすると、https://example.com:8065/plugins/{PLUGING_ID}がPlugin専用のエンドポイントになります。ここに送られたリクエストを処理するのがServeHTTPです。\nfunc (p *SamplePlugin) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \u0026#34;Hello, world!\u0026#34;) } Interactive Messageなどのリクエスト送信先をPlugin用のエンドポイントにするなどの利用方法があります。\nExecuteCommand Plugin APIのRegisterCommandで登録されたコマンドが実行された時に処理されます。\nfunc (p *SamplePlugin) OnActivate() error { // Slash Commandの登録 \tif err := p.API.RegisterCommand(\u0026amp;model.Command{ Trigger: \u0026#34;sample\u0026#34;, AutoComplete: true, }); err != nil { return errors.Wrap(err, \u0026#34;failed to register command\u0026#34;) } return nil } func (p *SamplePlugin) ExecuteCommand(c *plugin.Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) { return \u0026amp;model.CommandResponse{Text: \u0026#34;Hello by plugin\u0026#34;}, nil } UserHasBeenCreated UserHasBeenCreatedは、ユーザーが新規に作成された場合に実行されます。 新しく参加したユーザーにBotからメッセージを送る場合などに使用できます。\nfunc (p *SamplePlugin) UserHasBeenCreated(c *plugin.Context, user *model.User) { channel, appErr := p.API.GetDirectChannel(p.botUserID, user.Id) if appErr != nil { p.API.LogWarn(\u0026#34;failed to get direct channel\u0026#34;, \u0026#34;user_id1\u0026#34;, p.botUserID, \u0026#34;user_id2\u0026#34;, user.Id, \u0026#34;details\u0026#34;, appErr.Error()) return } if _, appErr := p.API.CreatePost(\u0026amp;model.Post{ ChannelId: channel.Id, UserId: p.botUserID, Message: \u0026#34;Welcome to Our Mattermost!\u0026#34;, }); appErr != nil { p.API.LogWarn(\u0026#34;failed to create welcome post.\u0026#34;, \u0026#34;channel_id\u0026#34;, channel.Id, \u0026#34;details\u0026#34;, appErr.Error()) } } UserWillLogIn UserWillLogInは、ユーザーがログインする直前に実行されます。\n空文字以外の文字列を返すとログインが取り消されますが、現在のバージョンでは返却した文字列はユーザーには表示されず、ユーザー名とパスワードが合っていてもEnter a valid email or username and/or passwordというメッセージが表示されてしまうようです。さらに、プラグインを管理できるユーザーがログアウトしてしまうと、前記のエラーでログインできず、利用可能な状態に戻すのが困難になってしまうかもしれないため、使用には注意が必要そうです。\nunc (p *SamplePlugin) UserWillLogIn(c *plugin.Context, user *model.User) string { if err := p.check(); err != nil { return err.Error() } return \u0026#34;\u0026#34; } UserHasLoggedIn UserHasLoggedInは、ユーザーがログインした直後に実行されます。\n前回ログアウト(オフライン)してから、7日以上経過していた場合にBotからメッセージを送信する場合などに利用できます。\nfunc (p *SamplePlugin) UserHasLoggedIn(c *plugin.Context, user *model.User) { status, appErr := p.API.GetUserStatus(user.Id) if appErr != nil { p.API.LogWarn(\u0026#34;failed to get user status\u0026#34;, \u0026#34;user_id\u0026#34;, user.Id, \u0026#34;details\u0026#34;, appErr.Error()) return } t := time.Unix(status.LastActivityAt/1000, status.LastActivityAt%1000) if status.Status == model.STATUS_OFFLINE \u0026amp;\u0026amp; time.Now().After(t.AddDate(0, 0, 7)) { channel, appErr := p.API.GetDirectChannel(p.botUserID, user.Id) if appErr != nil { p.API.LogWarn(\u0026#34;failed to get direct channel\u0026#34;, \u0026#34;user_id1\u0026#34;, p.botUserID, \u0026#34;user_id2\u0026#34;, user.Id, \u0026#34;details\u0026#34;, appErr.Error()) return } if _, appErr := p.API.CreatePost(\u0026amp;model.Post{ ChannelId: channel.Id, UserId: p.botUserID, Message: \u0026#34;Hi! :wave:\u0026#34;, }); appErr != nil { p.API.LogWarn(\u0026#34;failed to create post.\u0026#34;, \u0026#34;channel_id\u0026#34;, channel.Id, \u0026#34;details\u0026#34;, appErr.Error()) } } } MessageWillBePosted MessageWillBePostedは、投稿されたメッセージがデータベースに保存される前に実行されます。投稿を拒否したり、投稿内容を自動で編集したい場合などに利用できます。投稿作成時に拒否や編集以外の処理を実行する場合は、投稿がデータベースに保存された後に実行されるMessageHasBeenPostedの利用が推奨されています。\n投稿を拒否する場合は、２つ目のreturn値に空でない文字列を指定します。一つ目の返却値の*model.Postには内容を編集した後の*model.Postを指定します。nilを指定した場合でも、引数で与えられた*model.Postが指定されたものと解釈されます。\nfunc (p *SamplePlugin) MessageWillBePosted(c *plugin.Context, post *model.Post) (*model.Post, string) { if strings.Contains(post.Message, \u0026#34;shit\u0026#34;) || strings.Contains(post.Message, \u0026#34;💩\u0026#34;) { return nil, \u0026#34;You can\u0026#39;t use `shit` and 💩 on this server.\u0026#34; } return nil, \u0026#34;\u0026#34; } このHookによって投稿が拒否された場合、ユーザーからはその拒否理由が見えないようなので、拒否基準を明文化したり、拒否理由をBotから通知するなどの対応が必要そうです。\nMessageWillBeUpdated MessageWillBeUpdatedは、投稿済みのメッセージを編集した際、編集内容がデータベースに保存される直前に実行される処理です。 MessageWillBePostedとほぼ同じ内容のため、例は省略します。\nfunc (p *SamplePlugin) MessageWillBeUpdated(c *plugin.Context, newPost, oldPost *model.Post) (*model.Post, string) { ... } MessageHasBeenPosted MessageHasBeenPostedは、投稿がデータベースに保存された直後に実行される処理です。\n特定のキーワードを含むメッセージが作成された場合に、特定のチャンネルに通知するようなコードは下記のようになります。 Botが作成した投稿もこのHookで処理されるため、考慮が漏れると処理が無限ループしてしまうため注意が必要です。また、非公開チャンネルの投稿なども処理されてしまうため、その点を考慮する必要もあります。\nfunc (p *SamplePlugin) MessageHasBeenPosted(c *plugin.Context, post *model.Post) { postUrl := fmt.Sprintf(\u0026#34;http://localhost:8065/_redirect/pl/%s\u0026#34;, post.Id) if strings.Contains(post.Message, \u0026#34;mattermost\u0026#34;) \u0026amp;\u0026amp; post.UserId != p.botUserID { p.API.CreatePost(\u0026amp;model.Post{ Message: fmt.Sprintf(\u0026#34;Post refered to `mattermost` is created. See [here](%s) \u0026#34;, postUrl), UserId: p.botUserID, ChannelId: \u0026#34;su7w9z51atnspjufg1c73ijx8w\u0026#34;, }) } } MessageHasBeedUpdated MessageHasBeenUpdatedは、投稿済みのメッセージを編集した際、編集内容がデータベースに保存された直後に実行される処理です。 こちらもMessageHasBeenPostedとほぼ同じ内容のため、例は省略します。\nfunc (p *SamplePlugin) MessageHasBeenUpdated(c *plugin.Context, newPost, oldPost *model.Post) { ... } ChannelHasBeenCreated ChannelHasBeenCreatedは、チャンネルが作成された直後に実行されます。\nチャンネルが作成されたことをtown-squareチャンネルに通知するコードは下記のようになります。このHookについても、非公開チャンネルが作成された場合の考慮が必要になります。\nfunc (p *SamplePlugin) ChannelHasBeenCreated(c *plugin.Context, channel *model.Channel) { if channel.Type != model.CHANNEL_OPEN { return } u, appErr := p.API.GetUser(channel.CreatorId) if appErr != nil { p.API.LogError(\u0026#34;Failed to get user\u0026#34;, \u0026#34;details\u0026#34;, appErr) return } townSquare, appErr := p.API.GetChannelByName(channel.TeamId, model.DEFAULT_CHANNEL, false) if appErr != nil { p.API.LogError(\u0026#34;Failed to get channel\u0026#34;, \u0026#34;details\u0026#34;, appErr) return } if _, appErr := p.API.CreatePost(\u0026amp;model.Post{ Type: model.POST_DEFAULT, ChannelId: townSquare.Id, UserId: p.botUserID, Message: fmt.Sprintf(\u0026#34;Channel ~%s has been created by %s.\u0026#34;, channel.Name, u.GetDisplayName(model.SHOW_USERNAME)), }); appErr != nil { p.API.LogError(\u0026#34;Failed to create post\u0026#34;, \u0026#34;details\u0026#34;, appErr) } } UserHasJoinedChannel UserHasJoinedChannelは、ユーザーがチャンネルに参加した直後に実行されます。第３引数のactorは、他のユーザーがユーザーをチャンネルに追加した場合など、ユーザーをチャンネルに追加する処理を実行した人の情報が入ります。\nチャンネルに新しく参加したユーザーに読んで欲しいリンクなどを通知する場合に利用できます。\nfunc (p *SamplePlugin) UserHasJoinedChannel(c *plugin.Context, channelMember *model.ChannelMember, actor *model.User) { if channelMember.ChannelId != TargetChannelID { return } p.API.SendEphemeralPost(actor.Id, \u0026amp;model.Post{ ChannelId: channelMember.ChannelId, UserId: p.botUserID, Message: fmt.Sprintf(\u0026#34;This chanels is for XXX user. You\u0026#39;d better to read [notes for this channel](%s).\u0026#34;, UrlForNotes), }) } UserHasLeftChannel UserHasLeftChannelは、ユーザーがチャンネルから脱退した直後に実行されます。 UserHasJoinedChannelとほぼ同じ内容のため、例は省略します。\nfunc (p *SamplePlugin) UserHasLeftChannel(c *plugin.Context, channelMember *model.ChannelMember, actor *model.User) { ... } UserHasJoinedTeam UserHasJoinedTeamは、ユーザーがチームに参加した直後に実行されます。 UserHasJoinedChannelとほぼ同じ内容のため、例は省略します。\nfunc (p *SamplePlugin) UserHasJoinedTeam(c *plugin.Context, teamMember *model.TeamMember, actor *model.User) { ... } UserHasLeftTeam UserHasLeftTeamは、ユーザーがチャンネルから脱退した直後に実行されます。 UserHasJoinedChannelとほぼ同じ内容のため、例は省略します。\nfunc (p *SamplePlugin) UserHasLeftTeam(c *plugin.Context, teamMember *model.TeamMember, actor *model.User) { ... } FileWillBeUploaded FileWillBeUploadedは、メッセージ入力欄にファイルが添付された時に実行されます。ユーザーが投稿作成を実行する前にファイルが変換されます。\n添付されたファイルの情報は第2引数の*model.FileInfoから、ファイルの内容は第3引数のio.Readerから取得できます。添付ファイルに変更を加えた場合は、第4引数のio.Writerに書き込みます。 また、ファイルの添付を拒否する場合は、2つ目の返却値に空でない文字列を指定します。1つ目の返却値の*model.FileInfoには内容を編集した後の*model.FileInfoを指定します。もしファイルを編集した場合、編集後のファイルサイズについては自動で更新されるため、FileWillBeUploaded内で計算する必要はありません。\n画像にフィルタをかける例は下記のようになります。\nfunc (p *SamplePlugin) FileWillBeUploaded(c *plugin.Context, info *model.FileInfo, file io.Reader, output io.Writer) (*model.FileInfo, string) { if info.IsImage() { // Decode original image \timg, _, err := image.Decode(file) if err != nil { p.API.LogWarn(\u0026#34;failed to decode uploaded image\u0026#34;, \u0026#34;details\u0026#34;, err.Error()) return nil, \u0026#34;\u0026#34; } // Draw original image \tbase := image.NewRGBA(image.Rect(0, 0, img.Bounds().Dx(), img.Bounds().Dy())) draw.Draw(base, base.Bounds(), img, image.ZP, draw.Src) // Create green filter \tsrc := image.NewRGBA(image.Rect(0, 0, img.Bounds().Dx(), img.Bounds().Dy())) draw.Draw(src, src.Bounds(), \u0026amp;image.Uniform{color.RGBA{255, 128, 255, 128}}, image.ZP, draw.Src) // Mask original image \tmask := image.Rect(25, 25, base.Bounds().Dx()-25, base.Bounds().Dy()-25) draw.DrawMask(base, base.Bounds(), src, image.ZP, mask, image.ZP, draw.Over) // Write masked image \tpng.Encode(output, base) } return info, \u0026#34;\u0026#34; } 画像ファイルのExifを削除するなどで利用することもできますが、処理自体はMattermostサーバーにファイルが送られた後に実行されるため、注意が必要です。\nさいごに 本日は、Mattermost PluginのServer Hooksについて紹介しました。 明日も、Mattermost PluginのServerサイドで使用できるAPIとHelper関数について紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day17-plugin/","title":"[Mattermost Integrations] Plugin基本編","section":"post","date":"2020.12.17","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第17日目の記事です。\n本記事では、Mattermostのプラグイン機能について紹介します。Mattermost Pluginは機能が多いため、本日はMattermostの概要と使い方、Mattermost公式チームが用意しているMattermost Plugin開発のためのテンプレートプロジェクトの紹介までを行います。\nMattermost Plugin Mattermost Pluginは、Mattermostの様々な箇所に存在する拡張ポイントを使ってより幅広く、コアに近い部分に処理を差し込むことができる機能です。今まで紹介してきた統合機能に比べて、下記２点で優れていると個人的に思っています。\n 投稿以外のユーザーの行動に対して独自の処理を追加することができる Mattermostと同じサーバー上で動かすことができ、プロセス管理もMattermostに任せられる  1.の点については、今まで紹介してきた統合機能は、メッセージの投稿やSlash Commandの実行などMattermost上で投稿操作が行われた際に独自の処理を実行することができるというものでした。しかし、Plugin機能では、ユーザーによる投稿操作の他にもチャンネル/チームへの参加/脱退やチャンネル作成時など、Mattermost上の様々な操作に反応して独自の処理を実行させることができます。また、投稿操作についても、投稿がデータベースに保存される前後で処理を実行することができるため、投稿が作成される前にRejectするようなこともできます。\n2.の点についてはWebSocket APIを使うことで実現できたかもしれませんが、WebSocket APIを始めMattermostの統合機能を使うには、Mattermostとは別に統合機能からのリクエストを受け取るサーバーアプリケーションを構築しておく必要がありました。しかし、Mattermost Pluginは、そのプロセス管理をMattermost自身が行うため、Mattermost以外のサーバーを管理する必要はありません。これが2.の利点です。さらに、Mattermost PluginではPlugin用のKey-Valueストアも用意されているため、簡単なデータの保持であればMattermostに任せることができます。\nMattermost Pluginは、サーバー側で動作するServerサイドのプラグインとブラウザ上で動作するWebappサイドのプラグインがあります。一つのPluginに両方の機能を持たせても良いですし、どちらか一方の機能だけのPluginを実装することもできます。\nMattermost Pluginの使用 まず、Mattermost Pluginを使ってみるところから紹介します。\n今回は、私も開発に参加しているMattermost上で投票機能を作成することができるMatterpollプラグインを手動でインストールしてみます。\nhttps://github.com/matterpoll/matterpoll\n設定 まず、Mattermost Pluginを使うには、システムコンソール \u0026gt; プラグイン管理 \u0026gt; プラグインを有効にするが有効になっている必要があります。\nまた、手動でプラグインのインストールを行う場合、システムコンソール \u0026gt; プラグイン管理 \u0026gt; プラグインをアップロードするのファイルを選択するが有効になっている必要があります。もし、このボタンが無効化されている場合は、Mattermostが起動しているサーバーのMattermostインストールディレクトリにあるconfig/config.jsonのEnableUploadsをtrueにし、Mattermostを再起動する必要があります。\n... \u0026#34;PluginSettings\u0026#34;: { \u0026#34;Enable\u0026#34;: true, \u0026#34;EnableUploads\u0026#34;: true, ... インストール Pluginを使用する設定が完了したら、以下のページからcom.github.matterpoll.matterpoll-1.4.0.tar.gzをダウンロードして、システムコンソール \u0026gt; プラグイン管理 \u0026gt; プラグインをアップロードするからアップロードします。\nhttps://github.com/matterpoll/matterpoll/releases/tag/v1.4.0\n(Matterpoll v1.4.0はMattermost v5.20以上を対象としているため、それより古いバージョンを使用している場合は、Matterpollも古いバージョンのものをお使いください)\nインストールが正常に終了すると、インストール済みプラグインのところにMatterpollが表示されます。Matterpollプラグインのところにある有効にするのリンクをクリックすることでプラグインを有効にできます。\n実行 Matterpollプラグインが問題なく起動できれば、Matterpollの機能が利用できるようになっています。MatterpollはSlash Commandで投票を作成するため、チャンネルに戻り /poll help と打つと、Matterpollのヘルプメッセージが出てきます。\nMattermost Pluginの開発 先ほども見たように、Mattermost Pluginの本体は.tar.gzファイルになります。この.tar.gzファイルには、プラグインのマニフェストファイルや、Serverサイド機能のバイナリ、Webappサイドの.jsファイルなどが含まれています。\n毎回一からこれらを用意するのは大変なため、MattermostチームはMattermost Plugin開発用のテンプレートリポジトリを公開しています。\nhttps://github.com/mattermost/mattermost-plugin-starter-template\nこのテンプレートリポジトリを使ったMattermost Pluginの開発方法は、以下の記事で既に紹介しているため、ここでの説明は割愛します。\nMattermostプラグイン用のGitHubリポジトリテンプレートを使ってみる - Qiita\nMattermost Demo Plugin Mattermost PluginではMattermostの様々な箇所を拡張できますが、Pluginで拡張できる箇所を紹介するDemo用のプラグインが公開されています。\nhttps://github.com/mattermost/mattermost-plugin-demo\nこのプラグインをインストールすることで、全てではないですがMattermost Pluginで拡張可能な箇所を確認できます。\nさいごに 本日は、Mattermost Pluginの概要や使い方について紹介しました。 明日からは、Mattermost Pluginで実現できる機能について紹介していきます。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day16-interactive-dialog/","title":"[Mattermost Integrations] Interactive Dialog","section":"post","date":"2020.12.16","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第16日目の記事です。\n本記事では、Mattermostでユーザーの入力を受け付けるダイアログを表示するInteractive Dialogの機能について紹介します。\nInteractive Dialogの概要 Interactive Dialogは、Slash CommandやInteractive Messageなどのアクションを起点に、Mattermost上にユーザー入力を受け付けるダイアログ(モーダルウィンドウ)を表示する機能です。\n(画像は公式ドキュメントから)\nInteractive Dialogに関する公式ドキュメントは下記になります。\n https://docs.mattermost.com/developer/interactive-dialogs.html  Interactie Dialogは、何度かMattermostとインタラクションをしながら動作するもののため、動作が複雑になります。今までのようにcurlだけで動作させることは難しいため、Goのコードで書いたものを断片的に紹介していきます。\n今回は、Interactive Dialogの入力内容からMessage Attachmentsのメッセージを作成するような例を考えてみます。\nTrigger IDの取得 Interactive Dialogを起動するには、まず、Mattermost内部で生成されるTrigger IDというものが必要です。Trigger IDはSlash CommandやInteractive Messageのアクションを実行した時に、Mattermostから送信されるリクエストに含まれています。Slash Command実行時のリクエストからTrigger IDを取得する場合、Slash Command実行時に送信されるリクエストを処理するサーバーで、以下のようにTrigger IDを取得することができます。\nhttp.HandleFunc(\u0026#34;/command\u0026#34;, func(w http.ResponseWriter, r *http.Request) { r.ParseForm() // (1) Slash Command実行時に送信されるリクエストから \u0026#34;Trigger ID\u0026#34; を取得 \ttriggerId := r.Form.Get(\u0026#34;trigger_id\u0026#34;) ... Interactive Message Buttonなどのアクションから取得する際は、PostActionIntegrationRequest.TriggerIdからTrigger IDを取得できます。\nInteractive Dialogの起動 先ほど取得したTrigger IDを使って、MattermostへInteractive Dialog起動のリクエストを投げます。 Trigger IDを取得するコードに続けて、/api/v4/actions/dialogs/openにOpenDialogRequestで定義されるリクエストを送信することでInteractive Dialogを起動することができます。\nhttp.HandleFunc(\u0026#34;/command\u0026#34;, func(w http.ResponseWriter, r *http.Request) { r.ParseForm() // (1) Slash Command実行時に送信されるリクエストから \u0026#34;Trigger ID\u0026#34; を取得 \ttriggerId := r.Form.Get(\u0026#34;trigger_id\u0026#34;) // (2) Interactive Dialogを起動するためのリクエストを構築 \trequest := model.OpenDialogRequest{ TriggerId: triggerId, URL: \u0026#34;http://localhost:8080/actions/dialog\u0026#34;, Dialog: model.Dialog{ Title: \u0026#34;Sample Interactive Dialog\u0026#34;, Elements: []model.DialogElement{{ DisplayName: \u0026#34;Title\u0026#34;, Name: \u0026#34;title\u0026#34;, Type: \u0026#34;text\u0026#34;, }, { DisplayName: \u0026#34;Message\u0026#34;, Name: \u0026#34;message\u0026#34;, Type: \u0026#34;textarea\u0026#34;, }}, }, } // (3) Interactive Dialogを開く \tb, _ := json.Marshal(request) req, _ := http.NewRequest(http.MethodPost, \u0026#34;http://localhost:8065/api/v4/actions/dialogs/open\u0026#34;, bytes.NewReader(b)) req.Header.Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) resp, err := http.DefaultClient.Do(req) ... (2)で構築しているOpenDialogRequestにどのようなダイアログを表示するかという情報も指定するのですが、詳しくは後述します。 (3)で/actions/dialogs/openにリクエストを送信していますが、ここではAccessTokenなどが必要ありません。これはTrigger ID自体の利用可能期限が3秒と短く、悪用の心配がないためだと思われます。この点は、Trigger IDを取得してからダイアログを開く前に時間のかかる処理などを入れないよう注意する必要があるということも意味します。\n/actions/dialogs/openへのリクエストが正常に完了すると、Mattermost上でInteractive Dialogが表示されます。\nInteractive Dialog起動時のパラメータ Interactive Dialogを起動する際に送信するOpenDialogRequestに与えることができるパラメータは下記の通りです。\n TriggerId: Slash CommandやInteractive Messageのアクションを実行した時にMattermost内部で生成されるInteractive Dialog起動用のIDを指定します URL: Interactive Dialogに入力された情報の送信先URLを指定します Dialog: Interactive Dialog上に表示される要素を指定します  CallbackId: 統合機能で設定されるIDです。Slash Commandの場合はCommandArgs.RootId、Interactive Messageの場合はPostActionIntegrationRequest.PostIdを指定している気がしますが、何に使われているかはいまいちわかりません。 Title: Interactive Dialogのタイトル部分に表示されるテキストを指定します IntroductionText: Titleの下に表示されるダイアログの説明文を指定します IconURL: ダイアログに表示されるアイコンのURLを指定します SubmitLabel: ダイアログの決定ボタンのラベルを指定します NotifyOnCancel: ダイアログのキャンセルボタンが押された時に、サーバーにその旨を通知するかを選択します。trueの場合、キャンセル通知がサーバーに送信されます State: 統語機能によって処理の状態を管理したい場合に設定される任意のフィールドです Elements: ダイアログ上の入力フィールドを指定します。利用可能なElementについては公式ドキュメントを参照してください。    Interactive Dialogからのリクエスト受信 Interactive Dialogの送信ボタンが押されると、OpenDialogRequestのURLフィールドに指定したURLへリクエストが送信されます。\n// (2) Interactive Dialogを起動するためのリクエストを構築 \trequest := model.OpenDialogRequest{ TriggerId: triggerId, URL: \u0026#34;http://localhost:8080/actions/dialog\u0026#34;, ... 送信されるリクエストはMattermostのコードではSubmitDialogRequestとして定義されています。\ntype SubmitDialogRequest struct { Type string `json:\u0026#34;type\u0026#34;` URL string `json:\u0026#34;url,omitempty\u0026#34;` CallbackId string `json:\u0026#34;callback_id\u0026#34;` State string `json:\u0026#34;state\u0026#34;` UserId string `json:\u0026#34;user_id\u0026#34;` ChannelId string `json:\u0026#34;channel_id\u0026#34;` TeamId string `json:\u0026#34;team_id\u0026#34;` Submission map[string]interface{} `json:\u0026#34;submission\u0026#34;` Cancelled bool `json:\u0026#34;cancelled\u0026#34;` } ユーザーがInteractive Dialog上で入力したデータは Submission に格納されています。SubmissionはOpenDialogRequest内のDialogElementのNameをkey、入力データをvalueとしたmap形式のデータです。\n今回のInteractive Dialogでは、titleとmessageというNameを持つDialogElementを指定しているため、Submissionからはこれらの値をキーとするValueが格納されています。\n... Elements: []model.DialogElement{{ DisplayName: \u0026#34;Title\u0026#34;, Name: \u0026#34;title\u0026#34;, Type: \u0026#34;text\u0026#34;, }, { DisplayName: \u0026#34;Message\u0026#34;, Name: \u0026#34;message\u0026#34;, Type: \u0026#34;textarea\u0026#34;, }}, ... 以上より、Interactive Dialogからのリクエストを受信し、入力内容からMessage Attachmentのメッセージを作るアプリケーションは以下のようになります。\n... http.HandleFunc(\u0026#34;/actions/dialog\u0026#34;, func(w http.ResponseWriter, r *http.Request) { defer r.Body.Close() // (4) リクエストデータの読み出し \tb, _ := ioutil.ReadAll(r.Body) var payload model.SubmitDialogRequest json.Unmarshal(b, \u0026amp;payload) title, ok := payload.Submission[\u0026#34;title\u0026#34;].(string) if !ok { resp := model.SubmitDialogResponse{Error: \u0026#34;failed to get title\u0026#34;} w.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, string(resp.ToJson())) return } msg, ok := payload.Submission[\u0026#34;message\u0026#34;].(string) if !ok { resp := model.SubmitDialogResponse{Error: \u0026#34;failed to get message\u0026#34;} w.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, string(resp.ToJson())) return } // (5) Message Attachmentsインスタンス作成 \tpost := \u0026amp;model.Post{ ChannelId: payload.ChannelId, Props: model.StringInterface{ \u0026#34;attachments\u0026#34;: []*model.SlackAttachment{{ Title: title, Text: msg, }}, }, } // (6) REST APIによるメッセージ投稿 \treq, _ := http.NewRequest(http.MethodPost, \u0026#34;http://localhost:8065/api/v4/posts\u0026#34;, strings.NewReader(post.ToJson())) req.Header.Add(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34;+MattermostAccessToken) req.Header.Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) resp, err := http.DefaultClient.Do(req) // (7) エラー処理 \tdialogResp := model.SubmitDialogResponse{} if err != nil { dialogResp.Error = err.Error() } if resp.StatusCode != http.StatusCreated { dialogResp.Error = fmt.Sprintf(\u0026#34;failed to request: %s\u0026#34;, resp.Status) } w.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, string(dialogResp.ToJson())) }) ... Interactive Dialogからのリクエストを受け取ったら、(4)でリクエストを SubmitDialogRequest形式で読み込みます。そして、SubmitDialogRequestのSubmissionからtitle、messageをキーに持つ値を取得します。SubmissionのValueはinterface{}型なので、文字列の場合はキャストが必要です。\nデータを読み出せたら (5) で、読み出したデータを使ってMessage Attachmentsを含むPostインスタンスを作成し、(6)でREST API経由で投稿を作成しています。REST APIを実行するため、Mattermostのアクセストークン(MattermostAccessToken)を事前に取得しておく必要があります。\n最後に (7) でREST APIの実行結果をチェックし、エラーが発生している場合はSubmitDialogResponse形式のデータを返却します。\ntype SubmitDialogResponse struct { Error string `json:\u0026#34;error,omitempty\u0026#34;` Errors map[string]string `json:\u0026#34;errors,omitempty\u0026#34;` } SubmitDialogResponseのErrorにはInteractive Dialog全体のエラーとして表示される文字列、ErrorsにはDialogElementの要素ごとのエラーメッセージを指定します。ErrorsはSubmissionと同じくDialogElementのNameをkeyとするmap形式でエラーメッセージを指定します。\n試しに、以下のようなSubmitDialogResponseを返したときの結果を紹介します。\ndialogResp.Errors = map[string]string{ \u0026#34;title\u0026#34;: \u0026#34;title error\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;message error\u0026#34;, } dialogResp.Error = \u0026#34;error\u0026#34; w.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, string(dialogResp.ToJson())) 以上のようにInteractive Dialogからのリクエストを処理できます。\nさいごに 本日は、Interactive Dialogの使い方について紹介しました。 明日からは、Mattermostのプラグイン機能について紹介していきます。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day15-interactive-message-menu/","title":"[Mattermost Integrations] Interactive Message Menu","section":"post","date":"2020.12.15","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第15日目の記事です。\n本記事では、Mattermostの投稿にユーザーが操作できるセレクトボックスを追加するInteractive Message Menuの機能について紹介します。\nInteractive Message Menu概要 Interactive Message Menuは、昨日紹介したInteractive Message Buttontと同様の機能です。\nInteractive Message Buttonは、Mattermostの投稿にボタンを表示する機能でしたが、Interactive Message Menuでは、Mattermostの投稿にセレクトボックスを表示することができます。\nInteractive Messageに関する公式ドキュメントは下記になります。\n https://docs.mattermost.com/developer/interactive-messages.html  作成 Interactive Message Menuを含む投稿を作成する方法はInteractive Message Buttonの時とほぼ同じです。\nIncoming Webhook(内向きのウェブフック)を使って作成する例は下記のようになります。\nBODY=\u0026#39;{ \u0026#34;attachments\u0026#34;: [{ \u0026#34;title\u0026#34;: \u0026#34;Echo text\u0026#34;, \u0026#34;actions\u0026#34;: [{ \u0026#34;id\u0026#34;: \u0026#34;echo\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Would you like to echo?\u0026#34;, \u0026#34;integration\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://localhost:8080/actions/echo\u0026#34;, \u0026#34;context\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;sample text\u0026#34; } }, \u0026#34;type\u0026#34;: \u0026#34;select\u0026#34;, \u0026#34;options\u0026#34;: [{ \u0026#34;text\u0026#34;: \u0026#34;Echo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;echo\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Reject\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;reject\u0026#34; }] }] }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr 上記のリクエストを実行すると、下記のようなセレクトボックスを含む投稿が作成されます。\noptionsに指定したオプションがセレクトボックスから選べるようになっています。\nセレクトボックスから要素を選択すると、対応するオプションのvalueに指定した値を含むリクエストがIntegrationに指定したURLへ送信されることになります。\nパラメータ actionsフィールドに指定できるパラメータは、Interactive Message Buttonと同じPostAction構造体として宣言されています。 https://github.com/mattermost/mattermost-server/blob/master/model/integration_action.go#L37\n昨日の記事にも載せましたが、再掲します。\n id: 1投稿内でユニークとなるボタンのIDを指定します。指定しない場合、Mattermost側で一意のIDが付与されます。 type: Interactive Messageの種別を指定します。selectかbuttonを指定でき、何も指定しないとbuttonが指定されます。 name: Mattermost内でボタンのラベルとして表示される文字列を指定します。 disabled: ボタンを無効化するオプションです。trueを指定するとボタンが押せなくなります。 style: ボタンの色を指定できます。default, primary, success, good, warning, danger, もしくは任意のHex color(\u0026quot;#FF9900\u0026quot;など)を指定できます。 Outgoing WebHookを利用するには、システムコンソール \u0026gt; 統合機能管理 \u0026gt; 外向きのウェブフックを有効にする の設定が有効になっている必要があります。 data_source: Interactive Message Buttonでは使用しません。Interactie Message Menuでのみ使用します。 options: Interactive Message Buttonでは使用しません。Interactie Message Menuでのみ使用します。 default_option: Interactive Message Buttonでは使用しません。Interactie Message Menuでのみ使用します。 integration: アクションを実行した際に送信されるリクエストに関する情報を指定します。  url: リクエスト送信先のURLを指定します。 context: 送信されるリクエストに含まれる追加情報を指定します integrationに指定した情報はリクエスト送信時にしか読み出されないため、(httpsなどで通信経路のセキュリティが担保されていれば)アクセストークンのような秘密情報なども含めることができます。    この中で、Interactive Message Menuのみで使用できるパラメータはdata_source, options, default_optionになります。\noptionsは、先ほどの例にも示したようにセレクトボックスで選択する要素を定義するフィールドです。 default_optionは、デフォルトで選択されているオプションを指定することができます。options内のいずれかのオプションのvalueの値を指定します。\ndata_sourceは特殊なオプションです。usersかchannelsを指定でき、これを指定するとセレクトボックスから選択できるオプションがそれぞれMattermost上のユーザーかMattermost上の公開チャンネルになります。data_sourceを指定した場合、optionsに指定されたオプションは無視されます。\nBODY=\u0026#39;{ \u0026#34;attachments\u0026#34;: [{ \u0026#34;title\u0026#34;: \u0026#34;Echo text\u0026#34;, \u0026#34;actions\u0026#34;: [{ \u0026#34;id\u0026#34;: \u0026#34;echo\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Would you like to echo?\u0026#34;, \u0026#34;integration\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://localhost:8080/actions/echo\u0026#34;, \u0026#34;context\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;sample text\u0026#34; } }, \u0026#34;type\u0026#34;: \u0026#34;select\u0026#34;, \u0026#34;data_source\u0026#34;: \u0026#34;channels\u0026#34; }] }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr 実行 今回は、slash commandの引数に指定したテキストをセレクトボックスで選択されたチャンネルへEchoするようなInteractive Message Menuを紹介します。\nslash command、Interactive Message Menuからのリクエストを受け取るサーバーアプリのサンプルコードは下記のようになります。\n(今回の例ではslash command、Interactive Message Button共に、Mattermostからlocalhostに対してリクエストが送信されるため、システムコンソール \u0026gt; 開発者 \u0026gt; 信頼されていない内部接続を許可するの設定に、リクエスト送信先のサーバーを記述しておく必要があります。詳しくは公式ドキュメントを参照ください。)\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/mattermost/mattermost-server/v5/model\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/command\u0026#34;, func(w http.ResponseWriter, r *http.Request) { r.ParseForm() response := model.CommandResponse{ ResponseType: model.COMMAND_RESPONSE_TYPE_IN_CHANNEL, Attachments: []*model.SlackAttachment{{ Title: \u0026#34;Echo server\u0026#34;, Actions: []*model.PostAction{{ // (1) Echoメニュー \tName: \u0026#34;Echo\u0026#34;, Integration: \u0026amp;model.PostActionIntegration{ URL: \u0026#34;http://localhost:8080/actions/echo\u0026#34;, Context: map[string]interface{}{ \u0026#34;text\u0026#34;: r.Form.Get(\u0026#34;text\u0026#34;), }, }, Type: model.POST_ACTION_TYPE_SELECT, Options: []*model.PostActionOptions{{ Text: \u0026#34;Echo\u0026#34;, Value: \u0026#34;echo\u0026#34;, }, { Text: \u0026#34;Reject\u0026#34;, Value: \u0026#34;reject\u0026#34;, }}, }}, }}, } // Need to set header. if not, just json string will be posted. \tw.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, response.ToJson()) }) // (2) Echo Buttonが押されたときの処理 \thttp.HandleFunc(\u0026#34;/actions/echo\u0026#34;, func(w http.ResponseWriter, r *http.Request) { defer r.Body.Close() // (3) リクエストデータの読み出し \tb, _ := ioutil.ReadAll(r.Body) var payload model.PostActionIntegrationRequest json.Unmarshal(b, \u0026amp;payload) text, ok := payload.Context[\u0026#34;text\u0026#34;].(string) if !ok { resp := \u0026amp;model.PostActionIntegrationResponse{EphemeralText: \u0026#34;invalid request. Context[\u0026#39;text\u0026#39;] is not found.\u0026#34;} fmt.Fprint(w, resp.ToJson()) return } selected, ok := payload.Context[\u0026#34;selected_option\u0026#34;].(string) if !ok { resp := \u0026amp;model.PostActionIntegrationResponse{EphemeralText: \u0026#34;invalid request. Context[\u0026#39;selected_option\u0026#39;] is not found.\u0026#34;} fmt.Fprint(w, resp.ToJson()) return } // (4) レスポンスの構築 \tresponse := \u0026amp;model.PostActionIntegrationResponse{} switch selected { case \u0026#34;echo\u0026#34;: response.Update = \u0026amp;model.Post{ Message: text, Props: model.StringInterface{}, } case \u0026#34;reject\u0026#34;: response.Update = \u0026amp;model.Post{Props: model.StringInterface{}} response.EphemeralText = \u0026#34;Echoing was rejected\u0026#34; default: response.EphemeralText = \u0026#34;invalid operation\u0026#34; } w.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, string(response.ToJson())) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } (1)ではInteractive Message Menuの内容を定義しています。Integration.URLにリクエスト送信先としてhttp://localhost:8080/actions/echoを、Integration.Contextに、slash commandの引数として指定された文字列を保持しています。また、EchoとRejectのオプションをoptionsに定義しています。\n(2)で、セレクトボックスからオプションが選択された時に送信されるリクエストを処理しています。(3)で送信されたリクエストを読み出しています。送信されるリクエストの形式は、Interactive Message Menuから送信されるリクエストもInteractive Message Buttonと同じくPostActionIntegrationRequestとして定義されています。\ntype PostActionIntegrationRequest struct { UserId string `json:\u0026#34;user_id\u0026#34;` UserName string `json:\u0026#34;user_name\u0026#34;` ChannelId string `json:\u0026#34;channel_id\u0026#34;` ChannelName string `json:\u0026#34;channel_name\u0026#34;` TeamId string `json:\u0026#34;team_id\u0026#34;` TeamName string `json:\u0026#34;team_domain\u0026#34;` PostId string `json:\u0026#34;post_id\u0026#34;` TriggerId string `json:\u0026#34;trigger_id\u0026#34;` Type string `json:\u0026#34;type\u0026#34;` DataSource string `json:\u0026#34;data_source\u0026#34;` Context map[string]interface{} `json:\u0026#34;context,omitempty\u0026#34;` } 今回はContextからtextをキーとして格納されているslash command実行時の引数と、selected_optionをキーとして格納されている選択されたオプションを読み出しています。 そして、(4)で読み出したselected_optionの値に応じてレスポンスを構築しています。レスポンスの形式もInteractie Message Buttonと同じくPostActionIntegrationResponseとして定義されています。\ntype PostActionIntegrationResponse struct { Update *Post `json:\u0026#34;update\u0026#34;` EphemeralText string `json:\u0026#34;ephemeral_text\u0026#34;` SkipSlackParsing bool `json:\u0026#34;skip_slack_parsing\u0026#34;` // Set to `true` to skip the Slack-compatibility handling of Text. } さいごに 本日は、Interactive Message Menuの使い方について紹介しました。 明日は、Interactive Dialogについて紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day14-interactive-message-button/","title":"[Mattermost Integrations] Interactive Message Button","section":"post","date":"2020.12.14","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第14日目の記事です。\n本記事では、Mattermostの投稿にユーザーが操作できるボタンを追加するInteractive Message Buttonの機能について紹介します。\nInteractive Message Button概要 Interactive Message Buttonは、Mattermostの投稿にボタンを表示し、ボタンがクリックされるとどのボタンが押されたのかという情報がサーバーへ送信される機能です。\n(画像は公式ドキュメントから)\nInteractive Messageに関する公式ドキュメントは下記になります。\n https://docs.mattermost.com/developer/interactive-messages.html  作成 Interactive Message Buttonを含む投稿を作成するには、Message Attachments機能と同様attachmentsにButtonに関する情報を追加します。\nIncoming Webhook(内向きのウェブフック)を使って作成する例は下記のようになります。\nBODY=\u0026#39;{ \u0026#34;attachments\u0026#34;: [{ \u0026#34;title\u0026#34;: \u0026#34;Echo text\u0026#34;, \u0026#34;actions\u0026#34;: [{ \u0026#34;id\u0026#34;: \u0026#34;echo\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Echo\u0026#34;, \u0026#34;integration\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://localhost:8080/actions/echo\u0026#34;, \u0026#34;context\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;sample text\u0026#34; } } }, { \u0026#34;name\u0026#34;: \u0026#34;Reject\u0026#34;, \u0026#34;style\u0026#34;: \u0026#34;danger\u0026#34;, \u0026#34;integration\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://localhost:8080/actions/reject\u0026#34; } }] }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr 上記のリクエストを実行すると、下記のようなボタンを含む投稿が作成されます。\nリクエスト内容と見ると、actionsフィールドに含まれる下記の一つのオブジェクトが一つのボタンに関連していることが分かります。\n{ \u0026#34;id\u0026#34;: \u0026#34;echo\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Echo\u0026#34;, \u0026#34;integration\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://localhost:8080/actions/echo\u0026#34;, \u0026#34;context\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;sample text\u0026#34; } } } idはボタンのID、nameは投稿上に表示されるボタンのラベルを指定します。integration内には、ボタンを押した時に送信されるリクエストの情報を記述しており、urlにはリクエスト送信先のURLを、contextにはリクエストに含まれる任意の情報を指定することができます。\nボタンが押された時に何か処理を行うには、リクエストを受け取るサーバーを用意する必要がありますが、それについては後述します。\nパラメータ actionsフィールドに指定できるパラメータは、Mattermostのサーバー側のコードにPostAction構造体として宣言されています。 https://github.com/mattermost/mattermost-server/blob/master/model/integration_action.go#L37\n id: 1投稿内でユニークとなるボタンのIDを指定します。指定しない場合、Mattermost側で一意のIDが付与されます。 type: Interactive Messageの種別を指定します。selectかbuttonを指定でき、何も指定しないとbuttonが指定されます。 name: Mattermost内でボタンのラベルとして表示される文字列を指定します。 disabled: ボタンを無効化するオプションです。trueを指定するとボタンが押せなくなります。 style: ボタンの色を指定できます。default, primary, success, good, warning, danger, もしくは任意のHex color(\u0026quot;#FF9900\u0026quot;など)を指定できます。 Outgoing WebHookを利用するには、システムコンソール \u0026gt; 統合機能管理 \u0026gt; 外向きのウェブフックを有効にする の設定が有効になっている必要があります。 data_source: Interactive Message Buttonでは使用しません。Interactie Message Menuでのみ使用します。 options: Interactive Message Buttonでは使用しません。Interactie Message Menuでのみ使用します。 default_option: Interactive Message Buttonでは使用しません。Interactie Message Menuでのみ使用します。 integration: アクションを実行した際に送信されるリクエストに関する情報を指定します。  url: リクエスト送信先のURLを指定します。 context: 送信されるリクエストに含まれる追加情報を指定します integrationに指定した情報はリクエスト送信時にしか読み出されないため、(httpsなどで通信経路のセキュリティが担保されていれば)アクセストークンのような秘密情報なども含めることができます。    実行 Interactive Message Buttonを機能させるには、ボタンが押された時に送信されるリクエストを処理するサーバーを立てておく必要があります。今回は、slash commandの引数に指定したテキストをEchoするようなInteractive Message Buttonについて考えます。\nslash command、Interactive Message Buttonからのリクエストを受け取るサーバーアプリのサンプルコードは下記のようになります。\n(今回の例ではslash command、Interactive Message Button共に、Mattermostからlocalhostに対してリクエストが送信されるため、システムコンソール \u0026gt; 開発者 \u0026gt; 信頼されていない内部接続を許可するの設定に、リクエスト送信先のサーバーを記述しておく必要があります。詳しくは公式ドキュメントを参照ください。)\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/mattermost/mattermost-server/v5/model\u0026#34; ) func main() { // (1) Interactive Message Button作成用slash command \thttp.HandleFunc(\u0026#34;/command\u0026#34;, func(w http.ResponseWriter, r *http.Request) { r.ParseForm() response := model.CommandResponse{ ResponseType: model.COMMAND_RESPONSE_TYPE_IN_CHANNEL, Attachments: []*model.SlackAttachment{{ Title: \u0026#34;Echo text\u0026#34;, Actions: []*model.PostAction{{ // (2) Echoボタン \tId: \u0026#34;echo\u0026#34;, Name: \u0026#34;Echo\u0026#34;, Integration: \u0026amp;model.PostActionIntegration{ URL: \u0026#34;http://localhost:8080/actions/echo\u0026#34;, Context: map[string]interface{}{ \u0026#34;text\u0026#34;: r.Form.Get(\u0026#34;text\u0026#34;), }, }, }, { // (3) Rejectボタン \tName: \u0026#34;Reject\u0026#34;, Style: \u0026#34;danger\u0026#34;, Integration: \u0026amp;model.PostActionIntegration{ URL: \u0026#34;http://localhost:8080/actions/reject\u0026#34;, }, }}, }}, } // Need to set header. if not, just json string will be posted. \tw.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, response.ToJson()) }) // (4) Echo Buttonが押されたときの処理 \thttp.HandleFunc(\u0026#34;/actions/echo\u0026#34;, func(w http.ResponseWriter, r *http.Request) { defer r.Body.Close() // (5) リクエストデータの読み出し \tb, _ := ioutil.ReadAll(r.Body) var payload model.PostActionIntegrationRequest json.Unmarshal(b, \u0026amp;payload) text, ok := payload.Context[\u0026#34;text\u0026#34;].(string) if !ok { resp := \u0026amp;model.PostActionIntegrationResponse{EphemeralText: \u0026#34;invalid request. Context[\u0026#39;text\u0026#39;] is not found.\u0026#34;} fmt.Fprint(w, resp.ToJson()) return } // (6) レスポンスの構築 \tresponse := \u0026amp;model.PostActionIntegrationResponse{ Update: \u0026amp;model.Post{ Message: text, Props: model.StringInterface{}, }, } w.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, string(response.ToJson())) }) // (7) Rejectボタンが押されたときの処理 \thttp.HandleFunc(\u0026#34;/actions/reject\u0026#34;, func(w http.ResponseWriter, r *http.Request) { // (8) レスポンスの構築 \tresponse := \u0026amp;model.PostActionIntegrationResponse{ Update: \u0026amp;model.Post{ Props: model.StringInterface{}, }, EphemeralText: \u0026#34;Echoing was rejected.\u0026#34;, } w.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, string(response.ToJson())) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } (1)はslash commandのリクエストを処理するロジックです。http://localhost:8080/commandへリクエストを送信するslash commandを事前に登録しておく必要があります。slash commandの登録方法については6日目の記事を参照ください。 (2)では、slash command実行時の引数情報をEchoするEchoボタンを定義しています。Integration.URLにリクエスト送信先としてhttp://localhost:8080/actions/echoを、Integration.Contextに、slash commandの引数として指定された文字列を保持しています。(3)では、Echo処理を注意するためのRejectボタンを定義しています。リクエスト送信先はhttp://localhost:8080/actions/rejectにしてあります。また、Rejectボタンには\u0026quot;style\u0026quot;: \u0026quot;danger\u0026quot;をしているため、ボタンが赤く表示されます。\nslash commandを実行すると、下記のような投稿が作成されます。\n(4)で、Echoボタンが押された時に送信されるリクエストを処理しています。まず、(5)で送信されたリクエストを読み出しています。Interactive Message Buttonから送信されるリクエストはMattermostのコードではPostActionIntegrationRequestとして定義されています。\ntype PostActionIntegrationRequest struct { UserId string `json:\u0026#34;user_id\u0026#34;` UserName string `json:\u0026#34;user_name\u0026#34;` ChannelId string `json:\u0026#34;channel_id\u0026#34;` ChannelName string `json:\u0026#34;channel_name\u0026#34;` TeamId string `json:\u0026#34;team_id\u0026#34;` TeamName string `json:\u0026#34;team_domain\u0026#34;` PostId string `json:\u0026#34;post_id\u0026#34;` TriggerId string `json:\u0026#34;trigger_id\u0026#34;` Type string `json:\u0026#34;type\u0026#34;` DataSource string `json:\u0026#34;data_source\u0026#34;` Context map[string]interface{} `json:\u0026#34;context,omitempty\u0026#34;` } 今回はContext内にtextをキーとしてslash command実行時の引数が格納されているため、その文字列を読み出しています。 そして、(6)で読み出した文字列を使ってレスポンスを構築しています。レスポンスの形式はMattermostのコードでPostActionIntegrationResponseとして定義されています。\ntype PostActionIntegrationResponse struct { Update *Post `json:\u0026#34;update\u0026#34;` EphemeralText string `json:\u0026#34;ephemeral_text\u0026#34;` SkipSlackParsing bool `json:\u0026#34;skip_slack_parsing\u0026#34;` // Set to `true` to skip the Slack-compatibility handling of Text. } PostActionIntegrationResponseのUpdateフィールドに指定したPostのインスタンスで、Interactive Message Buttonを置き換えることができます。今回はslash commandの引数として与えられた文字列をメッセージに持つ投稿に置き換えています。Props: model.StringInterface{},でPostのPropsを空にしていますが、これをしないとInteractive Message Buttonがずっと残り続けてしまうため、ボタンを削除したい場合は必ず空に設定する必要があります。Mattermost v5.10以前では、明示的にPropsを空にしなくてもInteractive Message Buttonが削除されていましたが、Mattermost v5.11以上では、明示的に空に設定しないと削除されないようになったようです。(https://docs.mattermost.com/developer/interactive-messages.html#how-do-i-manage-properties-of-an-interactive-message)\n(7)は、Rejectボタンが押されたときの処理です。(8)でレスポンスを構築していますが、ボタンが押された時にInteractive Message Buttonを含む投稿を削除したい場合は、このようにPropsを空に設定しただけのPostインスタンスを指定します。EphemeralTextに指定した文字列は、ボタンを押した人だけに見えるメッセージになります。\nさいごに 本日は、Interactive Message Buttonの使い方について紹介しました。 明日は、Interactive Message Menuについて紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day13-swags/","title":"Mattermostからの贈り物","section":"post","date":"2020.12.13","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第13日目の記事です。\n今まではMattermostの統合機能について紹介してきましたが、折り返し地点の13日目ということで、一旦Mattermostの機能紹介から離れて、今までMattermostから受け取ったグッズ(swag)について紹介します。\nMattermost Mug Mattermostのリポジトリに対するPRがマージされた人全員に送られる、GitHubユーザー名とコントリビュート日時の入った記念マグカップです。\nhttps://forum.mattermost.org/t/limited-edition-mattermost-mugs\nTwitterで#mattermugというハッシュタグを検索すると、mattermugを受け取った人のツイートを見ることができます。 https://twitter.com/search?q=%23mattermug\nMattermost MVP Mattermostは毎月新バージョンをリリースを出しており、その期間内で最も活躍した(?)コントリビュータをMVPとして表彰しています。これは、Mattermost 4.6のMVPに選ばれた時に貰った楯(?)です。\nMattermost Hall of Fame\nBottle \u0026amp; Cork Mug それぞれ何のタイミングで貰ったかは忘れてしまいましたが、ボトルとコルクが底についたマグカップです。どちらも在宅勤務で毎日使うほど愛用しています。コルクマグの方は、氷を入れても机に水滴が落ちないのですごく便利。\nMattermost T-shirt Tシャツ集。下記のようなイベントだったり、何かきっかけがあったときに貰えたりしました。\n Mattermost Holiday Hackfest 2016 Mattermost localization: 700,000 translations, hundreds of contributors Learn How to Become a Mattermost Superstar  Onesie 赤ちゃん用のロンバースというんですかね\u0026hellip;。 NRI主催のイベントでMattermost社の人が来日した時に個別に合う時間を設けてもらい、その中で子供が生まれたばかりという話をしたら「こんなものもあるよ」ということで貰ったもの。まさかこんなものまであるとは\u0026hellip;。\nUmbrella 一番最近もらったもの。開発に参加しているMatterpollプラグインがPlugin Markerplaceに公開されたことを記念して貰え増田。\nStickers ギフトと言ったらコレ。いろいろもらいました。\nLetters 最初の頃は手書きの手紙なんかも貰いました。\nMatterCon 2020 in Bahama MatterCon 2020 highlights the power of a remote community\nMattermostのコミュニティイベントがバハマであるということで、そこに招待してもらいました。興味でコントリビュートしてるもので、海外旅行までプレゼントされるとは思ってなかったので非常に印象深い経験でした。今年の2月末開催ということで新型コロナウイルスで渡航禁止になる本当に直前という感じでしたが、行きも帰りも何事もなくのんびりしてこれました。\nさいごに 本日は、Mattermostから今までもらったグッズを紹介しました。 明日からはMattermostの投稿にボタンなどのメニューを付与するInteractive Message機能について紹介していきます。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day12-bot/","title":"[Mattermost Integrations] Botアカウント","section":"post","date":"2020.12.12","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第12日目の記事です。\n本記事では、Mattermostで特定の用途向けのBotアカウントを作成する機能について紹介します。\nBotアカウントの概要 Mattermostの外部からMattermostのリソースを操作するようなアプリケーションについて考えてみます。\nMattermost外部から投稿を作成するだけであれば、WebHookやSlash Commandを利用すれば実現することができますが、これらの機能では投稿作成以外の処理を行うことができません。Mattermost REST APIを使右ことでMattermost上のチャンネル・チーム・投稿など様々なリソースをMattermost外部から操作することができますが、REST APIを実行するにはユーザーに紐づいたアクセストークンが必要なため、統合機能用のサーバーアプリケーションなどを構築する場合、ユーザー情報の不正利用を防ぐためにトークンの厳密な管理などを意識する必要が出てきます。\nこのような場合に有効なのがBotアカウント機能です。\nBotアカウント機能により特定の処理専用のユーザーアカウントを作成することができ、Botアカウントのアクセストークンを利用することで、ユーザー情報の不正な利用を心配することなくREST APIの実行などを行うことができます。\nまた、Enterpriseを利用している場合、Botアカウントは登録ユーザーとしてカウントされないため、統合機能専用のユーザーを作りやすくなります。\n設定 Mattermostの画面上からBotアカウントを作成するには、システムコンソール \u0026gt; Botアカウント \u0026gt; Botアカウントの作成を有効にする の設定が有効になっている必要があります。\n作成 メインメニュー \u0026gt; 統合機能 \u0026gt; Botアカウント \u0026gt; Botアカウントを追加するからBotアカウントを作成できます。\nBotアカウントの作成画面で入力する情報は下記の通りです。\n ユーザー名: Botアカウントのユーザー名です。既存のアカウントと同じユーザー名は使用できません。 Botアイコン: Botアカウントのアイコンをアップロードできます。 表示名: Botアカウントの表示名です。 説明: Botアカウント一覧画面に表示されるアカウントの説明です。 役割: Botアカウントに割り当てられる役割を メンバー(一般ユーザー) と システム管理者 から選択します。 投稿:全て: 公開チャンネルだけでなく、非公開チャンネルやダイレクトメッセージチャンネルなどにもBotアカウントによる投稿を作成する場合、こちらにチェックします。 投稿:チャンネル: Botアカウントによる投稿の作成が公開チャンネルだけで良い場合、こちらにチェックします。  役割、投稿:全て、投稿:チャンネルが実際にどのような効果があるかが分かりづらいですが、例えば、役割がメンバーで、投稿:全てにも投稿:チャンネルにもチェックがない場合、そのBotはチャンネルにメンバーとして追加されない限り、そのチャンネルに投稿を作成できないということになります。投稿:チャンネルが設定された場合は、公開チャンネルであればチャンネルにメンバーとして参加していなくてもそのチャンネルに投稿は作成できますが、非公開チャンネルやダイレクトメッセージチャンネルにはメンバーとして追加されるまで投稿を作成する権限がないということになります。\nBotアカウントの作成が完了すると、このBotアカウントに割り当てられたアクセストークンが表示されます。このトークンはこの画面を閉じると二度と表示することができませんが、Botアカウントにはいくつもアクセストークンを追加することができるため、アクセストークンを忘れてしまった場合は再生しすることになります。\n作成されたBotアカウントはBotアカウント一覧画面に表示されます。\n実行 Botアカウントに割り当てられたアクセストークンを使用してREST APIを実行すると、BotアカウントによってMattermostのリソースを操作することができます。\nBODY=\u0026#39;{ \u0026#34;channel_id\u0026#34;: \u0026#34;89xmji6bibbn9eqpe1okx8j8fe\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Create post by bot account\u0026#34; }\u0026#39; curl -i \\  -H \u0026#39;Authorization: Bearer 3uhox91m6bdbt8pqsczouy9mny\u0026#39; \\  -H \u0026#39;Content-Type: application/json\u0026#39; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/api/v4/posts また、Botアカウントはユーザーと同じようにチャンネルやチームに参加させることもできます。\nBotアカウント作成時に投稿:全てや投稿:チャンネルにチェックを入れなかった場合、このようにBotをチャンネルに参加させない限り、Botアカウントはそのチャンネルにアクセスできない（権限エラーで投稿が作成できない）ことになります。\nまた、Botアカウントのアクセストークンを使ってWebSocket APIをListenしている場合、Botを参加せているチャンネルのイベントだけが取得できるため、Botアカウントが参加しているチャンネルのみを対象とした処理を実装することもできます。Outgoing Webhookで指定できたのは1つのチャンネルのみ、Custom Slash Commandでは作成したチーム内の全チャンネルを対象としていましたが、Botアカウントの場合、Botアカウントをチャンネルさせるかどうかで柔軟に統合機能の対象チャンネルを設定できるようになります。\nBotアカウントの削除 Botアカウントを利用しなくなった場合、無効化はBotアカウントの一覧画面から実行できます。\nしかし、Botアカウントの削除はMattermost画面からは実行できません（できないはずです）。Botアカウントの削除を行うにはMattermostのCLIツールである mattermost コマンドを使用する必要があります。mattermostコマンドはMattermostを起動しているサーバーのMattermostインストールディレクトリ内のbin/mattermostという場所に存在するはずです。 Linux用のバイナリであればMattermostのダウンロードページからダウンロードできるMattermost本体に含まれていますが、mattermostコマンドはMattermostサーバーの設定ファイルconfig.jsonを読み込んで動作するため、Mattermostサーバー上で実行するのが無難です。\n$ bin/mattermost user delete sample_bot と、mattermost user deleteコマンドの引数としてBotアカウントのユーザー名を指定することで、Botアカウントの削除を行うことができます。\nさいごに 本日は、Botアカウントについて紹介しました。 明日はMattermostの機能から一旦離れて、今までMattermostから受け取ったSwag(Contributors Gift)を紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day11-rest-api-websocket/","title":"[Mattermost Integrations] REST API (WebSocket)","section":"post","date":"2020.12.11","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第11日目の記事です。\n本記事では、MattermostのWebSocket APIついて紹介します。\nWebSocket APIの概要 MattermostはWebSocket APIを利用することで、Mattermost上でやり取りされているWebSocketのイベントを取得することもできます。\nWebSocket APIについてはREST APIのドキュメントに説明があります。 https://api.mattermost.com/#tag/WebSocket\nWebSocketイベントの取得 MattermostのWebSocket Eventを取得するために、Mattermost公式のWebSocketクライアント websocket_client.go を利用します。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/mattermost/mattermost-server/v5/model\u0026#34; ) const ( // (1) Mattermost WebSocket Endpoint  MattermostWebSocketURL = \u0026#34;ws://localhost:8065\u0026#34; // (2) Access Token \tAccessToken = \u0026#34;4cacdozwn3fndnzobbpha3nnhy\u0026#34; ) func main() { // (3) WebSocket Clientの構築 \tclient, appErr := model.NewWebSocketClient4(MattermostWebSocketURL, AccessToken) if appErr != nil { log.Fatal(appErr.Error()) } // (4) 接続 \tif appErr = client.Connect(); appErr != nil { log.Fatal(appErr.Error()) } client.Listen() for { select { case event := \u0026lt;-client.EventChannel: // (5) WebSocket Eventについての処理 \tlog.Printf(\u0026#34;Received: %v\u0026#34;, event) } } } (1)でMattermost WebSocketのURLを宣言しています。プロトコルがhttp(s)ではなくws(s)になります。また、WebSocket APIのエンドポイントは/api/v4/websocketですが、この部分はMattermostのWebSocket Driverが付与してくれます。 (2)ではWebSocket APIにアクセスするために使用するアクセストークンを宣言しています。REST API実行用と同じTokenです。\n(3)で、MattermostのWebSocket Driverを利用してWebSocketクライアントを生成し、このクライアントを使って(4)でWebSocket APIへ接続しています。\n接続が問題なく完了すると、 WebSocketクライアントのEventChannelフィールドにWebSocket Eventが流れてきます。(5)で、流れてきたイベントを出力しています。\n上記コードを実行しておくと、Mattermost上で何か操作をした時にWebSocket Eventがコンソールに表示されるようになります。\nCtrl + cを入力するとプログラムを終了します。\n今回は単に受け取ったイベント情報を出力するだけでしたが、受け取ったWebSocketEventの内容に応じた処理を実装することもできます。 WebSocketEvent構造体のDataフィールドの内容はイベントの種類によって異なり、イベントの種類は下記から確認できます。 https://github.com/mattermost/mattermost-server/blob/c54ab6da211af861b25af1364518e549d3a1ed91/model/websocket_message.go#L14\nWebSocket APIの実行 MattermostではWebSocket APIを通じてリクエストを送信することもできるようですが、現在利用可能なのが下記3種類のみのようで、ちょっと用途が今のところ分かりません。\n user_typing get_statuses get_statuses_by_id  さいごに Mattermost WebSocket APIの使い方について紹介しました。 明日は、Botアカウントの使い方を紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day10-rest-api/","title":"[Mattermost Integrations] REST API","section":"post","date":"2020.12.10","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第10日目の記事です。\n本記事では、MattermostのREST APIについて紹介します。\nREST APIの概要 Mattermostには統合機能を作成するための様々な機能がありますが、一般的なREST APIを利用することもできます。 Mattermostで利用可能なREST APIは、下記の公式ドキュメントにまとまっています。\nhttps://api.mattermost.com/\nAccess Token (Personal Access Token) REST APIを実行するには、API実行権限を保持していることを示すためのTokenが必要になります。MattermostではいくつかTokenを取得する方法がありますが、ここでは最も手軽に使えるPersonal Access Tokenを生成する方法について紹介します。\nPersonal Access Tokenを利用するには、システムコンソール \u0026gt; 統合機能 \u0026gt; 統合機能管理 \u0026gt; パーソナルアクセストークンを有効にするが有効になっている必要があります。\nPersonal Access Token生成 メインメニュー \u0026gt; アカウントの設定 \u0026gt; セキュリティ \u0026gt; パーソナルアクセストークン \u0026gt; トークンを生成するを実行し、生成するトークンの説明を入力することでPersonal Access Tokenを生成できます。\nPersonal Access Tokenの生成に成功すると、画面にトークンが表示されます。ここでアクセストークンと表示されている文字列を使ってREST APIの呼び出しを行います。(トークンIDは、Mattermost内部でトークンを一意に識別するためのIDであり、REST APIの実行に利用することはできません)\nREST API実行 先ほど生成したトークンをAuthorizationヘッダーに指定し、/api/v4/users/meのAPIを実行することで、ユーザーの情報を取得するAPIを実行することができます。\n$ curl -i \\ \u0026gt; -H \u0026#39;Authorization: Bearer 4cacdozwn3fndnzobbpha3nnhy\u0026#39; \\ \u0026gt; http://localhost:8065/api/v4/users/me HTTP/1.1 200 OK Content-Type: application/json Etag: 5.30.0.87x93uo8pfnzdro9ktcmobpa1r.1606000641083..0.true.true.0 Expires: 0 Vary: Accept-Encoding X-Request-Id: qws4oo9dyjy8pxs48kaqd86goh X-Version-Id: 5.30.0.dev.3fbba2b2e9e21536fd2bdc547afe31fd.false Date: Sun, 22 Nov 2020 05:33:58 GMT Content-Length: 774 {\u0026#34;id\u0026#34;:\u0026#34;87x93uo8pfnzdro9ktcmobpa1r\u0026#34;,\u0026#34;create_at\u0026#34;:1598680540414,\u0026#34;update_at\u0026#34;:1606000641083,\u0026#34;delete_at\u0026#34;:0,\u0026#34;username\u0026#34;:\u0026#34;kaakaa\u0026#34;,\u0026#34;auth_data\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;auth_service\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;kaakaa@example.com\u0026#34;,\u0026#34;nickname\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;first_name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;last_name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;position\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;roles\u0026#34;:\u0026#34;system_user system_admin\u0026#34;,\u0026#34;allow_marketing\u0026#34;:true,\u0026#34;notify_props\u0026#34;:{\u0026#34;auto_responder_active\u0026#34;:\u0026#34;false\u0026#34;,\u0026#34;auto_responder_message\u0026#34;:\u0026#34;ただいま外出中のため返信できません。\u0026#34;,\u0026#34;channel\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;comments\u0026#34;:\u0026#34;never\u0026#34;,\u0026#34;desktop\u0026#34;:\u0026#34;all\u0026#34;,\u0026#34;desktop_notification_sound\u0026#34;:\u0026#34;Bing\u0026#34;,\u0026#34;desktop_sound\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;first_name\u0026#34;:\u0026#34;false\u0026#34;,\u0026#34;mention_keys\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;push\u0026#34;:\u0026#34;mention\u0026#34;,\u0026#34;push_status\u0026#34;:\u0026#34;away\u0026#34;},\u0026#34;last_password_update\u0026#34;:1598680540414,\u0026#34;locale\u0026#34;:\u0026#34;ja\u0026#34;,\u0026#34;timezone\u0026#34;:{\u0026#34;automaticTimezone\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;manualTimezone\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;useAutomaticTimezone\u0026#34;:\u0026#34;true\u0026#34;}} REST API実行 REST APIは種類が多いため、一部のみ実行方法を紹介します。\nREST APIから投稿を作成する REST APIを使ってMattermostに投稿を作成するには/postsを利用します。また、リクエストパラメータはJSON形式のためContent-Typeヘッダーにapplication/jsonを指定し、下記のようにAPIを実行することで投稿を作成できます。\nBODY=\u0026#39;{ \u0026#34;channel_id\u0026#34;: \u0026#34;uoxmk8819pyftybx6zqkij37ce\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Create post by REST API\u0026#34; }\u0026#39; curl -i \\  -H \u0026#39;Authorization: Bearer 4cacdozwn3fndnzobbpha3nnhy\u0026#39; \\  -H \u0026#39;Content-Type: application/json\u0026#39; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/api/v4/posts 以下のようにpropsフィールドにattachmentsを指定することでMessage Attachmentsを利用することもできます。\nBODY=\u0026#39;{ \u0026#34;channel_id\u0026#34;: \u0026#34;uoxmk8819pyftybx6zqkij37ce\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Create post by REST API\u0026#34;, \u0026#34;props\u0026#34;: { \u0026#34;attachments\u0026#34;: [{ \u0026#34;text\u0026#34;: \u0026#34;hoge\u0026#34; }] } }\u0026#39; 統計情報を取得する /analytics/oldではMattermostの統計情報を取得することができます。\n$ curl \\ \u0026gt; -H \u0026#39;Authorization: Bearer 4cacdozwn3fndnzobbpha3nnhy\u0026#39; \\ \u0026gt; http://localhost:8065/api/v4/analytics/old [ { \u0026#34;name\u0026#34;: \u0026#34;channel_open_count\u0026#34;, \u0026#34;value\u0026#34;: 9 }, { \u0026#34;name\u0026#34;: \u0026#34;channel_private_count\u0026#34;, \u0026#34;value\u0026#34;: 1 }, { \u0026#34;name\u0026#34;: \u0026#34;post_count\u0026#34;, \u0026#34;value\u0026#34;: 3696 }, { \u0026#34;name\u0026#34;: \u0026#34;unique_user_count\u0026#34;, \u0026#34;value\u0026#34;: 3 }, { \u0026#34;name\u0026#34;: \u0026#34;team_count\u0026#34;, \u0026#34;value\u0026#34;: 1 }, { \u0026#34;name\u0026#34;: \u0026#34;total_websocket_connections\u0026#34;, \u0026#34;value\u0026#34;: 3 }, { \u0026#34;name\u0026#34;: \u0026#34;total_master_db_connections\u0026#34;, \u0026#34;value\u0026#34;: 7 }, { \u0026#34;name\u0026#34;: \u0026#34;total_read_db_connections\u0026#34;, \u0026#34;value\u0026#34;: 0 }, { \u0026#34;name\u0026#34;: \u0026#34;daily_active_users\u0026#34;, \u0026#34;value\u0026#34;: 1 }, { \u0026#34;name\u0026#34;: \u0026#34;monthly_active_users\u0026#34;, \u0026#34;value\u0026#34;: 2 }, { \u0026#34;name\u0026#34;: \u0026#34;inactive_user_count\u0026#34;, \u0026#34;value\u0026#34;: 0 } ] nameクエリにより取得する統計情報を指定することもできます。例えば、?name=post_counts_dayでは、ここ一週間の日ごとの投稿数を取得することができます。（取得する期間の指定などには対応していないようです）\n$ curl \\ \u0026gt; -H \u0026#39;Authorization: Bearer 4cacdozwn3fndnzobbpha3nnhy\u0026#39; \\ \u0026gt; http://localhost:8065/api/v4/analytics/old?name=post_counts_day [ { \u0026#34;name\u0026#34;: \u0026#34;2020-11-19\u0026#34;, \u0026#34;value\u0026#34;: 11 }, { \u0026#34;name\u0026#34;: \u0026#34;2020-11-07\u0026#34;, \u0026#34;value\u0026#34;: 15 }, { \u0026#34;name\u0026#34;: \u0026#34;2020-11-04\u0026#34;, \u0026#34;value\u0026#34;: 29 }, { \u0026#34;name\u0026#34;: \u0026#34;2020-11-03\u0026#34;, \u0026#34;value\u0026#34;: 41 }, { \u0026#34;name\u0026#34;: \u0026#34;2020-11-02\u0026#34;, \u0026#34;value\u0026#34;: 5 }, { \u0026#34;name\u0026#34;: \u0026#34;2020-11-01\u0026#34;, \u0026#34;value\u0026#34;: 17 }, { \u0026#34;name\u0026#34;: \u0026#34;2020-10-31\u0026#34;, \u0026#34;value\u0026#34;: 25 } ] その他 API実行回数の制限 大量のAPIリクエストの処理による高負荷状態を避けるために、REST APIの頻度制限(Rate Limit)をかけることもできます。システムコンソール \u0026gt; 環境 \u0026gt; 投稿頻度制限から設定を行えます。\n各言語向けDrivers Mattermost REST APIには各言語向けのDriverが存在します。GoとJavascriptについては、Mattermostが公式にサポートしています。 https://api.mattermost.com/#tag/drivers\n Go(公式): https://github.com/mattermost/mattermost-server/blob/master/model/client4.go Javascript(公式): https://github.com/mattermost/mattermost-redux/blob/master/src/client/client4.ts Python: https://github.com/Vaelor/python-mattermost-driver PHP: https://github.com/gnello/php-mattermost-driver Java: https://github.com/maruTA-bis5/mattermost4j  さいごに Mattermost REST APIの使い方について紹介しました。 明日は、WebSocket APIの使い方を紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day9-message-attachments/","title":"[Mattermost Integrations] Message Attachments","section":"post","date":"2020.12.09","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第9日目の記事です。\n本記事では、Mattermostの統合機能から投稿を作成する際に、視覚的にリッチな投稿を作成することができるMessage Attachmentsの機能について紹介します。\nhttps://docs.mattermost.com/developer/message-**attachments.html\nMessage Attachmentsの概要 Message AttachmentsはMattermost上に下記のような投稿を作成するための機能です。（画像は公式ドキュメントより）\nMattermostではデフォルトでMarkdown記法(設定によってはkatex記法も)をサポートしているため、簡単な見出しやリンクなどは普通の投稿で表すことができますが、多くの情報を通知したい場合、Markdownだと情報量の分だけ投稿が縦に伸びていってしまうため視認性が悪いという問題があります。 そのような場合にMessage Attachmentsを使うことで、より構造化された情報をMattermost上に投稿できるようになります。\nMessage Attachmentsは、今まで紹介してきたIncoming WebHookやSlash Command、今後紹介予定のREST APIやプラグインなど、Mattermostへ投稿を作成する多くの場合で使用することができます。今回は、Incoming WebHookを利用してMessage Attachmentsを作成する例を紹介していきます。\nMessage Attachmentsの作成 まず、Incoming WebHook(内向きのウェブフック)のおさらいです。 Incoming WebHookでは、ウェブフックのエンドポイントに下記のようなJSONデータを送信することで、Mattermostに投稿を作成することができました。\nBODY=\u0026#39;{ \u0026#34;text\u0026#34;: \u0026#34;Hello, Mattermost\u0026#34; }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr Message Attachmentsを使う場合、送信するJSONデータにattachmentというフィールドを追加します\nBODY=\u0026#39;{ \u0026#34;text\u0026#34;: \u0026#34;Hello, Mattermost\u0026#34;, \u0026#34;attachments\u0026#34;: [{ \u0026#34;color\u0026#34;: \u0026#34;#FF6600\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;message attachments\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;This is title\u0026#34;, \u0026#34;title_link\u0026#34;: \u0026#34;https://github.com/mattermost\u0026#34; },{ \u0026#34;color\u0026#34;: \u0026#34;#0066FF\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;message attachments2\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;This is title\u0026#34;, \u0026#34;title_link\u0026#34;: \u0026#34;https://github.com/mattermost\u0026#34; }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr 上記のコマンドを実行することで、通常のメッセージの下にMessage Attachmentsのメッセージが表示されます。\nattachmentsは複数指定することができ、複数指定した場合は上記のように縦に並んで表示されます。\n以降は、attachmenstに指定できるオプションと、その効果を紹介していきます。\nAttachments Options fallback メッセージが作成された際の通知メッセージを指定します。\nBODY=\u0026#39;{ \u0026#34;attachments\u0026#34;: [{ \u0026#34;fallback\u0026#34;: \u0026#34;This is fallback\u0026#34; }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr 何も指定しない場合はシステムデフォルトのメッセージが表示されます。\ncolor Message Attachmentsの左側に表示されるラインの色を指定します。\nBODY=\u0026#39;{ \u0026#34;attachments\u0026#34;: [{ \u0026#34;color\u0026#34;: \u0026#34;#FF6600\u0026#34; }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr pretext Message Attachments領域の上に表示されるテキストを指定します。Markdownや絵文字も使用できます。\nBODY=\u0026#39;{ \u0026#34;attachments\u0026#34;: [{ \u0026#34;pretext\u0026#34;: \u0026#34;This is `pretext`\u0026#34; }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr attachmentsと同時にtextフィールドを指定した場合、両方のテキストが表示されます。 また、attachmentsを複数指定していた場合、pretextはMessage Attachmentsの前にそれぞれ表示されます。\nBODY=\u0026#39;{ \u0026#34;text\u0026#34;: \u0026#34;This is `text`\u0026#34;, \u0026#34;attachments\u0026#34;: [{ \u0026#34;pretext\u0026#34;: \u0026#34;This is first `pretext`\u0026#34; },{ \u0026#34;pretext\u0026#34;: \u0026#34;This is second `pretext`\u0026#34; }] }\u0026#39; text Message Attachments領域内に表示されるテキストです。こちらもMarkdownや絵文字を利用可能です。\nBODY=\u0026#39;{ \u0026#34;attachments\u0026#34;: [{ \u0026#34;text\u0026#34;: \u0026#34;## This is `text` :smiley: \\n**Markdown** can be used.\u0026#34; }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr Author Details author_name / author_link / author_icon Message Attachmentsの作成者情報を指定します。\nBODY=\u0026#39;{ \u0026#34;attachments\u0026#34;: [{ \u0026#34;author_name\u0026#34;: \u0026#34;kaakaa\u0026#34;, \u0026#34;author_link\u0026#34;: \u0026#34;https://github.com/kaakaa\u0026#34;, \u0026#34;author_icon\u0026#34;: \u0026#34;https://blog.kaakaa.dev/images/avatar.png\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Author Details\u0026#34; }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr  author_name: attachmentsの上部に表示される作成者の名前を指定します author_link: attachmentsの上部に表示される作成者の名前をクリックしたときのリンクを指定します author_icon: attachmentsの上部に表示される作成者のアイコン画像のURLを指定します  Titles title / title_link BODY=\u0026#39;{ \u0026#34;attachments\u0026#34;: [{ \u0026#34;title\u0026#34;: \u0026#34;Attachment Title\u0026#34;, \u0026#34;title_link\u0026#34;: \u0026#34;https://github.com/kaakaa\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Titles\u0026#34; }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr  title: attachmentsの上部に表示されるタイトルを指定します title_link: attachmentsの上部に表示されるタイトルをクリックしたときのリンクを指定します  Author Detailsと同時に指定した場合は、下記のような見た目になります。\nFields title / value / short Message Attachmentsの内容を指定します。\nBODY=\u0026#39;{ \u0026#34;attachments\u0026#34;: [{ \u0026#34;text\u0026#34;: \u0026#34;Fields\u0026#34; \u0026#34;fields\u0026#34;: [{ \u0026#34;title\u0026#34;: \u0026#34;Short Field :one:\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;This is first **short** field. This is first **short** field. This is first **short** field. This is first **short** field. This is first **short** field. \u0026#34;, \u0026#34;short\u0026#34;: true }, { \u0026#34;title\u0026#34;: \u0026#34;Short Field :two:\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;This is second **short** field. This is second **short** field. This is second **short** field. This is second **short** field. This is second **short** field. \u0026#34;, \u0026#34;short\u0026#34;: true }, { \u0026#34;title\u0026#34;: \u0026#34;Long Field :one:\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;This is first **long** field. This is first **long** field. This is first **long** field. This is first **long** field. This is first **long** field. \u0026#34;, \u0026#34;short\u0026#34;: false }, { \u0026#34;title\u0026#34;: \u0026#34;Long Field :two:\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;This is second **long** field. This is second **long** field. This is second **long** field. This is second **long** field. This is second **long** field. \u0026#34;, \u0026#34;short\u0026#34;: false }], }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr  title: Fieldsのタイトル部分を指定します。絵文字を利用できます。 value: Fieldsのtitleに続く文字を指定します。Markdown形式で記述できます。 short: Fieldの長さをshortにするかどうかを指定します。\u0026quot;short\u0026quot;: trueを指定すると、１行に２つのFieldを表示できます。  Images image_url / thumb_url Message Attachmentに表示される画像のURLを指定します.\nBODY=\u0026#39;{ \u0026#34;attachments\u0026#34;: [{ \u0026#34;text\u0026#34;: \u0026#34;Images\u0026#34;, \u0026#34;fields\u0026#34;: [ {\u0026#34;title\u0026#34;: \u0026#34;Long Field\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;This is a long field\u0026#34;, \u0026#34;short\u0026#34;: false}, {\u0026#34;title\u0026#34;: \u0026#34;Short Field\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;This is a short field\u0026#34;, \u0026#34;short\u0026#34;: true}, {\u0026#34;title\u0026#34;: \u0026#34;Short Field\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;This is a short field\u0026#34;, \u0026#34;short\u0026#34;: true}, {\u0026#34;title\u0026#34;: \u0026#34;Short Field\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;This is a short field\u0026#34;, \u0026#34;short\u0026#34;: true} ], \u0026#34;image_url\u0026#34;: \u0026#34;https://blog.kaakaa.dev/images/avatar.png\u0026#34;, \u0026#34;thumb_url\u0026#34;: \u0026#34;https://blog.kaakaa.dev/images/avatar.png\u0026#34; }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr  image_url: textフィールドとfieldsフィールドの間に表示される画像のURLを指定します。バナーやチャートのような横長の画像を表示するのに適してします。 thumb_url: Message Attachmentsの右上端に表示される画像のURLを指定します。  Footer footer / footer_link Message Attachmentsのフッター情報を指定します。\nBODY=\u0026#39;{ \u0026#34;attachments\u0026#34;: [{ \u0026#34;text\u0026#34;: \u0026#34;Footer\u0026#34;, \u0026#34;footer\u0026#34;: \u0026#34;sample footer\u0026#34;, \u0026#34;footer_icon\u0026#34;: \u0026#34;https://blog.kaakaa.dev/images/avatar.png\u0026#34; }] }\u0026#39; curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;$BODY\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr 既知の問題 2020/11月時点では、下記の制限があります。\n Footerフィールドのタイムスタンプ(ts)に対応していない Message Attachmentの内容はMattermostの検索機能で検索できない  さいごに Message Attachmentsの基本的な使い方について紹介しました。 明日は、MattermostのREST APIについて紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day8-slash-command-spotify/","title":"[Mattermost Integrations] Slash Command 応用編","section":"post","date":"2020.12.08","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第8日目の記事です。\n本日の記事は、昨日まで紹介してきたSlash Commandを使ったサンプルアプリの紹介です。\n背景 コロナ影響によりWFH(Work From Home)が定着してきましたが、毎日自宅で作業していると同じ景色しか見えないため気持ちが滅入ってくることがあります。自分は少しでも日常に変化を付けようと音楽を流しながら作業していることが多いので、MattermostからSpotifyのプレイリストを探すことができる統合機能を作ってみました。（普段はAppleMusic派ですが\u0026hellip;）\n動作例 /music [search_term]で、[search_term]を検索キーとしてプレイリストを検索します。[search_term]を指定しない場合、workfromhomeを検索キーとして検索します。 コマンドを実行すると、見つかったプレイリストの情報をリンク付きでMattermostに投稿します。この時、card機能を使って投稿からプレイリストの内容を確認できるようにしています。\nコード ソースコードは下記のリポジトリにコミットしてあります。\nhttps://github.com/kaakaa/blog/tree/master/code/mattermost/2020-advent-calendar/slash-command-spotify\nMattermost連携部分の動作コードは下記になります。これとは別にSpotifyクライアント用のコードもありますが、そちらの紹介は割愛します。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/mattermost/mattermost-server/v5/model\u0026#34; ) const ( // (1) 定数の設定 \tMattermostToken = \u0026#34;arzoyh4i57dw5x57yumenuktqw\u0026#34; SpotifyClientID = \u0026#34;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\u0026#34; SpotifyClientSecret = \u0026#34;ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\u0026#34; ) func main() { // (2) Spotify クライアントの初期化 \tclient, err := NewSpotifyClient(SpotifyClientID, SpotifyClientSecret) if err != nil { log.Fatalf(\u0026#34;failed to set up spotify client: %s\u0026#34;, err.Error()) } http.HandleFunc(\u0026#34;/spotify\u0026#34;, func(w http.ResponseWriter, r *http.Request) { r.ParseForm() // (3) トークンによるリクエストの検証 \tif MattermostToken != r.Form.Get(\u0026#34;token\u0026#34;) { log.Printf(\u0026#34;received token is invalid: %s\u0026#34;, r.Form.Get(\u0026#34;token\u0026#34;)) return } // (4) serach_termの取得 \tterm := \u0026#34;workfromhome\u0026#34; if t := r.Form.Get(\u0026#34;text\u0026#34;); len(t) \u0026gt; 0 { term = t } // (5) プレイリストの検索 \tplaylist, err := client.findRandomPlaylist(term) if err != nil { io.WriteString(w, fmt.Sprintf(\u0026#34;failed to serach playlist: %s\u0026#34;, err.Error())) return } // (6) プレイリスト内のトラック情報の取得 \ttracks, err := client.getTracks(playlist.Id) if err != nil { io.WriteString(w, fmt.Sprintf(\u0026#34;failed to get tracks: %s\u0026#34;, err.Error())) return } contextInfo := []string{\u0026#34;Tracks\u0026#34;} for _, t := range tracks { contextInfo = append(contextInfo, fmt.Sprintf(\u0026#34;1. %s\u0026#34;, t)) } // (7) Mattermostへのレスポンスの構築 \tresponse := model.CommandResponse{ ResponseType: model.COMMAND_RESPONSE_TYPE_IN_CHANNEL, Username: \u0026#34;Music Provider\u0026#34;, Props: map[string]interface{}{ \u0026#34;card\u0026#34;: strings.Join(contextInfo, \u0026#34;\\n\u0026#34;), }, Attachments: playlist.ToMessage(), } w.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, response.ToJson()) }) // Start server \thttp.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } (1) 定数の設定 プログラム内で使用する定数を宣言しています。\nMattermost関係はSlash Commandから送信されるリクエスト検証用のトークン文字列。\nSpotifyは、アプリケーションのクライアントID/クライアントシークレットです。これらの値の取得方法については Spotify Developer Platform: Spotify APIアクセスしてデータ取得してみてみた - Qiita などを参照ください。Client Credential Flowで認証するため、Redirect URIなどの設定は必要無いかと思います。\n(2) Spotify クライアントの初期化 SpotifyのAPIを実行するためのインスタンスを構築しています。内容については割愛します。\n(3) トークンによるリクエストの検証 MattermostのCustom Slash Commandによるリクエストを受信したら、まずはトークンによる検証を行います。\n(4) serach_termの取得 Custom Slash Commandのリクエストから、Slash Commandの引数として指定されたテキストを取得します。これがSpotifyへの検索キーワードになります。 Custom Slash Commandのリクエスト内容については公式ドキュメントを参照ください。\n https://developers.mattermost.com/integrate/slash-commands/#basic-usage  (5) プレイリストの検索 (2) で初期化したSpotifyクライアントを使ってプレイリストの検索を行います。詳細は割愛しますが、Search for an Item | Spotify for DevelopersのAPIを実行し、ランダムに選んだ一つのプレイリストを返すようになっています。\n(6) プレイリスト内のトラック情報の取得 こちらもSpotifyクライアントを使って(5)で取得したプレイリストのトラックを取得しています。内部ではGet a Playlist\u0026rsquo;s Items | Spotify for DevelopersのAPIを実行しています。 一度のAPIリクエストで取得できる最大のトラックス数が100であり、100トラック以上あるプレイリストについては、最初の100トラックだけを取得しています。\n(7) Mattermostへのレスポンスの構築 今まで取得してきた情報を使ってMattermostへのレスポンスを構築しています。attachmentsフィールドはMessageAttachmentsの機能を使っていますが、MessageAttachmentsについては後日紹介します。\n さいごに 以上のように、Custom Slash Commandによるリクエストを受信したサーバーから、外部のAPIを実行し、結果をMattermostに返すようなアプリケーションを構築することができます。外部APIの実行に時間がかかる恐れがある場合は、Delayed Responseを利用するとSlash Commandを実行したユーザーへフィードバックをすぐに返せるため便利です。[Delayed Response]の機能については昨日の記事で紹介しました。\n明日は、Message Attachmentsについて紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day7-slash-command2/","title":"[Mattermost Integrations] Slash Command 発展編","section":"post","date":"2020.12.07","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第7日目の記事です。\n前回の記事では、Mattermostで/で始まるコマンドを実行することで、特定の処理を実行することができるSlash Commandの機能について紹介しました。また、Custom Slash Commandにより外部アプリケーションにリクエストを送信する方法を紹介しました。本記事では、Custome Slash Commandのリクエストが送信された外部アプリケーション側からMattermost側へ返却するレスポンス内容について紹介します。\nSlash Commandのレスポンスとして投稿を作成する Slash Commandによるリクエストを受け付けた外部アプリケーションから、レスポンスとしてMattermostに投稿を作成する方法について紹介します。\n以下のコードは昨日のコードにレスポンスを返すコードを追加したものです。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) const ( WebHookToken = \u0026#34;8w7foap4ufrsfczda8uez51yxo\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/command\u0026#34;, func(w http.ResponseWriter, r *http.Request) { log.Printf(\u0026#34;%#v\u0026#34;, r.Form) r.ParseForm() log.Printf(\u0026#34;token: %v\u0026#34;, r.Form.Get(\u0026#34;token\u0026#34;)) // (1) Tokenをチェック \tif r.Form.Get(\u0026#34;token\u0026#34;) != WebHookToken { log.Printf(\u0026#34;received an invalid request with token: %s\u0026#34;, r.Form.Get(\u0026#34;token\u0026#34;)) return } // (2) レスポンスとしてMattermostへ投稿を作成 \tw.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, fmt.Sprintf(`{\u0026#34;text\u0026#34;: \u0026#34;**%s**\u0026#34;}`, r.Form.Get(\u0026#34;text\u0026#34;))) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } Outgoing WebHookの時とほぼ同じですが、(1) でトークンを利用したリクエストの検証を行い、(2) でSlash Commandのレスポンスとして投稿を作成しています。レスポンスヘッダーへのContent-Type: application/jsonの設定は必須です。textフィールドに指定したメッセージがMattermostに投稿されます。\nこのサーバに対して/サンプルコマンド TESTというSlash Commandを送信した時の画面が下記になります。\n作成された投稿には、BOTというラベルに加え、(あなただけが見ることができます)というメッセージがついています。Slash Commandのレスポンスとして作成した投稿は、デフォルトではSlash Commandを実行したユーザーしか見ることができない投稿になり、他のユーザーからは見ることができません。チャンネルの全員が閲覧可能な投稿を作成するには、後述のresponse_typeパラメータを設定します。\nSlash Commandレスポンスパラメータ text 投稿されるメッセージであり、後述のattachmentsを指定しない場合は必須のパラメータです。Markdown記法や、@によるメンションを投稿することもできます。\nio.WriteString(w, `{\u0026#34;text\u0026#34;: \u0026#34;**TEST**\u0026#34;}`) response_type Slash Commandのレスポンスにより作成される投稿の種別を指定します。デフォルトではephemeralであり、Slash Commandを実行したユーザーにしか見えない投稿になります。チャンネル全員が見えるようにするにはresponse_typeにin_channelを指定します。\nio.WriteString(w, `{\u0026#34;text\u0026#34;: \u0026#34;**TEST**\u0026#34;, \u0026#34;response_type\u0026#34;: \u0026#34;in_channel\u0026#34;}`) username, icon_url Slash Commandのレスポンスとして作成される投稿のユーザー名とアイコンの表示を変更することができます。デフォルトでは、ウェブフックを作成したユーザーになります。\nこのパラメータを使用する場合、システムコンソールから下記の設定をそれぞれ有効にする必要があります。\n システムコンソール \u0026gt; 統合機能管理 \u0026gt; 統合機能によるユーザー名の上書きを許可する システムコンソール \u0026gt; 統合機能管理 \u0026gt; 統合機能によるプロフィール画像アイコンの上書きを許可する  （この設定を有効にすると、usernameとicon_urlを指定しない場合の投稿の作成者がデフォルトのアイコン、ユーザー名(webhook)に変更されます）\nio.WriteString(w, `{ \u0026#34;text\u0026#34;: \u0026#34;**TEST**\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;new-bot\u0026#34;, \u0026#34;icon_emoji\u0026#34;: \u0026#34;http://www.mattermost.org/wp-content/uploads/2016/04/icon_WS.png\u0026#34; }`) channel_id 投稿を作成するチャンネルを指定できます。ここで指定するチャンネルIDは、チャンネルメニュー \u0026gt; 情報を表示するから確認できます。\nio.WriteString(w, `{ \u0026#34;text\u0026#34;: \u0026#34;**TEST**\u0026#34;, \u0026#34;channel_id\u0026#34;: \u0026#34;u6ijofzg8bnsie5u8c1eumtc1h\u0026#34; }`) goto_location Slash Command特有のパラメータです。goto_locationフィールドにURLを指定しておくと、Slash Commandが実行された際に指定されたURLに移動します。この時textなどで指定した投稿も作成されます。\nio.WriteString(w, `{ \u0026#34;text\u0026#34;: \u0026#34;**TEST**\u0026#34;, \u0026#34;goto_location\u0026#34;: \u0026#34;https://github.com/mattermost\u0026#34; }`) goto_locationにはhttpsだけでなく、sshやmailtoのプロトコルも使用できるため、例えばスラッシュコマンドを実行した場合に「メーラーでメール作成画面を開く」というような動作をさせることも可能です。\nio.WriteString(w, `{ \u0026#34;text\u0026#34;: \u0026#34;**TEST**\u0026#34;, \u0026#34;goto_location\u0026#34;: \u0026#34;mailto:test@example.com\u0026#34; }`) attachments attachmentsは、Mattermostにリッチな投稿を作成することができるMessageAttachmentsを指定できる機能です。MessageAttachmentsについては、別途紹介記事を用意する予定です。\ntype typeは、Mattermostの投稿の種別を指定するパラメータですが、基本的に使用することはありません。Plugin(Webapp)にてプラグイン独自の投稿種別を指定した場合のみに使用するものかと思います。Plugin(Webapp)については、別途紹介記事を用意する予定です。\nextra_responses extra_responses配列としてレスポンスのJSONデータを記述することで複数の投稿を作成することができます。 extra_responsesが導入されるMattermost v5.6以前は、Slash Commandのレスポンスとして複数の投稿を作成したい場合はREST APIを実行するなどをしなくてはなりませんでしたが、extra_responsesによってREST APIを実行するためのコードなどが必要なくなりました。\nSlash Commandのリクエストに対して下記のレスポンスを返却すると、「チャンネル全員が閲覧できる投稿を作りつつ、コマンド実行ユーザーのみにしか見えない投稿も合わせて作成し、さらに、別のチャンネルにコマンドが実行されたことを通知する」ということができるようになります。\nio.WriteString(w, `{ \u0026#34;text\u0026#34;: \u0026#34;**TEST**\u0026#34;, \u0026#34;response_type\u0026#34;: \u0026#34;in_channel\u0026#34;, \u0026#34;extra_responses\u0026#34;: [ { \u0026#34;text\u0026#34;: \u0026#34;**Secret Info**\u0026#34; }, { \u0026#34;text\u0026#34;: \u0026#34;Notify in other channel\u0026#34;, \u0026#34;channel_id\u0026#34;: \u0026#34;u6ijofzg8bnsie5u8c1eumtc1h\u0026#34; } ] }`) extra_responses内にさらにextra_responsesを指定することはできず、また、goto_locationも使用できません。\nskip_slack_parsing Mattermostの統合機能はSlack記法との互換性を意識して作成されていますが、skip_slack_parsingにtrueを指定すると、レスポンスとして返却したtextをSlack互換の記法として解析しないようになります。あまり使うことは無いかと思いますが、レスポンスが想定どおりに投稿されない場合などに利用を検討してみても良いかもしれません。\nこのパラメータが追加されたきっかけとなったのは下記のIssueです。 slack-compatibility-layer seems to break results of MM-only integration · Issue #12702 · mattermost/mattermost-server\nprops Incoming WebHookなどと同様、投稿のメタデータを格納するフィールドです。Incoming WebHookと同様、cardも利用することができます。\nSlash Commandで時間のかかる処理を実行する場合 単にSlash Commandのレスポンスとして投稿を作成できるだけだと、外部アプリケーションで時間のかかる処理を実行し、その結果を返したいという場合、Mattermost上のユーザーはコマンドを実行してから結果が返るまで何の反応も得ることができません。それを回避するため、Slash Command実行時に送信されるリクエストには、レスポンスを一度返した後で投稿を作成ことができるURLであるresponse_urlフィールドを持っています。\nresponse_urlを使ったコードは下記のようになります。\npackage main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) const ( WebHookToken = \u0026#34;8w7foap4ufrsfczda8uez51yxo\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/command\u0026#34;, func(w http.ResponseWriter, r *http.Request) { r.ParseForm() if r.Form.Get(\u0026#34;token\u0026#34;) != WebHookToken { log.Printf(\u0026#34;received an invalid request with token: %s\u0026#34;, r.Form.Get(\u0026#34;token\u0026#34;)) return } w.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, `{\u0026#34;text\u0026#34;: \u0026#34;Request is recieved. Results will return later.\u0026#34;}`) // (1) 5秒後に \u0026#34;response_url\u0026#34; に対してリクエストを送信 \tgo func(url string) { time.Sleep(5 * time.Second) body := strings.NewReader(`{\u0026#34;text\u0026#34;: \u0026#34;This is the result.\u0026#34;, \u0026#34;response_type\u0026#34;: \u0026#34;in_channel\u0026#34;}`) http.Post(url, \u0026#34;application/json\u0026#34;, body) }(r.Form.Get(\u0026#34;response_url\u0026#34;)) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } 今までと同じようにレスポンスを返した後、5秒Sleepした後にresponse_urlのURLに対してリクエストを送信しています\nresponse_urlに送信するリクエストには、goto_locationは使えませんでしたが、response_typeやextra_responsesなどは使えるようです。\nまた、response_urlが有効なのは、元のSlash Commandが実行されてから30分間のみで、5つまでの投稿を作成することができます。処理が30分以上かかる場合や、5つ以上の投稿を作成したい場合は、REST APIを利用するか、Pluginを利用する必要がありそうです。\nさいごに 本日は、Slash Commandの詳細な使い方について紹介しました。 明日は、REST APIの使い方について紹介していきます。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day6-slash-command/","title":"[Mattermost Integrations] Slash Command 基本編","section":"post","date":"2020.12.06","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第6日目の記事です。\n本記事では、Mattermost上で任意のタイミングで特定の処理を実行できるSlash Command機能について紹介します。\nSlash Command概要 Slash Commandは、Mattermostの投稿入力欄で / で始まるコマンドを入力することで、特定の処理を実行できる機能です。 Slash Commandには、Mattermostにデフォルトで搭載されている**Built-in Slash Command（内蔵スラッシュコマンド）と、ユーザーが独自にカスタマイズできるCustom Slash Command（カスタムスラッシュコマンド）**があります。\n投稿入力欄に何も入力していない状態で/を入力すると、利用できるスラッシュコマンドの一覧が表示されます。\nSlash Commandに関する公式ドキュメントは下記になります。\n https://docs.mattermost.com/developer/slash-commands.html https://developers.mattermost.com/integrate/slash-commands/  一つ目の公式ドキュメントはSlash Command機能の概要について記述しており、二つ目のDeveloper Documentにはより細かい開発者向けの情報が書かれています。\nBuilt-in Slash Command Built-in Slash Commandとして使用できるスラッシュコマンドは、下記のドキュメントに記載されています。\nhttps://docs.mattermost.com/developer/slash-commands.html#built-in-commands\n数が多いので全ては紹介しませんが、個人的には /shortcut と /shrug をよく使います。\n/shortcutはMattermost上で使用できるショートカットを表示するコマンドです。ショートカットの中では、Ctrl + kによるチャンネル切り替えをよく使います。\n/shrugは、¯\\_(ツ)_/¯ を簡単に入力するためのコマンドです。なんだかよく分からないけど上手くいかなかった時などに使います。\nCustom Slash Command Custom Slash Commandは、ユーザーが独自のSlash Commandを作成できる機能です。Custom Slash Commandが実行されると、Custom Slash Command作成時に指定したURLへコマンド実行情報が送信されます。\nCustom Slash Commandは、外部アプリケーションにリクエストを送信するという点でOutgoing WebHookと似ていますが、ユーザーが明示的にコマンドを実行できる点や、Outgoing WebHookでは利用できなかった非公開チャンネルやダイレクトメッセージチャンネル内でも利用できるという点が異なります。\n設定 Custom Slash Commandを利用するには、システムコンソール \u0026gt; 統合機能管理 \u0026gt; カスタムスラッシュコマンドを有効にする の設定が有効になっている必要があります。\nまた、統合機能はデフォルトではシステム管理者とチーム管理者しか作成することができませんが、誰でも作成できるようにしたい場合、システムコンソール \u0026gt; 統合機能管理 \u0026gt; 統合機能の管理を管理者のみに制限するの設定を無効してください。\n作成 メインメニュー \u0026gt; 統合機能から統合機能の画面を開き、\nスラッシュコマンド \u0026gt; スラッシュコマンドを追加するから、新たなSlash Commandを追加します。\nSlash Commandの作成画面で入力する情報は下記の通りです。\n タイトル: ウェブフックの一覧ページに表示されるタイトルです 説明: ウェブフックの説明です コマンドトリガーワード: ここで指定したキーワードがスラッシュコマンド名として使われます。日本語も使用できます。 リクエストURL: リクエスト送信先のURLです リクエストメソッド: 送信されるリクエストをGET、POSTから選択できます 返信ユーザー名: Slash Command実行によって作成される投稿のユーザー名部分に表示される名前を指定できます 応答アイコン: Slash Command実行によって作成される投稿のユーザーアイコン部分に表示されるアイコン画像を指定できます 自動補完: 投稿入力欄に/を入力した時に表示されるSlash Command一覧画面にこのコマンドを表示するかどうかを選択できます。自動補完にチェックをした場合、Slash Command一覧に表示される自動補完のヒントと自動補完の説明を入力できるようになります。  Slash Commandの作成が完了すると、トークンが表示されます。このトークンは、Outgoing WebHookのトークンと同様、リクエストがMattermostから送信されたことを検証するために使われます。\n実行 Slash Commandを実行する前に、リクエスト送信先サーバーを立ち上げておく必要があります。 Outgoing WebHookの時と同様、送信されたリクエストのJSONボディをログ出力する簡単なサーバーを立ち上げておきます。Outgoing WebHookの時との違いは、送信されるリクエストボディの形式が異なるのと、エンドポイントを変更している点です。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/command\u0026#34;, func(w http.ResponseWriter, r *http.Request) { // (1) Formデータの読み込み \tr.ParseForm() log.Printf(\u0026#34;Request: %#v\u0026#34;, r.Form) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } (1) Slash Commandにより送信されるリクエストは、application/x-www-form-urlencoded形式で送信されるため、Formデータとして読み出しています。\n上記コードをmain.goとして保存し、go run main.goを実行してサーバーを立ち上げます。もし、MattermostサーバーとSlashCommandリクエスト受付用のサーバを同じマシン上で起動し、Outgoing WebHook作成時のコールバックURLにlocalhostのサーバーを指定している場合、システムコンソール \u0026gt; 開発者 \u0026gt; 信頼されていない内部接続を許可するにlocalhostを追加しておく必要があります。\n上記の設定が完了した後、Slash Commandを実行すると下記のようなリクエストの情報がコンソールに出力されます。\n$ go run main.go 2020/11/03 15:04:24 Request: url.Values{\u0026#34;channel_id\u0026#34;:[]string{\u0026#34;xxyu9xoref8mjgy3s9i5y7776y\u0026#34;}, \u0026#34;channel_name\u0026#34;:[]string{\u0026#34;slash-command\u0026#34;}, \u0026#34;command\u0026#34;:[]string{\u0026#34;/サンプルコマンド\u0026#34;}, \u0026#34;response_url\u0026#34;:[]string{\u0026#34;http://localhost:8065/hooks/commands/5xthz8jf67ggx8heopn1ay1tqe\u0026#34;}, \u0026#34;team_domain\u0026#34;:[]string{\u0026#34;test\u0026#34;}, \u0026#34;team_id\u0026#34;:[]string{\u0026#34;9d1xf4gg7fnibxs8fdw6fo5fre\u0026#34;}, \u0026#34;text\u0026#34;:[]string{\u0026#34;\u0026#34;}, \u0026#34;token\u0026#34;:[]string{\u0026#34;8w7foap4ufrsfczda8uez51yxo\u0026#34;}, \u0026#34;trigger_id\u0026#34;:[]string{\u0026#34;bm1udGhmOGs3ZmJmeGpmb3dnODZnY2NzaWU6ODd4OTN1bzhwZm56ZHJvOWt0Y21vYnBhMXI6MTYwNDM4MzQ2NDI4MTpNRVVDSUZ5Vjc0NmwrWWt3UVUrUkwrUzFaYWlTMStnYTZPa2ZsSzJtSTBBL2wzNThBaUVBOFpTY2hjblZLa05scVU0MVNmc2l0cEdGanpXWE9tREdKK2NTeUFiRURHYz0=\u0026#34;}, \u0026#34;user_id\u0026#34;:[]string{\u0026#34;87x93uo8pfnzdro9ktcmobpa1r\u0026#34;}, \u0026#34;user_name\u0026#34;:[]string{\u0026#34;kaakaa\u0026#34;}} このように、Slash Commandを実行することで外部アプリケーションへリクエストを送信することができます。外部アプリケーション側で、送信されたリクエストに応じた処理を実装することで、Mattermostから処理を起動したりすることができます。動作的にはOutgoing WebHookと似ていますが、Slash Commandはチーム内のどのチャンネルからも実行することができ、チャンネルやトリガーワードの設定も存在しないため作成者でなくても使いやすいという利点があります。 また、レスポンスによる投稿作成時に利用できる機能もOutgoing WebHookよりも多いですが、その辺りは明日の記事で紹介します。\nさいごに 本日は、Slash Commandの基本的な使い方について紹介しました。 明日は、Slash Commandのレスポンスとして利用できるパラメータについて紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day5-outgoing-webhook2/","title":"[Mattermost Integrations] Outgoing WebHook 発展編","section":"post","date":"2020.12.05","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第5日目の記事です。\n前回の記事では、Mattermostに投稿が作成された際に、その投稿情報を外部アプリケーションに送信することができるOutgoing WebHook(外向きのウェブフック)の機能について紹介しましたが、本記事はその続きです。Outgoing WebHookが送信された外部アプリケーションからMattermostへ投稿を作成する方法について紹介します。\nOutgoing WebHookのレスポンスとして投稿を作成する 昨日の記事では、Outgoing WebHookを受け取ってコンソールへ出力する例を紹介しましたが、受け取ったリクエストへのリクエストとしてJSONデータを返却することで、外部アプリケーションからMattermostへ投稿を作成することもできます。\n以下のコードは昨日のコードにレスポンスを返すコードを追加したものです。\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/mattermost/mattermost-server/v5/model\u0026#34; ) const ( WebHookToken = \u0026#34;9mgpebi9a7bq3qjedd1kt6mwtr\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/outgoing\u0026#34;, func(w http.ResponseWriter, r *http.Request) { defer r.Body.Close() b, _ := ioutil.ReadAll(r.Body) var payload model.OutgoingWebhookPayload json.Unmarshal(b, \u0026amp;payload) // (1) Tokenのチェック \tif payload.Token != WebHookToken { log.Printf(\u0026#34;received an invalid request with token: %s\u0026#34;, payload.Token) return } // (2) レスポンスとしてMattermostへ投稿を作成 \tw.Header().Add(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) io.WriteString(w, fmt.Sprintf(`{\u0026#34;text\u0026#34;: \u0026#34;Echo: %s\u0026#34;}`, payload.Text)) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } (1) では、トークンを利用したリクエストの検証を行っています。 (2) で、Outgoing WebHookのレスポンスとして投稿を作成しています。投稿を作成するには、ヘッダーにContent-Type: application/jsonを指定し、レスポンスボディにtextフィールドを含むJSONデータを指定します。ここでは、受け取ったメッセージをそのまま返しています。\nこのサーバに対してOutgoing WebHookを送信した時の画面が下記になります。\nOutgoing WebHookが送信されると、ユーザー名の横にBOTというラベルのついた投稿が作成されます。\nレスポンスボディのJSONに含めることができるパラメータは、3日目の記事で紹介したIncoming WebHook作成時のパラメータと多くが共通します。異なる点は下記です。\n icon_emojiは使用できない channelによる投稿先の設定はできない response_typeが指定できる  このうち、response_typeにcommentを指定した場合、Outgoing WebHookのきっかけとなった投稿への返信という形で投稿が作成されます。 先ほどのコードのレスポンス部分を下記のように変更し、\nio.WriteString(w, fmt.Sprintf(`{\u0026#34;text\u0026#34;: \u0026#34;Echo: %s\u0026#34;, \u0026#34;response_type\u0026#34;: \u0026#34;comment\u0026#34;}`, payload.Text)) Outgoing WebHookによるリクエストを送信すると、下記の通り元の投稿への返信として投稿が作成されます。\nさいごに 本日は、Outgoing WebHookの詳細な使い方について紹介しました。 明日からは、Slash Commandの使い方について紹介していきます。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day4-outgoing-webhook/","title":"[Mattermost Integrations] Outgoing WebHook 基本編","section":"post","date":"2020.12.04","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第4日目の記事です。\n本記事では、Mattermostから外部アプリケーションへ投稿内容を送信できるOutgoing WebHook（外向きのウェブフック）について紹介します。\nOutgoing WebHook概要 Outgoing WebHookは、Mattermostに投稿が作成された時にその投稿情報を外部アプリケーションへ送信するための機能です。\nOutgoing WebHookを使うことで、Mattermostで発生した投稿イベントを外部アプリケーションに通知することができます。\nOutgoing WebHookに関する公式ドキュメントは下記になります。\n https://docs.mattermost.com/developer/webhooks-outgoing.html https://developers.mattermost.com/integrate/outgoing-webhooks/  一つ目の公式ドキュメントはOutgoing WebHookの概要について記述しており、二つ目のDeveloper Documentにはより細かい開発者向けの情報が書かれています。\n設定 Outgoing WebHookを利用するには、システムコンソール \u0026gt; 統合機能管理 \u0026gt; 外向きのウェブフックを有効にする の設定が有効になっている必要があります。\nまた、統合機能はデフォルトではシステム管理者とチーム管理者しか作成することができませんが、誰でも作成できるようにしたい場合、システムコンソール \u0026gt; 統合機能管理 \u0026gt; 統合機能の管理を管理者のみに制限するの設定を無効してください。\n作成 メインメニュー \u0026gt; 統合機能から統合機能の画面を開き、\n外向きのウェブフック \u0026gt; 外向きのウェブフックを追加するから、新たなOutgoing WebHookを追加します。\nウェブフックの作成画面で入力する情報は下記の通りです。\n タイトル: ウェブフックの一覧ページに表示されるタイトルです 説明: ウェブフックの説明です コンテントタイプ: 外部アプリケーションに送信するデータの形式をapplication/x-www-form-urlencoded と application/json から選択できます チャンネル: ここで指定したチャンネルに投稿が作成されると、外部アプリケーションへのリクエストが送信されます。トリガーワードを指定した場合、チャンネルの指定は必須ではなくなります。非公開チャンネルやダイレクトメッセージチャンネルは指定できません。 トリガーワード: ここで指定したキーワードで始まる投稿が外部アプリケーションへ送信されます。チャンネルとトリガーワードを両方指定した場合、指定したチャンネル内のトリガーワードで始まる投稿のみが外部アプリケーションに送信されます。 トリガーとなる条件: トリガーワードと一致する条件を指定します。スペース区切りで最初の単語がトリガーワードと完全に一致するか、トリガーワードで始まるかを設定するものであるため、日本語の投稿を対象とする場合、最初の単語がトリガーワードで始まるに設定しておくと良いかと思います。 コールバックURL: リクエスト送信先のURLです。  Outgoing WebHookの作成が完了すると、トークンが表示されます。このトークンは、外部アプリケーションに対して送信されるリクエストに含まれる値であり、リクエストがMattermostから送信されたことを検証するために使われます。\n実行 Outgoing WebHookを実行する前に、リクエスト送信先サーバーを立ち上げておく必要があります。 今回は、送信されたリクエストのJSONボディをログ出力する簡単なサーバーを立ち上げておきます。\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/mattermost/mattermost-server/v5/model\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/outgoing\u0026#34;, func(w http.ResponseWriter, r *http.Request) { defer r.Body.Close() b, _ := ioutil.ReadAll(r.Body) // (1) `model.OutgoingWebhookPayload`によるリクエストの読み出し \tvar payload model.OutgoingWebhookPayload json.Unmarshal(b, \u0026amp;payload) log.Printf(\u0026#34;Request: %#v\u0026#34;, payload) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } (1) Outgoing WebHookにより送信されるJSONデータは、Mattermost本体の model.OutgoingWebhookPayload の形式で送信されるため、この構造体を利用してデータを変換しています。\n上記コードをmain.goとして保存し、go run mainを実行してサーバーを立ち上げます。MattermostサーバーとOutgoing WebHookリクエスト受付用のサーバを同じマシン上で起動し、Outgoing WebHook作成時のコールバックURLにlocalhostのサーバーを指定している場合、システムコンソール \u0026gt; 開発者 \u0026gt; 信頼されていない内部接続を許可するにlocalhostを追加しておく必要があります。\n上記の設定が完了した後、Outgoing WebHook作成時にチャンネルに指定したチャンネルに投稿を作成すると、\nOutgoing WebHookがサーバに送信され、下記のようなリクエストの情報がコンソールに出力されます。\n$ go run main.go 2020/11/03 00:10:30 Request: model.OutgoingWebhookPayload{Token:\u0026#34;9mgpebi9a7bq3qjedd1kt6mwtr\u0026#34;, TeamId:\u0026#34;9d1xf4gg7fnibxs8fdw6fo5fre\u0026#34;, TeamDomain:\u0026#34;test\u0026#34;, ChannelId:\u0026#34;9eexapjuabd89fzbwfajdqhwta\u0026#34;, ChannelName:\u0026#34;outgoing-webhook\u0026#34;, Timestamp:1604329830865, UserId:\u0026#34;87x93uo8pfnzdro9ktcmobpa1r\u0026#34;, UserName:\u0026#34;kaakaa\u0026#34;, PostId:\u0026#34;au6tf4hoebyeffiaw9h1w6rpaw\u0026#34;, Text:\u0026#34;こんにちは、テスト。\u0026#34;, TriggerWord:\u0026#34;こんにちは、\u0026#34;, FileIds:\u0026#34;\u0026#34;} リクエストに含まれるトークンの値(Token:\u0026quot;9mgpebi9a7bq3qjedd1kt6mwtr\u0026quot;)がOutgoing WebHook作成時に表示されていたトークンと同じものであることがわかります。\nこのように、Mattermostの投稿情報を外部アプリケーションへ送信することができます。外部アプリケーション側で、送信されたリクエストに応じた処理を実装することで、Mattermostから処理を起動したりすることができます。また、ウェブフックを受け取った外部アプリケーションから、再びMattermostへ投稿を作成したりすることもできますが、その辺りは明日の記事で紹介します。\nさいごに 本日は、Outgoing WebHookの基本的な使い方について紹介しました。 明日は、Outgoing WebHookに反応して外部アプリケーションからMattermostへ投稿を作成する方法について紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day3-incoming-webhook2/","title":"[Mattermost Integrations] Incoming WebHook 発展編","section":"post","date":"2020.12.03","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第3日目の記事です。\n前回の記事では、外部アプリケーションからMattermostの投稿を作成することができるIncoming WebHook(内向きのウェブフック)の機能について紹介しましたが、本記事はその続きです。Incoming WebHookを作成する際に利用できるパラメータについて紹介します。\nIncoming WebHookパラメータ text Incoming WebHookを通じて投稿するメッセージであり、後述のattachmentsを指定しない場合は必須のパラメータです。Markdown記法や、@によるメンションを投稿することもできます。\ncurl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#39;{\u0026#34;text\u0026#34;: \u0026#34;## Test\\n@channel\\n* foo\\n* bar\u0026#34;}\u0026#39; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr channel 投稿先のチャンネルを指定することができます。ここで指定するチャンネル名は、サイドバーに表示されているチャンネル表示名でなく、URLとして使われているチャンネル名になる点に注意が必要です。\nまた、@kaakaaのように、@+ユーザー名を指定するとDM(ダイレクトメッセージ)として投稿することも可能です。channelを指定しない場合、Incoming WebHook作成時に指定したデフォルトチャンネルに投稿されます。\ncurl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#39;{\u0026#34;text\u0026#34;: \u0026#34;Sample Message\u0026#34;, \u0026#34;channel\u0026#34;: \u0026#34;incoming-webhook\u0026#34;}\u0026#39; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr Incoming WebHook作成時にこのチャンネルに固定するにチェックをしていた場合、デフォルトのチャンネル以外に投稿しようとすると403エラーとなります。\n$ curl \\ \u0026gt; -H \u0026#34;Content-Type: application/json\u0026#34; \\ \u0026gt; -d \u0026#39;{\u0026#34;text\u0026#34;: \u0026#34;Sample Message\u0026#34;, \u0026#34;channel\u0026#34;: \u0026#34;incoming-webhook\u0026#34;}\u0026#39; \\ \u0026gt; http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr {\u0026#34;id\u0026#34;:\u0026#34;web.incoming_webhook.channel_locked.app_error\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;This webhook is not permitted to post to the requested channel.\u0026#34;,\u0026#34;detailed_error\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;request_id\u0026#34;:\u0026#34;qe3eyht563d1b8xani3g93dgfh\u0026#34;,\u0026#34;status_code\u0026#34;:403} username icon_url usernameとicon_urlのパラメータを指定することで、Incoming WebHookを実行して作成される投稿のユーザー名とアイコンの表示を変更することができます。デフォルトでは、ウェブフックを作成したユーザーになります。\nこのパラメータを使用する場合、システムコンソールから下記の設定をそれぞれ有効にする必要があります。\n システムコンソール \u0026gt; 統合機能管理 \u0026gt; 統合機能によるユーザー名の上書きを許可する システムコンソール \u0026gt; 統合機能管理 \u0026gt; 統合機能によるプロフィール画像アイコンの上書きを許可する  （この設定を有効にすると、usernameとicon_urlを指定しない場合の投稿の作成者がデフォルトのアイコン、ユーザー名(webhook)に変更されます）\ncurl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#39;{\u0026#34;text\u0026#34;: \u0026#34;Sample Message\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;new-bot\u0026#34;, \u0026#34;icon_url\u0026#34;: \u0026#34;http://www.mattermost.org/wp-content/uploads/2016/04/icon_WS.png\u0026#34;}\u0026#39; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr ユーザー名とプロフィール画像アイコンの上書きを許可すると、Incoming WebHook作成画面にもユーザー名、プロフィール画像の指定画面が現れるようになります。\nicon_emoji icon_urlでは、アイコン画像に使用する画像のURLを指定しましたが、icon_emojiを使うことでアイコン画像に絵文字を指定することもできます。\ncurl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#39;{\u0026#34;text\u0026#34;: \u0026#34;Sample Message\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;new-bot\u0026#34;, \u0026#34;icon_url\u0026#34;: \u0026#34;http://www.mattermost.org/wp-content/uploads/2016/04/icon_WS.png\u0026#34;, \u0026#34;icon_emoji\u0026#34;: \u0026#34;smiley\u0026#34;}\u0026#39; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr icon_urlとicon_emojiを同時に指定すると、icon_emojiの方が採用されるようです。\nattachments attachmentsは、Mattermostにリッチな投稿を作成することができるMessageAttachmentsを指定できる機能です。MessageAttachmentsについては、第9日目の記事で紹介します。\ntype typeは、Mattermostの投稿の種別を指定するパラメータですが、基本的に使用することはありません。Plugin(Webapp)にてプラグイン独自の投稿種別を指定した場合のみに使用するものかと思います。Plugin(Webapp)については、第20日目以降の記事で紹介します。\nprops propsは投稿のメタデータを格納する場所であり、他の統合機能から利用されることを想定して用意されており、基本的に決まったデータ構造などはありません。cardというパラメータのみ特別で、cardに格納されたテキストデータは、ウェブフックにより作成された投稿のコンテキストデータとしてMattermostの画面上で確認することができます。\ncurl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#39;{\u0026#34;text\u0026#34;: \u0026#34;Sample Message\u0026#34;, \u0026#34;props\u0026#34;: {\u0026#34;card\u0026#34;: \u0026#34;## Sample\\n* foo\\n* bar\u0026#34;}}\u0026#39; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr props.cardを指定して作成された投稿には、メッセージのヘッダ部分に i ボタンが表示されるようになり、i ボタンをクリックすると右サイドバーにprops.cardに指定したテキストが表示されます。props.cardにはMarkdownを使用することもできますが、@によるメンションは機能しません。(ユーザープロファイルの確認はできます)\nIncoming WebHookによる投稿が長くなってしまう場合などに有効だと思います。\nただし、cardによる投稿はモバイルアプリからは確認できない点に注意が必要です。また、cardはMattermost v5.14から利用可能です。\nさいごに Incoming WebHookの詳細な使い方について紹介しました。 明日からは、Outgoing WebHookについて紹介していきます。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day2-incoming-webhook/","title":"[Mattermost Integrations] Incoming WebHook 基本編","section":"post","date":"2020.12.02","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第2日目の記事です。\n本記事では、Mattermostの最も簡易な統合機能であるIncoming WebHook(内向きのウェブフック)機能について紹介します。\nIncoming WebHook Incoming WebHookは外部アプリケーションからMattermostの投稿を作成するための機能です。\nIncoming WebHookを使うことで、Mattermostの外側で発生したイベントを簡単にMattermost上に通知することができます。\nIncoming WebHookに関する公式ドキュメントは下記になります。\n https://docs.mattermost.com/developer/webhooks-incoming.html https://developers.mattermost.com/integrate/incoming-webhooks/  一つ目の公式ドキュメントはIncoming WebHookの概要について記述しており、二つ目のDeveloper Documentはより細かい開発者向けの情報が書かれています。\n設定 Incoming WebHookを利用するには、システムコンソール \u0026gt; 統合機能管理 \u0026gt; 内向きのウェブフックを有効にする の設定が有効になっている必要があります。\nまた、統合機能はデフォルトではシステム管理者とチーム管理者しか作成することができませんが、誰でも作成できるようにしたい場合、システムコンソール \u0026gt; 統合機能管理 \u0026gt; 統合機能の管理を管理者のみに制限するの設定を無効してください。\n作成 メインメニュー \u0026gt; 統合機能から統合機能の画面を開き、\n内向きのウェブフック \u0026gt; 内向きのウェブフックを追加するから、新たなIncoming WebHookを追加します。\nウェブフックの作成画面で入力する情報は下記の通りです。\n タイトル: ウェブフックの一覧ページに表示されるタイトルです 説明: ウェブフックの説明です チャンネル: チャンネル名を指定せずにIncoming WebHookを実行した場合、ここで指定したチャンネルに投稿が作成されます このチャンネルに固定する: このIncoming WebHookでは、チャンネルで指定したチャンネルにしか投稿を作成できなくなります  Incoming WebHookの作成が完了すると、WebHook実行時に指定するURLが表示されます。このURLに対してHTTPリクエストを送信することで、外部アプリケーションからMattermostに投稿を作成することができます。\n作成したIncoming WebHookは後で編集することも可能です。\n実行 今回は、curlコマンドを使って、定期的にマシンのDISK容量を通知するスクリプトを作ってみます。\nDISK=`df -h /System/Volumes/Data` curl \\  -H \u0026#34;Content-Type: application/json\u0026#34; \\  -d \u0026#34;{\\\u0026#34;text\\\u0026#34;: \\\u0026#34;${DISK}\\\u0026#34;}\u0026#34; \\  http://localhost:8065/hooks/ucw5qjw86jgeum77o1uw8197jr 先ほど生成されたWebHookのURLにtextフィールドを持つJSONを送信するだけで投稿を作成することができます。\ncurlコマンドを実行するスクリプトをcronなどで毎日定刻に実行することで、毎日ディスクの状況をチェックしたりすることができます。\nさいごに Incoming WebHookの基本的な使い方について紹介しました。 明日は、Incoming WebHook実行時のパラメータについて紹介します。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/advent-calendar-2020/day1-overview/","title":"Mattermost Integrationsアドベントカレンダーについて","section":"post","date":"2020.12.01","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\n本記事について Mattermostの統合機能アドベントカレンダーの第1日目の記事です。\n今日からMattermostの統合機能の開発方法について書いていきます。\nMattermost について Mattermostは、米国のMattermost Inc.が開発しているSlack AlternativeなチャットツールMattermostです。OSSとして開発が進められており、誰でも開発に参加することができます。\nhttps://github.com/mattermost\nAtlassian HipChat亡き後、オンプレミスで運用できるビジネスチャット基盤として勢力を伸ばしており、昨年には投資額が $50Mに達し、Y CombinatorのSeries B史上最大の投資額を得るなど、その規模を拡大しています。 YC leads $50M Series B in Mattermost as open source Slack alternative - Mattermost - Open Source, On-Prem or Private Cloud Messaging\n国内でも(自分の観測範囲だけでも)様々な企業・組織が採用しており、また、Mattermost Inc.と提携し、サービスを提供している企業もいくつもあります。\n Mattermost | aslead/アスリード | 野村総合研究所(NRI) Educhat Mattermost(企業向けコラボレーション チャットツール)｜ 製品 ｜ リックソフト   Mattermostはビジネスチャットの機能だけでも便利なのですが、さらに組織の要望に合わせたカスタマイズを行うことができます。このカスタマイズの方法は多岐に渡るのですが、まとまった情報が公式の英語ドキュメントしかなさそうなので情報源を増やすことを目的に記事を書いていこうと思います。各機能の解説というよりは、その機能を使ってどのようなことが出来るのかを実例と合わせて書いていきたいと思っています。\nまた、今回書いていく内容は、現在リリースされているMattermostの最新版 v5.28 で動作確認を行っているものであり、異なるバージョンを使っている場合は公式ドキュメントを参照することをオススメします。\n https://docs.mattermost.com/guides/integration.html https://developers.mattermost.com/integrate/getting-started/  概要 １日目の記事は、Mattermostの統合機能の全体像を紹介します。\nまず、Mattermost本体の機能は上図青い四角のMattermost ServerとMattermost Webappから成り、Mattermost Serverはデータの管理などのコアの機能を果たしており、Go言語で書かれています。Mattermost WebappはブラウザやデスクトップアプリのUIの部分であり、React/Reduxで書かれています。\nMattermost ServerとMattermost Webappの間は、初回こそHTTPでやりとりされますが、その後の通信は基本的にWebSocketで行われています。\nこのMattermostのコア機能に対して独自の処理を追加するための拡張ポイントとして、赤字で書かれたMattermostの統合機能があります。\n(1) Incoming WebHook (HTTP) Incoming WebHook（内向きのWebHook）は、外部アプリケーションからMattermostへ投稿をするためのエンドポイントを新たに作成する機能です。この新たに作成したエンドポイントに対して既定のJSONをHTTP POSTすることで、Mattermost外のアプリケーションから投稿が作成できます。\nIncoming Webhookについては第2,3日目の記事で紹介します。\n(2) Outgoing WebHook (HTTP) Outgoing WebHook（外向きのWebHook）は、Mattermost上でユーザーによって作成された投稿の情報を外部アプリケーションへ送信する機能です。Mattermost上での会話に応じて処理を行いたい場合などに使用します。\nOutgoing Webhookについては第4,5日目の記事で紹介します。\n(3) Slash Command (HTTP) Slash Commandは、(2) Outgoing WebHookと動作は似ていますが、ユーザーが/で始まる特殊なコマンドを投稿することで動作させることができる機能です。ユーザーの任意のタイミングで処理を実行させることができるため、Outgoing WebHookよりも使い勝手が良いです。\nSlash Commandについては、第6, 7, 8日目の記事で紹介します。\n(4) REST API (HTTP) REST API は、Mattermost上で管理されているリソースを取得、作成、更新、削除する機能です。一般的なREST APIです。HTTPによるリクエストだけでなく、Mattermost ServerとMattermost Webapp間でやりとりされるWebSocketを購読することもできます。\nREST APIについては、第10,11日目の記事で紹介します。\n(5) Plugin (Server) (RPC) Plugin(Server) はMattermost Serverの機能を拡張するための機能です。今まで紹介してきた機能は、基本的にHTTPを通じてMattermostと外部アプリケーションのやりとりを行う機能でしたが、Plugin(Server)は、Mattermostと同一サーバー上でRPCを通じてやりとりを行う機能です。今まで紹介してきた機能より、より多様なMattermost上のイベントとやりとりを行うことができます。\nPlugin (Server)については、第18, 19日目の記事で紹介します。\n(6) Plugin (Webapp) Plugin(Webapp)は、Mattermost Webappの機能を拡張するための機能です。ブラウザなどのクライアントアプリ上のMattermost画面の見え方を変えることができます。また、Plugin(Server)はMattermost Server上の全ユーザー共通の情報を扱う機能でしたが、Plugin(Webapp)により、ユーザーごとに異なる見え方を提供したりできます。\nPlugin (Webapp)については、第20,21日目の記事で紹介します。\n Mattermostの統合機能は大きくわけで以上の５つになるかと思います。また、統合機能とは別に統合機能から作成する投稿の見た目を変えるMessage AttachmentsやInteractiveMessageなどの機能もあるため、それらの機能についても触れていきます。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.28/","title":"Mattermost5.28の新機能","section":"post","date":"2020.10.23","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2020/10/15にMattermost v5.28.0がリリースされました。\n本記事は、個人的に気になった新しい機能などを動かしてみることを目的としています。（なので、Enterprise版限定の機能などについてはリリースノート書いてあることの紹介程度となっています）\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost Release v5.28 is now available - Mattermost - Open Source, On-Prem or Private Cloud Messaging Release v5.28 - Feature Release  また、mmctl コマンドとコンプライアンスエクスポート機能のバグFixが行われた v5.28.1 がリリースされています。\n Mattermost 5.28.1 and 5.27.1 released - Mattermost - Open Source, On-Prem or Private Cloud Messaging   新しく導入された機能のお知らせ Mattermostを新しいバージョンに上げた後にログインすると、新しいバージョンで利用可能なった機能などがMattermost上で通知されるようになりました。(v5.27からv5.28に上げた時は出てこなかったような? v5.26で導入されたチャンネルカテゴリの機能では表示されましたが。）\n(画像は公式ブログのもの)\nこの設定は システムコンソール \u0026gt; 通知 \u0026gt; エンドユーザー通知を有効にする からオフにすることもできます。\n(システムコンソールのサイドメニュー上に２つ「通知」の項目が存在してしまったため、下の方の設定（今回追加された機能に関する設定）の項目名を「お知らせ」に変更しました。v5.29から反映されると思います。)\nその他の新機能 bold / italic の入力簡易化 メッセージ入力欄で Ctrl + I を入力するとMarkdownのItalic記法が、Ctrl + b を入力するとMarkdownのBold記法が挿入されるようになりました。\nBleve検索でのワイルドカードのサポート v5.24でBleveを利用した全文検索機能がベータ版としてリリースされましたが、Bleveを利用した検索を行う際にワイルドカードを利用することができるようになりました。\n検索除外文字のみを指定した場合でも検索結果を返す 過去にIssueも立てていましたが、チャンネルと検索除外ワードのみを指定した場合に、検索結果が空になってしまう問題が解決しました。チャンネル内の検索除外ワードを含む投稿を除いた投稿が検索結果として返されるようになります。\n関連記事: Mattermostの検索機能についてちょっと調べた · kaakaa blog\n通知音の切り替え デスクトップ通知の通知音を変更できるようになりました。\n(E20) 管理者タスクを委譲するための新たな管理者ロールの導入 Enterprise E20 限定の機能です。\n管理者タスクを委譲しやすくするため、それぞれ細かい粒度の管理者権限を持つ新たな管理者ロール System Manger、 UserManage、 Read-only Adminが導入されました。\n以前のバージョンでは、システム管理者の権限を持つユーザーのみがシステムコンソールにアクセスしたり、管理者向けのコマンドを実行することができました。そのため、一部の管理者権限を他のユーザーに渡したい場合でも、全ての管理者権限を渡す必要がありました。 今回のバージョンから、以下のような管理者タスクを他のユーザーに委譲したい場合に、全ての管理者権限を渡すことなく権限を委譲することができるようになります。\n 管理タスクやユーザー管理の委譲 プラグイン管理の委譲 システムコンソールの読み取り専用権限 AD/LDAPやSAMLなどの認証管理やアクセスコントロールシステムへのアクセス権限 コンプライアンスレポートやコンプライアンス管理へのアクセス権限  今回新たに追加された管理者ロールが持つ権限について、詳しくは公式ブログや公式ドキュメントを確認してください。 Granular administrator roles for delegated administration (E20 Edition) Additional System Admin Roles (E20)\n今回新たに追加された管理者ロールは、システム管理者がコマンドラインツールであるmmctlを実行することで付与できます。\n(E10) AD/LDAP 証明書ベースの認証 Enterprise E10 限定の機能です。\nAD/LDAPと連携している場合に、クライアント証明書を利用してAD/LDAPディレクトリに対する認証を行うことができるようになりました。この追加の認証メカニズムにより、認証情報の誤用に対する保護を強化できます。\n証明書ベースの認証を有効にするには、システムコンソール \u0026gt; AD/LDAPから公開証明書と秘密鍵をアップロードしてください。\nその他の変更 GitHub Plugin v2.0 リリース Mattermost公式チームが開発を進めている GitHub Plugin v2.0 がリリースされました。 Github Plugin 2.0 Release - Mattermost\nGitHubプラグインでは、GitHubリポジトリのアクティビティを関連するMattermostへ通知したり、MattermostからIssueを作成するなど、MattermostとGitHubを使っている場合に便利な機能が利用可能になります。\nその他、プラグインを含むMattermostとの連携機能については Mattermost Integrations - Powerful integrations to help your team do better work, faster. にまとまっています。\nmmctl の TLS1.0, 1.1 サポートについて 2021/1/16リリース予定の Mattermost v5.31 から、Mattermostの管理者向けコマンドラインツールであるmmctl を用いてTLS1.0, 1.1 を利用しているMattermostサーバーに対して操作を行おうとすると、エラーを返すようになります。オプションを指定することで利用し続けることも可能ですが、TLS1.0, 1.1は多くのブラウザでdeprecatedとなっているため、TLS1.2以降へのアップグレードを推奨します。\n破壊的変更  Mattermostがクラッシュした時に coredump が生成されるようになりました  おわりに 次のv5.29のリリースは2020/11/16(Mon)を予定しています。 そして機能追加が行われるv5.30は恐らく2020/12/16(Wed)のリリースになるかと思います。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.26/","title":"Mattermost5.26の新機能","section":"post","date":"2020.08.16","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2020/8/14にMattermost v5.26.0がリリースされました。\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost Release v5.26 is now available - Mattermost - Open Source, On-Prem or Private Cloud Messaging Mattermost Changelog — Mattermost 5.26 documentation   (実験的な機能) チャンネルのカテゴリ化と順序の入れ替え Mattermostにもチャンネルのカテゴリ化の機能が追加されました！ 🎉\nMattermostでは最近チャンネルサイドバーの改善が行われていますが、ついにチャンネルをカテゴリ毎にまとめる機能が（実験的な機能としてではありますが）使えるようになりました。\n設定方法 システムコンソール \u0026gt; 実験的機能 \u0026gt; 機能 \u0026gt; 実験的なサイドバー機能 を 有効化 に設定する必要があります。実験的なサイドバー機能はユーザー毎にOn/Offの切り替えが可能であり、システムコンソールで有効化 (デフォルト On) に設定するとサーバー上の全てのユーザーに対して実験的なサイドバー機能を On にすることができ、有効化 (デフォルt Off) にするとユーザー自身で有効化しない限り 実験的なサイドバー機能 は Onになりません。\nシステムコンソールで 実験的なサイドバー機能 が 有効化 (デフォルト On) もしくは 有効化 (デフォルト Off) に設定されている場合、ユーザーは アカウント設定 \u0026gt; サイドバー \u0026gt; 実験的なサイドバー機能 から、機能のOn/Offを切り替えることができます。\n機能を有効にすると、Mattermostの画面にカテゴリの作成方法に関するポップアップが表示されます。\nカテゴリ作成 実験的なサイドバー機能を有効にしてから、サイドバーの チャンネルセクションの横にある ... をクリックし、新しいカテゴリを作成するをクリックすることでカテゴリを作成することができます。\nカテゴリを作成したら、サイドバーにある各チャンネルをドラッグ＆ドロップすることで、カテゴリにチャンネルを追加していくことができます。（カテゴリに追加するだけでなく、ドラッグ＆ドロップ操作でチャンネルの順序を入れ替えることもできるようになっています）\n（画像は公式ブログから）\nカテゴリ名の部分をクリックすることで、カテゴリに追加されたチャンネルの表示・非表示を切り替えることができ、チャンネルを非表示にした状態でも未読の投稿があるとチャンネル名が表示されるようです。（未読であってもチャンネル名を表示したくない場合もある気がしますが、その場合は優先度の低いチャンネルのカテゴリを作って、そのカテゴリを一番下に持っていくなどの対応が必要そうです）\nその他、チャンネル名の横にあるメニューからも、様々な操作が可能になっているようです。\nダイレクトメッセージの表示順変更 また、ダイレクトメッセージチャンネルの表示順を「新しい順」と「アルファベット順」で切り替えることができるようになっています。\nチャンネルサイドバー改善作業の今後 チャンネルサイドバー改善については公式ブログの下記エントリにまとめられています。 https://mattermost.com/blog/upcoming-channel-sidebar-features/\n今後の改善としては、2020年中にカテゴリのミュート機能とダイレクトメッセージの新しい順でのソート機能（今回追加されたもの？）が予定されており、さらに2020年中に実験的な機能から正式な機能への格上げが予定されているようです。\n  Phase 1 (v5.22): Unreads filtering, collapsible favorites, public, private, and direct message categories Phase 2 (v5.26): User-defined custom categories with drag \u0026amp; drop of channels and categories, quick access menus Phase 3 (Q4 2020): Muting categories, direct message recency sorting Phase 4 (Q4 2020): General availability (i.e., remove the experimental config setting and release these features to all users)   Enterprise版の改善 （Enterprise版の機能は動作確認が取れる環境がないので伝聞調の書き方になります\u0026hellip;）\n(E20) チャンネルのアーカイブ・復元がシステムコンソールから可能に チャンネルのアーカイブ、アーカイブされたチャンネルの復元が、システムコンソールから実行可能になったようです。\n（画像は公式ブログから）\n(E20) システムコンソールでのメンバー・チャンネルの チームメンバ管理、チャンネルメンバ管理ページで、ユーザーを役割(ゲスト、システム管理者、等)でフィルタリング可能になったようです。 また、チャンネル管理画面では、チャンネルのタイプ(公開チャンネル、非公開チャンネル、AD/LDAPグループと同期したチャンネル、等)でフィルタリング可能になったようです。 （画像は公式ブログから）\n(E20) ログ設定のカスタマイズ Mattermostが出力するログについて、出力先をコンソール、ファイル、syslog、 TCPから選択できるようになり、さらにそれぞれの出力先に対して異なるログレベルを設定するなど柔軟なログ出力の設定が可能になったようです。\n設定方法については公式ドキュメントを参照ください。 https://docs.mattermost.com/administration/config-settings.html#output-logs-to-multiple-targets\n(E20・ベータ版) モバイルアプリからもAD/LDAPグループへのメンションが利用可能に モバイルアプリからも、メンションするAD/LDAPグループの補完、グループメンバーメンションのハイライト、5人以上が属するグループへメンションする際の警告ダイアログが利用可能になったようです。\nその他の変更 Ask the community リンクの追加 Mattermostのヘッダ部分にヘルプアイコンが追加され、そこからMattermostチームが利用している公式インスタンスの Peer-to-peer Help チャンネルへ移動できるようになりました。\n(画像中に翻訳ミスの部分がありますが修正しておきます\u0026hellip;)\nPeer-to-peer Helpチャンネルでは、やりとりは基本的に英語ですが、開発チームも見ているチャンネルのため素早い回答が期待できるのではないかと思います。\nまた、Mattermostは質問用のフォーラムも運用してしおり、こちらからも質問を投稿することができます。 https://forum.mattermost.org/\n上記フォーラムも基本的に英語でやりとりが行われていますが、一応、日本語のフォーラムもあります。（あまり利用されてはいないですが\u0026hellip;） https://forum.mattermost.org/c/international/japanese/29\nPostgreSQL 10のサポート 今までサポート対象だったPostgreSQL 9.4のLTSが2020年2月に終了したことを受け、Mattermostも5.26から公式にPostgreSQL 10をサポートするようになりました。今後もMattermost v5系はPostgreSQL 9.4でも動作可能となりますが、Mattermost v6.0(リリース時期未定)ではPostgreSQL 9.4はサポート対象外となる予定です。\n破壊的変更  Mattermost v5.26では、Elasticsearchのインデックスを再作成する必要があるそうです Gossipプロトコルを使用したクラスター間の通信を暗号化するオプションが追加されたそうです  おわりに 次のv5.27のリリースは2020/9/16(Wed)を予定しています。 そして機能追加が行われるv5.28は恐らく2020/10/16(Fri)のリリースになるかと思います。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/tech/drawio-png-ext/","title":"*.drawio.png と *.drawio.svg とはなんなのか","section":"post","date":"2020.07.28","body":"VS Code Draw.io Integrationの画像エクスポート機能 数ヶ月前に、VS CodeのDraw.io Integrationが話題になりました。\nVSCodeでDraw.ioが使えるようになったらしい！ - Qiita\nただ、上記の記事にもあるようにエクスポート機能はv0.4.0から無効化されており、エクスポート機能を利用するにはオンライン版のDraw.ioに繋がないといけないという本末転倒な状況になっているようです。\nせっかくエディタ内でドキュメントと作図が完結しそうという素敵な体験にあと一歩というところなので、*.drawioファイルを一括で画像ファイルに変換するスタンドアロンのツールを作ってみたり（kaakaa/dio-exporter）もしましたが、もっと良い方法があったようです。\n*.drawio.png と *.drawio.svg Visual Studio Code - *.drawio.svg や *.drawio.png の衝撃 - anfangd\u0026rsquo;s blog\nこちらの記事で知ったのですが、ファイルを*.drawio.svgや*.drawio.pngという拡張子で保存すると、Draw.ioで開くことができ、かつSVG/PNGファイルとして扱うことができるようです。\n公式リポジトリの方にも記述がありました。\nhttps://github.com/hediet/vscode-drawio#editing-drawiosvgdrawiopng-files\n You can directly edit and save .drawio.svg and .drawio.png files. These files are perfectly valid svg/png-images that contain an embedded Draw.io diagram. Whenever you edit such a file, the svg/png part of that file is kept up to date.\n なぜ、そんなことができるのかを調べてみました。\nなぜ画像ファイルとしてもDraw.ioとしても開けるのか *.drawio.png or *.dio.png Draw.ioには、extractGraphModelFromPngというメソッドがあり、このメソッドにPNGファイルからDraw.ioのグラフモデルを取得する処理が書かれているようです。\nhttps://github.com/jgraph/drawio/blob/a579fe9c094510093db631283166f35588848113/src/main/webapp/js/diagramly/Editor.js#L1547\nEditor.extractGraphModelFromPng = function(data) { var result = null; ... (snip) ... EditorUi.parsePng(binary, mxUtils.bind(this, function(pos, type, length) { var value = binary.substring(pos + 8, pos + 8 + length); if (type == \u0026#39;zTXt\u0026#39;) { var idx = value.indexOf(String.fromCharCode(0)); if (value.substring(0, idx) == \u0026#39;mxGraphModel\u0026#39;) { // Workaround for Java URL Encoder using + for spaces, which isn\u0026#39;t compatible with JS  var xmlData = pako.inflateRaw(value.substring(idx + 2), {to: \u0026#39;string\u0026#39;}).replace(/\\+/g,\u0026#39; \u0026#39;); if (xmlData != null \u0026amp;\u0026amp; xmlData.length \u0026gt; 0) { result = xmlData; } } } // Uncompressed section is normally not used  else if (type == \u0026#39;tEXt\u0026#39;) { var vals = value.split(String.fromCharCode(0)); if (vals.length \u0026gt; 1 \u0026amp;\u0026amp; (vals[0] == \u0026#39;mxGraphModel\u0026#39; || vals[0] == \u0026#39;mxfile\u0026#39;)) { result = vals[1]; } } if (result != null || type == \u0026#39;IDAT\u0026#39;) { // Stops processing the file as our text chunks  // are always placed before the data section  return true; } })); ... (snip) ... PNGファイルのzTXtチャンク、もしくはtEXtチャンクからグラフモデルを読み出しているようです。\n実際に、適当な*.dio.pngファイルを作って中身をみてみます。 以下のコードは PNGを読む - Qiita を参考にしました。\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;os\u0026#34; ) func parse(r io.Reader) (err error) { buffer := new(bytes.Buffer) _, err = buffer.ReadFrom(r) if err != nil { return err } if string(buffer.Next(8)) != \u0026#34;\\x89PNG\\r\\n\\x1a\\n\u0026#34; { return fmt.Errorf(\u0026#34;not a PNG\u0026#34;) } data := make([]byte, 0, 32) loop := true for loop { length := int(binary.BigEndian.Uint32(buffer.Next(4))) chunkType := string(buffer.Next(4)) switch chunkType { case \u0026#34;zTXt\u0026#34;: fmt.Println(\u0026#34;chunk: zTXt\u0026#34;) data = append(data, buffer.Next(length)...) _ = buffer.Next(4) // CRC  case \u0026#34;tEXt\u0026#34;: fmt.Println(\u0026#34;chunk: tEXt\u0026#34;) data = append(data, buffer.Next(length)...) _ = buffer.Next(4) // CRC  case \u0026#34;IEND\u0026#34;: fmt.Println(\u0026#34;chunk: IEND\u0026#34;) loop = false default: fmt.Println(\u0026#34;chunk:\u0026#34;, chunkType) _ = buffer.Next(length) // chunk data  _ = buffer.Next(4) // CRC  } } d, _ := url.QueryUnescape(string(data)) fmt.Println(d) return nil } func main() { imageFile := \u0026#34;test.dio.png\u0026#34; file, err := os.Open(imageFile) if err != nil { fmt.Println(err) return } defer file.Close() err = parse(file) if err != nil { fmt.Println(err) return } fmt.Println(\u0026#34;Complete\u0026#34;) } 実行結果は下記になります。\n$ go run main.go chunk: IHDR chunk: tEXt chunk: IDAT chunk: IEND mxfile\u0026lt;mxfile host=\u0026quot;8ce946a9-c68b-479a-941a-3275fc70c066\u0026quot; modified=\u0026quot;2020-07-28T13:37:16.115Z\u0026quot; agent=\u0026quot;5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Code/1.47.0 Chrome/78.0.3904.130 Electron/7.3.2 Safari/537.36\u0026quot; version=\u0026quot;13.1.3\u0026quot; etag=\u0026quot;9Ipt2ayCl9tVzXnOHPW3\u0026quot; pages=\u0026quot;2\u0026quot;\u0026gt;\u0026lt;diagram id=\u0026quot;TjNWy2FeEwpBci7nIAZN\u0026quot; name=\u0026quot;ページ1\u0026quot;\u0026gt;\u0026lt;mxGraphModel dx=\u0026quot;630\u0026quot; dy=\u0026quot;380\u0026quot; grid=\u0026quot;1\u0026quot; gridSize=\u0026quot;10\u0026quot; guides=\u0026quot;1\u0026quot; tooltips=\u0026quot;1\u0026quot; connect=\u0026quot;1\u0026quot; arrows=\u0026quot;1\u0026quot; fold=\u0026quot;1\u0026quot; page=\u0026quot;1\u0026quot; pageScale=\u0026quot;1\u0026quot; pageWidth=\u0026quot;827\u0026quot; pageHeight=\u0026quot;1169\u0026quot; math=\u0026quot;0\u0026quot; shadow=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;root\u0026gt;\u0026lt;mxCell id=\u0026quot;0\u0026quot;/\u0026gt;\u0026lt;mxCell id=\u0026quot;1\u0026quot; parent=\u0026quot;0\u0026quot;/\u0026gt;\u0026lt;mxCell id=\u0026quot;2\u0026quot; value=\u0026quot;TEST\u0026quot; style=\u0026quot;rounded=0;whiteSpace=wrap;html=1;\u0026quot; vertex=\u0026quot;1\u0026quot; parent=\u0026quot;1\u0026quot;\u0026gt;\u0026lt;mxGeometry x=\u0026quot;260\u0026quot; y=\u0026quot;170\u0026quot; width=\u0026quot;120\u0026quot; height=\u0026quot;60\u0026quot; as=\u0026quot;geometry\u0026quot;/\u0026gt;\u0026lt;/mxCell\u0026gt;\u0026lt;/root\u0026gt;\u0026lt;/mxGraphModel\u0026gt;\u0026lt;/diagram\u0026gt;\u0026lt;diagram id=\u0026quot;R911WMiv1Lcx-Wbf2GqR\u0026quot; name=\u0026quot;ページ2\u0026quot;\u0026gt;\u0026lt;mxGraphModel dx=\u0026quot;630\u0026quot; dy=\u0026quot;380\u0026quot; grid=\u0026quot;1\u0026quot; gridSize=\u0026quot;10\u0026quot; guides=\u0026quot;1\u0026quot; tooltips=\u0026quot;1\u0026quot; connect=\u0026quot;1\u0026quot; arrows=\u0026quot;1\u0026quot; fold=\u0026quot;1\u0026quot; page=\u0026quot;1\u0026quot; pageScale=\u0026quot;1\u0026quot; pageWidth=\u0026quot;827\u0026quot; pageHeight=\u0026quot;1169\u0026quot; math=\u0026quot;0\u0026quot; shadow=\u0026quot;0\u0026quot;\u0026gt;\u0026lt;root\u0026gt;\u0026lt;mxCell id=\u0026quot;fRIcQMW-JuJCGEe4Us9i-0\u0026quot;/\u0026gt;\u0026lt;mxCell id=\u0026quot;fRIcQMW-JuJCGEe4Us9i-1\u0026quot; parent=\u0026quot;fRIcQMW-JuJCGEe4Us9i-0\u0026quot;/\u0026gt;\u0026lt;mxCell id=\u0026quot;fRIcQMW-JuJCGEe4Us9i-2\u0026quot; value=\u0026quot;HOGE\u0026quot; style=\u0026quot;ellipse;whiteSpace=wrap;html=1;\u0026quot; vertex=\u0026quot;1\u0026quot; parent=\u0026quot;fRIcQMW-JuJCGEe4Us9i-1\u0026quot;\u0026gt;\u0026lt;mxGeometry x=\u0026quot;260\u0026quot; y=\u0026quot;160\u0026quot; width=\u0026quot;120\u0026quot; height=\u0026quot;80\u0026quot; as=\u0026quot;geometry\u0026quot;/\u0026gt;\u0026lt;/mxCell\u0026gt;\u0026lt;/root\u0026gt;\u0026lt;/mxGraphModel\u0026gt;\u0026lt;/diagram\u0026gt;\u0026lt;/mxfile\u0026gt; Complete 実行結果を見ると、Draw.ioのグラフモデルは zTXtチャンク ではなく tEXtチャンク として保存されているようです。 tEXtチャンクの中身は、XML要素ではないmxfileというワードで始まっていることと、パーセントエンコードされていること以外は、Draw.ioのデータ保存形式と同じように見えます。実際、先頭のmxfileを外したXMLをファイルに保存し、Draw.io Integrationで開いてみたところ問題なく開けました。\n Draw.ioのコード内では、tEXtチャンクは基本的に使われないだろうというコメントが書かれています。\n// Uncompressed section is normally not used else if (type == 'tEXt') しかし、VS Code Draw.io Integrationで*.drawio.pngファイルを作成した場合は、そのtEXtチャンクにデータが保存されています。 個人的な予想ですが、エディタでの操作だと保存回数が多くなるため、保存のたびに圧縮をかける必要のあるzTXtチャンクでは保存操作に対するレスポンスが悪くなる恐れがあるため、tEXtチャンクを採用しているのではないかと思っています。\n*.drawio.svg or *.dio.svg SVGファイルの中身はXMLファイルなので、テキストファイルとして開けば \u0026lt;svg\u0026gt; タグの content属性の値として、HTMLエンコードされたDraw.ioのグラフモデルが格納されていることがわかります。\n\u0026lt;svg xmlns=\u0026quot;http://www.w3.org/2000/svg\u0026quot; xmlns:xlink=\u0026quot;http://www.w3.org/1999/xlink\u0026quot; version=\u0026quot;1.1\u0026quot; width=\u0026quot;121px\u0026quot; height=\u0026quot;81px\u0026quot; viewBox=\u0026quot;-0.5 -0.5 121 81\u0026quot; content=\u0026quot;\u0026amp;lt;mxfile host=\u0026amp;quot;40cbe15d-9605-4d22-a796-b079811d4635\u0026amp;quot; modified=\u0026amp;quot;2020-07-28T13:50:29.983Z\u0026amp;quot; agent=\u0026amp;quot;5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Code/1.47.0 Chrome/78.0.3904.130 Electron/7.3.2 Safari/537.36\u0026amp;quot; etag=\u0026amp;quot;dN67jIN7lHvydTadAscc\u0026amp;quot; version=\u0026amp;quot;13.1.3\u0026amp;quot; pages=\u0026amp;quot;2\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;diagram id=\u0026amp;quot;6hGFLwfOUW9BJ-s0fimq\u0026amp;quot; name=\u0026amp;quot;Page-1\u0026amp;quot;\u0026amp;gt;jZJNb8MgDIZ/DfcQtq69Luu2y06ptDMKXkAicUTJkuzXjwyTD1WVdsJ+bIP9YiaKZnxzstMfqMCyPFMjEy8szznPsnDMZIpEnB4iqJ1RlLSC0vwAQaqre6Pgukv0iNabbg8rbFuo/I5J53DYp32h3b/ayRpuQFlJe0s/jfI60mP+tPJ3MLVOL/PDKUYamZJpkquWCocNEmcmCofoo9WMBdhZvKRLrHu9E10ac9D6/xTkseBb2p5mu5zLC/XmpzSww75VMNdkTDwP2ngoO1nN0SF8cWDaNzZ4PJh0JTgP4922+DJs2BLABrybQgoViEfShxaEH8kfVrl50lBvpD4Qk/TD9XL1KkIwSIfkrnr/xTZbK86/\u0026amp;lt;/diagram\u0026amp;gt;\u0026amp;lt;diagram id=\u0026amp;quot;KO23mSEetFSPKnzUMudc\u0026amp;quot; name=\u0026amp;quot;ページ2\u0026amp;quot;\u0026amp;gt;rZNNT4QwEIZ/DcdNKNX9OK4sLhdjIgejt0pnaZNCSbcrsL/eYocv92BMPNF5Zvq2fWcIaFy2R8Nq8aQ5qCAKeRvQQxBFhISh+/Sk84Tu7jwojORYNIFMXgEh7isuksN5UWi1VlbWS5jrqoLcLhgzRjfLspNWy1NrVsANyHKmbumr5FZ4uo02E09BFmI4max3PlOyoRhfchaM62aGaBLQ2Ght/apsY1C9eYMvody/vL1/HNr0tE6S+CpWe7nyYo9/2TI+wUBl/1eaeulPpi7oV/p8TPC9thtMdEquXy54aIS0kNUs7zONGxnHhC2Vi4hbohwYC+0P/3+5PBkddaMIugRrOrcPVeg9NgGnkGwwbqaekqFRYtbPLTKGY1SM0pNVboFuDeHU1O/c7NegyRc=\u0026amp;lt;/diagram\u0026amp;gt;\u0026amp;lt;/mxfile\u0026amp;gt;\u0026quot; \u0026gt; \u0026lt;defs/\u0026gt; \u0026lt;g\u0026gt; \u0026lt;ellipse cx=\u0026quot;60\u0026quot; cy=\u0026quot;40\u0026quot; rx=\u0026quot;60\u0026quot; ry=\u0026quot;40\u0026quot; fill=\u0026quot;#ffffff\u0026quot; stroke=\u0026quot;#000000\u0026quot; pointer-events=\u0026quot;all\u0026quot;/\u0026gt; \u0026lt;g transform=\u0026quot;translate(-0.5 -0.5)\u0026quot;\u0026gt; \u0026lt;switch\u0026gt; ... (snip) ... 懸念点 *.drawio.png、*.drawio.svg形式で保存することで、画像ファイルとしても扱えますし、Draw.ioで開けば追加で編集も加えられるとても便利なファイルを作成することができます。しかし、いくつか懸念すべき点があります。\nファイルサイズが大きくなる *.drawio.pngや*.drawio.svgは、画像ファイルとしてのデータとDraw.ioとしてのデータの両方を持つことになるため、どうしてもファイルサイズは大きくなってしまいます。また、VS Code Draw.io Integrationで作成すると、Draw.ioのデータは圧縮されずに tEXt チャンクに格納されるため、その点でもファイルサイズを低減できていません。 Webページに使用するなど、容量にシビアな環境では画像ファイルとしてエクスポートし直す必要がありそうです。\n複数ページを扱うことはできない Draw.ioでは一つのファイルに複数ページ(タブ)を作成することができますが、画像として参照できるのは１ページのみです。（おそらく最初のページ） 複数ページの存在するDraw.ioファイルを画像表示するには、各ページを別ファイルに分割する必要があります。 （kaakaa/dio-exporterは複数ページのDraw.ioファイルから複数の画像ファイルを出力できるようになっているはずです）\nおわりに *.drawio.pngや*.drawio.svgというファイル形式にはいくつか懸念事項はありますが、作っているツールの概要をサクッと書きたいときなどは、とても役に立つと思います。\nまた、どうやら本体のDraw.io Integrationの方でも、PNGエクスポートの機能は追加される予定のようです。\n Support PNG Export · Issue #56 · hediet/vscode-drawio   As you can see, this feature has been released to insiders:\n 執筆時点(2020/07/28)での最新版である v0.7.2 では使えませんが、もしかしたらPNGエクスポートの機能は復活するのかもしれません。\n"},{"ref":"https://blog.kaakaa.dev/post/life/home-automation-smacame/","title":"子供の見守りカメラをちょいホームオートメーション","section":"post","date":"2020.07.23","body":"背景 数ヶ月前ぐらいから息子を寝室に寝かせるようになったのですが、寝室は2階にあり、リビングなどは1階にあるという状況なため、リビング居ても息子が目を覚ましたら気付けるようにと見守りカメラ的な物を購入して使っていました。\n寝室にはあまり物がないため、専用のクリップを一緒に購入し、窓枠に噛ませる形で設置をしていたのですが、子供が掴まり立ちをするとカメラの設置位置まで手が届いてしまうということが起き始めたため、カメラの設置位置を見直す必要が出てきました。\n設置位置としては、子供が届かない高さであり、かつ電源が供給できる位置ということで、照明用のダクトレールのところに移動しようと思っていたのですが、せっかくなので少しホームオートメーション的な構成にしてみようと思いました。\nデバイス 今回使ったデバイスたちの紹介。\n見守りカメラ カメラはPlanexのCS-QS10を自宅のネットワークに参加させ、公式スマホアプリから映像を見る感じ。\n 電気を消して暗くなると自動で赤外線モードになってくれ、赤外線モードでも子供の動きがしっかり認識できる程度の明るさが確保できるので便利。ただ、アプリで映像を見る時にデバイスの音声が奪われてしまうので、音楽聴きながら映像見たりできない点がちょっとネック。普段はiPadでカメラ映像を見ながらiPhoneで音楽聴いてます。\n電源 (SwitchBotプラグ) 電源部分については、ダクトレールは備え付けなので、そのダクトレールに取り付けられるコンセントを購入し、そのコンセントに以前購入して使っていなかったSwitchBot スマートプラグを挿しました。\n これで、SwitchBotアプリ経由でカメラの電源のON/OFFやスケジューリングなどができるようになります。設置方法としてはこんな感じ。\nレールを這わせることでコードを見えなくすることもできそうですが、家族以外入らない寝室なので横着しました。\nとりあえずココまででもスマホからカメラのON/OFFができ、かつ高さも取れているので十分なのですが、お遊びでiPhoenixのNFC機能も使ってみることにしました。\nNFCタグ 少し前に↓の記事を読み、iPhone + NFCタグの組み合わせに興味を持っていました。(Androidではだいぶ昔からできていたようですが)\niPhoneとNFCタグを使った家電制御が便利すぎる！【Siriショートカット】 - CHASUKE.com\n使い方としては、SwitchBot スマートプラグのON/OFF機能を持ったNFCタグを寝室の扉に貼っておき、子供を寝かせた後、出る時にピッとすると見守りカメラの電源をONにし、寝室にいくときにまたピッとするとカメラの電源がOFFになるイメージ。\nとりあえずNFCタグを購入。\n パッケージには \u0026ldquo;Android\u0026rdquo; としか書いておらず、「アレ？」と思って公式サイトを見に行ったらハッキリと「iPhoneは非対応です」と書いてあり一瞬焦りましたが、まだiPhoneにNFC機能が付く前の話だったようで一安心。\n ※iPhone、iPadは非対応です。（2014年6月現在）\n (2014年\u0026hellip;相当昔の商品だったのか\u0026hellip;)\n設定後、ドアノブのところにNFCタグを貼り、さて動作確認と行こうとしたら動かず\u0026hellip;どうやら金属製の部分に貼ると反応してくれないようで、公式サイトにもハッキリ書いてありましたね\u0026hellip;。\n ※アルミなどの金属面には対応していません。\n そしてお次は、貼りなおそうとした時にシール部分とNFC部分？が分離してしまいお釈迦に\u0026hellip;。新しいNFCタグで設定し直し、今度はドアの木の部分に貼り動作することを確認。（寝室から出る側に電源ONのNFCタグを、入る側に電源OFFのタグをそれぞれ貼っています）\nとりあえずこれで見守りカメラのON/OFFの操作をiPhoneをかざすだけでできるようになりました。NFCタグの使い勝手も分かり、ショートカットアプリ使用の実績も解除できました。\nおわりに 照明用のダクトレールに見守りカメラを設置すると、広い範囲を見れるので便利。（ダクトレールに取り付ける関係上、カメラの上下が逆転してしまってる）\nNFCタグとショートカットの組み合わせは便利そうだけど、今のところ他に良いユースケースは思い付かず。まぁ、思いついたらすぐ試せる材料が揃えられたのは良かったかな。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.24/","title":"Mattermost5.24の新機能","section":"post","date":"2020.06.20","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2020/6/17にMattermost v5.24.0がリリースされました。\n(2020/06/20現在、バグFixを含む v5.24.1 のリリースが計画されています)。\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost Release v5.24 is now available - Mattermost - Open Source, On-Prem or Private Cloud Messaging https://docs.mattermost.com/administration/changelog.html#release-v5-24-feature-release   Mattermostアプリ使用時にセッション維持期間を自動で延長する Mattermostにはセッション維持期間の設定項目があり、ログイン成功時からそのセッション維持期間で指定した期間が経過すると自動でログアウトされ、ユーザーは再度ログイン処理を行わなければなりませんでした。セキュリティ向上のためにセッション維持期間は短くしたいが、短くしてしまうとユーザーに再認証を要求するまでの期間も短くなってしまい、その結果、セッション切れから再認証までの間の通知を見落としてしまうというジレンマがありました。\nそれを解決するため、ユーザーがMattermost上でチャンネル切替やタイピングなどの行動を行った場合に、その時点から再度セッションが開始される設定が追加されました。\nこの設定は、システムコンソール \u0026gt; セッション維持期間 \u0026gt; 活動中はセッション維持期間を延長する から行うことができます。\n詳しくは、下記の公式ブログで説明されています。 Automatically extend Mattermost sessions for less frequent logouts and happier end users - Mattermost - Open Source, On-Prem or Private Cloud Messaging\n検索フィルタの改善 Mattermostヘッダ部分にある検索画面で、検索フィルタが利用しやすくなりました。 今までのバージョンでは空の検索画面をクリックすると検索フィルタについての説明が表示されるだけでしたが、今回のバージョンから検索フィルタの入力方法が改善され、検索フィルタの↑、↓、Enterキーでの選択入力や、日付指定フィルタ入力時のカレンダー表示などが行えるようになりました。\n絵文字リアクション操作が簡単に (モバイル) モバイルアプリ v1.32から、投稿を長押しすると出てくるメニューによく使われるリアクションが表示されるようになり、今までより簡単に絵文字リアクションが付けられるようになりました。\n自動補完を使用したスラッシュコマンド入力 (BETA) 今までのバージョンでも、メッセージ入力欄で / を入力すると利用可能なスラッシュコマンドの自動補完を行うことができましたが、今回のバージョンから、さらに選択したスラッシュコマンドで利用可能なオプション部分についても自動補完が可能となりました。\n(画像は[公式リリースブログ](https://mattermost.com/blog/mattermost-release-v5-24/)より転載) Bleveを利用した全文検索で日本語検索も可能に！（実験的機能） 今まで、Mattermost内の日本語メッセージを検索するためには、有償版のElasticsearch機能を使うか、DBに対して設定を追加する必要がありました。今回のバージョンから、Mattermost内のメッセージの全文検索にBleveを利用できるようになり、Bleveを使用することで、無償版でもDBへの設定なしに日本語を含む文字列を検索できるようになります。\nBleveの利用設定は システムコンソール \u0026gt; 実験的機能 \u0026gt; Bleve から行うことができます。 Bleveのインデックス付与を有効にする を有効にし、IndexDir にインデックスファイルを配置するディレクトリを指定する。（ここで指定したディレクトリの親ディレクトリが無いと、インデックス作成時にエラーが発生します）\n上記の設定を保存したら、一括インデックス付与 \u0026gt; インデックス付与をいますぐ開始するをクリックすることで、Bleveによるインデックス付与を開始することができます。メッセージ数が多い場合、この処理には時間がかかる可能性があります。インデックス付与はバックグラウンド処理として行われるため、処理中もMattermostは利用可能ですが、検索結果に不整合が発生する可能性があります。\nインデックス付与が完了したら、Bleveの検索クエリを有効にする、Bleveの自動補完クエリを有効にするを有効に設定することで、Bleveを利用した検索が行えるようになります。設定完了後は、新しいメッセージも自動でインデックス付与が行われるため、インデックス最新かのための操作は必要ありません。\n設定完了後、Mattermost上で検索を行うことで、日本語一文字だけでも検索できるようになります。\nBleveによる全文検索機能は実験的な機能のため、予期せぬ事象が発生する可能性があります。また、私も数件のメッセージがある環境でしか試していないため、大量のメッセージが存在する環境でどのような事象が発生するかは確認できていません。\nEnterprise版の改善 Office365カレンダーの同期 (E20) Mattermost上でOffice365カレンダーの予定を管理できるようになりました。\n その日のカレンダーイベントの確認 Office365カレンダーのstatusとMattermostのステータスを同期 (会議中は\u0026quot;離席中\u0026quot;になる、等) カレンダーイベントの承認/拒否がMattermrost上で可能に  (画像は公式リリースブログより転載)\nAD/LDAP グループメンション機能 (BETA) (E20) AD/LDAPグループに対して @メンション が行えるようになり、これにより複数の人に対して簡単にメンションを飛ばすことができるようになりました。\n(画像は公式リリースブログより転載)\nモバイルアプリでは、自動補完ドロップダウンでLDAPグループメンションのセクションは見えないようです。\nhttps://docs.mattermost.com/administration/changelog.html#breaking-changes\n Breaking Changes\n On mobile apps, users will not be able to see LDAP group mentions (E20 feature) in the autocomplete dropdown. Users will still receive notifications if they are part of an LDAP group. However, the group mention keyword will not be highlighted.   チーム/チャンネルのメンバーシップ管理がシステムコンソールから可能に (E20) 今までチームやチャンネルのメンバーシップ管理は、そのチーム/チャンネルの画面からしか行うことが行うことができませんでしたが、今回のバージョンからシステムコンソール上で行うことができるようになりました。\n(画像は公式リリースブログより転載)\nプロフィール画像をAD/LDAPと同期 (E10/E20) Mattermost上でのプロフィール画像をAD/LDAPのプロフィール画像と同期することができるようになりました。\nその他の変更  チャンネル内のピン留めされた投稿の数がヘッダ部分に表示されるようになりました  その他、多くの機能追加がありますが、詳細はChangelogからご確認ください  おわりに 次のv5.25のリリースは2020/7/15(Thu)を予定しています。 そして機能追加が行われるv5.26は恐らく2020/8/14(Fri)のリリースになるかと思います。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost%E3%81%AE%E6%A4%9C%E7%B4%A2%E6%A9%9F%E8%83%BD%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E8%AA%BF%E3%81%B9%E3%81%9F/","title":"Mattermostの検索機能についてちょっと調べた","section":"post","date":"2020.05.24","body":"Mattemrost の検索機能について少し調べた この前、Mattermostnの検索機能について質問を受けました。 検索欄に in:channel_name と入力して、チャンネル指定だけして検索を実行するとチャンネル内の全てのメッセージが検索できるけど、そこから除外文字だけ設定する(in:channel_name -excluded_term)と検索結果が0件になってしまうとのこと。\n2020/05/24時点の最新コミット (v5.24開発中)を元に見ていきます。 https://github.com/mattermost/mattermost-server/commit/2135096d886dad9055640edf881661004312c69b\nMattermostの投稿検索 search機能の本体はstore/sqlstore/post_store.go内のsearchメソッドな模様。 model.SearchParamsが検索条件を持つモデルで、この中のTerms、ExcludedTermsあたりが検索ワードに関するパラメータっぽい。\ntype SearchParams struct { Terms string ExcludedTerms string IsHashtag bool InChannels []string ExcludedChannels []string FromUsers []string ExcludedUsers []string AfterDate string ExcludedAfterDate string BeforeDate string ExcludedBeforeDate string OnDate string ExcludedDate string OrTerms bool IncludeDeletedChannels bool TimeZoneOffset int // True if this search doesn\u0026#39;t originate from a \u0026#34;current user\u0026#34;. \tSearchWithoutUserId bool } それぞれ一度変数に読み出しているので、こちらの変数を追っていく。\nhttps://github.com/mattermost/mattermost-server/blob/aad76a13e8381fc2a7c79d37d842d530c450a728/store/sqlstore/post_store.go#L1200\nterms := params.Terms excludedTerms := params.ExcludedTerms 1217行目あたりで、これらの変数で分岐しているところがあったのでここらへんが怪しい。\nif terms == \u0026#34;\u0026#34; \u0026amp;\u0026amp; excludedTerms == \u0026#34;\u0026#34; { // we\u0026#39;ve already confirmed that we have a channel or user to search for \tsearchQuery = strings.Replace(searchQuery, \u0026#34;SEARCH_CLAUSE\u0026#34;, \u0026#34;\u0026#34;, 1) } else if s.DriverName() == model.DATABASE_DRIVER_POSTGRES { ... } else if s.DriverName() == model.DATABASE_DRIVER_MYSQL { ... } まず検索ワードが無い場合の処理をして、その後は使用しているDBごとに処理を分けている。\n検索ワード/検索除外ワードが共に指定されていない場合 チャンネルだけ指定した検索(in:channel_name)はこれにあたりそう。 やっている処理は変数 searchQuery 内の SEARCH_CLAUSE という文字列を空文字に置換して消している。変数searchQueryは少し前の1160行目で宣言されているSQL文。SQLテンプレートの内部を置換しながらSQLを組み立てて行っている模様。検索ワードの有無はSEARCH_CLAUSEというパートで扱われていることがわかる。\n検索ワードが指定されている場合は使用しているDBごとにクエリの作り方を分岐させている。\n検索ワード有り かつ PostgreSQLの場合  terms, excludedTermsのワイルドカードを * -\u0026gt; :* に置換 除外句(excludedClause)の構築   \u0026amp; !(exTerm1|exTerm2|exTerm3))  検索句全体(:Terms)の構築   OrTerms?  YES -\u0026gt; (Term1|Term2|Term3) \u0026amp; !(exTerm1|exTerm2|exTerm3)) No -\u0026gt; (Term1\u0026amp;Term2\u0026amp;Term3) \u0026amp; !(exTerm1|exTerm2|exTerm3))    途中、SearchParams内のbool型変数OrTermsで分岐しているが、APIドキュメントによるとOrTermsというのはOR検索かAND検索かを判別フラグっぽい。\nhttps://api.mattermost.com/#tag/posts/paths/~1teams~1{team_id}~1posts~1search/post\n is_or_search Set to true if an Or search should be performed vs an And search.\n 以上からPostgreSQLの場合、検索除外ワードのみが設定されていた場合、検索句全体(:Terms)は \u0026amp; !(exTerm1|exTerm2|exTerm3)) となるはずです。検索句が \u0026amp; で始まっているのでクエリ的に怪しい気が(SQLについては詳しくないので予想ですが)。 ExcludedTermsしか設定されていない場合は、検索対象の語句をワイルドカードで与えてあげる (:* \u0026amp; !(exTerm1|exTerm2|exTerm3))) と良いような気がします。(PostgreSQLは使ってないので未検証)\n検索ワード有り かつ MySQLの場合 今回知りたかった部分の処理。\n 除外句(excludedClause)構築   -($excludedTerms)  検索句全体 (:Terms) の構築   OrTerms?  YES -\u0026gt; $terms -($excludedTerms) NO -\u0026gt; +term1 +term2 +term3 -($excludedTerms)    MySQLの場合、OrTermsが設定されていると与えられた（除外）検索句をそのまま利用するようです。 スペース区切りで与えられるからそのままOr検索になるのかな？ ただそうだとすると、除外句の部分 (-($excludedTerms)) を見ると、除外句の方が or にならなそうな気がしますが\u0026hellip;。\n以上から、MySQLでは、検索除外話ーどのみが設定されていた場合、検索句全体(:Terms)は -($excludedTerms) となるはずです。\n- で開始する検索句が有効なのか分からないのでMySQLのドキュメントを見てみる。\nするど、どうやら検索除外ワードのみのクエリが与えられた場合、MySQLは空の結果を返すようです。\nhttps://dev.mysql.com/doc/refman/5.7/en/fulltext-boolean.html\n* - A leading or trailing minus sign indicates that this word must not be present in any of the rows that are returned. InnoDB only supports leading minus signs. Note: The - operator acts only to exclude rows that are otherwise matched by other search terms. Thus, a boolean-mode search that contains only terms preceded by - returns an empty result. It does not return “all rows except those containing any of the excluded terms.” Mattermostはboolean-modeで検索を行っているため、検索除外ワードのみで検索ワードが与えられていないと検索結果が空となってしまい、空の検索結果から何を除外しても空ということのようです。 検索ワード、検索除外ワードともに空の場合は、PostgreSQL/MySQLごとに処理を分岐する以前に検索クエリ部分をSQL文から削除しているため、全ての投稿が検索結果として返ってきます。\nつまり、MySQLの場合も検索除外ワードのみが設定されているような場合は、検索対象の語句をワイルドカードで与えてあげる (* -($excludedTerms)) と良い気がします。 が、ワイルドカード(*) を使った検索は innodb_ft_min_token_size の影響を受けてしまい、1文字のワイルドカード(*)はクエリとして無効となってしまうらしい\u0026hellip;。(AB* のように2文字 + ワイルドカード(*) ならOK）。 Mattermostはこのサイズが最低でも2にしかできなかったため、単純にワイルドカードを付与する方法ではダメそうです\u0026hellip;。\nおわりに どうしよ。とりあえずIssueを立てた。 https://github.com/mattermost/mattermost-server/issues/14641\nIssue立ててる間に調べててわかったけど、Mattermostのコミュニティサーバーだと検索できるな。Elasticsearch使ってるからかな。お金を払ってちゃんと使おう。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.22/","title":"Mattermost5.22の新機能","section":"post","date":"2020.04.17","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2020/4/16にMattermost v5.22.0がリリースされました。\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost 5.22: Read-only channels \u0026amp; channel moderation settings in E20 - Mattermost - Open Source, On-Prem or Private Cloud Messaging https://docs.mattermost.com/administration/changelog.html#release-v5-22-feature-release   チームサイドバーの改善 Mattermostは一つのサーバーに複数のチームを作成でき、複数のチームに所属していると画面の左側にチーム切り替え用のサイドバーが表示されます。\n今回のリリースで、ショートカットキーによるチームの切り替えができるようになりました。 Ctrl + Alt (Windows) / ⌘ + ⌥ (Mac) を押しながら ↑/↓ キー、もしくはチームアイコンの脇に表示された数字のキーを押すことでチームを切り替えることができます。また、ドラッグ\u0026amp;ドロップでチームアイコンの順番を変えることができます。\nアーカイブしたチャンネルの復元 今まで一度アーカイブしたチャンネルを復元するには サーバー管理者向けのコマンドラインツール を使用するか、 APIからリクエストを送信する必要がありました。\n今回のバージョンから、MattermostのWeb画面からチャンネルを復元するメニューが使用可能になりました。 メッセージ検索結果などからアーカイブされたチャンネルに移動し、チャンネルメニューからチャンネル復元のメニューを選択することで復元可能になります。 (注意: 翻訳ミスのため、メニュー名が**「チャンネルをアーカイブする」**と表示されてしまっています\u0026hellip;次回リリースのv5.23.0で修正されているはずです。)\nConfluenceプラグインの改善 Atlassian Confluenceを利用しているユーザー向けに、Cofluenceプラグインが新しくなりました。 この改善により、複数のConfluenceサーバーへ接続できるようになり、また様々なConfluence上のイベントを関連するMattermostチャンネルに流すことができるようになります。\nイベントを購読したいMattermostチャンネルで、/cofluence subscribeというコマンドを実行することで設定することができます。\n詳しくは、下記を参照してください。 https://mattermost.gitbook.io/plugin-confluence/\n(実験的な機能) チャンネルサイドバーの改善 現在、Mattermostではチャンネルサイドバーの改善が進んでいます。 今回のリリースでは、実験的な機能としてチャンネルサイドバーに新たな機能が追加されています。\n サイドバーのカテゴリ(お気に入り、公開チャンネル、非公開チャンネル、ダイレクトメッセージ)が折り畳み可能に 未読チャンネルのみが表示される未読フィルダボタンの設置 チャンネル閲覧履歴に基いたチャンネル移動が可能なボタンの設置  (画像は公式ブログから転載)\nこの実験的な機能を有効にするには、まずシステム管理者によってシステムコンソールから 実験的なサイドバー機能 を有効にします。\nその後、ユーザーごとに アカウント設定 \u0026gt; サイドバー \u0026gt; 実験的なサイドバー機能 をオンにすることで有効になります。\nチャンネルモデレーション設定 (E20) （Enterprise E20 限定の機能です）\nシステム管理者がチャンネルごとに権限設定を行えるようになりました。 この機能により、以下のようなことが可能になります。\n チャンネル管理者が重要事項を通知するための読み込み専用アナウンスチャンネルの作成 チャンネル全体へのメンション (@channel, @here, @all) の無効化 チャンネルメンバーの変更を許可されたチャンネル管理者のみに制限  チャンネル設定画面から設定できます。\n詳細について公式ドキュメントを参照してください。 https://docs.mattermost.com/deployment/advanced-permissions.html#channel-moderation-beta-e20\nExtended Support Rellease(ESR) Mattermostは毎月16日にリリース日が設定されていますが、セキュリティアップデートなどがサポートされるのはリリースから3ヶ月後までです。毎月、もしくは3ヶ月ごとのアップデートが負担になるユーザー向けに昨年11月から9ヶ月サポートが続く Extended Support release (ESR) バージョンが半年に一度リリースされることになりました。\n今ではv5.9.0がESRとして設定されていましたが、そのサポートが終了し、今後は2020/01/16にリリースされたv5.19.0が ESR リリースとして 2020/10/16 までサポートされます。\n詳細は下記を参照してください。\n https://forum.mattermost.org/t/upcoming-extended-support-release-updates/8526 https://docs.mattermost.com/administration/extended-support-release.html   破壊的変更 絵文字リアクションポップアップのパフォーマンス改善 カスタム絵文字を多く登録すると、絵文字リアクションのポップアップ表示が重くなることがありました。今回のリリースで、パフォーマンス改善のために絵文字リアクション関連のスキーマ変更が行わレました。しかし、多くのカスタム絵文字が登録されている場合、スキーマ変更のアップデート処理に時間がかかることがあるため、利用者の少ない時間帯でのアップデートが推奨されています。\nチャンネルモデレーション設定のモバイルアプリ対応 今回のリリースで追加されたチャンネルモデレーションの設定は、モバイルアプリ v1.30 以降でサポートされています。それ以前のバージョンを使用している状態で、チャンネルモデレーション設定により投稿/絵文字リアクションが制限されているチャンネルで禁止された行為を行った場合、エラーが表示されてしまします。\nmodel.PostのPropsフィールドへの直接アクセスの制限 mattermost/mattermost-server の model.Postを利用した統合機能・プラグインを開発しているユーザー向けの注意事項です。 model.Post内の Props フィールドへの直接アクセスが禁止されたため、今後はGetProps()・SetProps()メソッドを利用してアクセスする必要があります。\nキーボードショートカットの追加  Ctrl/⌘ + .: 右サイドバーのopen/close Ctrl/⌘ + shift + /: 直前のメッセージにリアクション  キーボードショートカットは **Ctrl / ⌘ + /**で確認することができます。\nおわりに 次のv5.23のリリースは2020/5/15(Fri)を予定しています。 そして機能追加が行われるv5.24は恐らく2020/6/16(Tue)のリリースになるかと思います。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost-plugin-zoom/","title":"Mattermost Plugin Zoom","section":"post","date":"2020.04.10","body":"MattermostからZoomのミーティングに参加する Mattemrostではテキストでの議論が主になるため、テキストでは伝わり切らないニュアンスを伝えたい場合などに会話による調整が必要になる場面もあると思います。Mattermost社ではミーティングにZoomを利用しているというのもあり、Zoomミーティングを開催しやすくするプラグインを開発しています。\n本記事はMattemrost Zoomプラグインの使い方について紹介します。\n注記: Work From Homeの流れで必要性が増した気がしたので紹介しようとしましたが、Zoomのセキュリティ対応により現在は上手く動作しないようです。 April 2020: Setting updates for free accounts and single Pro users – Zoom Help Center\n具体的には、Zoom参加ボタンを押すとZoomミーティング参加のためのパスワードの入力が求められるようになりましたが、そのパスワードがどこからも取得できないため、開催者以外がZoomミーティングに参加できないという問題です。既にIssueが立っているので、利用される方は下記Issueの動向を確認してください。 https://github.com/mattermost/mattermost-plugin-zoom/issues/99\n環境  Mattermost v5.21.0  インストール プラグインのインストールにはシステム管理者の権限が必要です\nプラグインマーケットプレース Mattermost v5.16からプラグインのマーケットプレース機能が使えるようになり、UIからプラグインをダウンロードできます。\nメインメニュー \u0026gt; プラグインマーケットプレースからマーケットプレース画面を開ます。(プラグインマーケットプレースメニューはシステム管理者にしか見えません)\n表示されたプラグインからZoomプラグインを探し、 インストール のボタン押し、少し待てばZoomプラグインがインストールされます。\nインストールが完了すると、インストールボタンが設定ボタンに変わるはずです。\n手動インストール プラグインマーケットプレースメニューが表示されない、もしくはマーケットプレースへ接続できない、という場合は手動でプラグインをインストールします。手動でのプラグインのインストールにも、システム管理者の権限が必要です。\n手動でインストールするには、まず、GitHubから現時点(2020/4/10)での最新版である zoom-1.3.0.tar.gz をダウンロードします。v1.3.0 は、Mattermost v5.12 以上で使用できます。\nhttps://github.com/mattermost/mattermost-plugin-zoom/releases\nシステムコンソール \u0026gt; プラグイン(ベータ版) \u0026gt; プラグイン管理 を開き、 プラグインをアップロードするメニューから先ほどダウンロードした zoom-1.3.0.tar.gz をアップロードします。\n(もし、ファイルを選択するボタンが非活性になっている場合、Mattermostサーバーの設定ファイルconfig.jsonの PluginSettings.EnableUploads設定を true に手動で修正し、サーバーを再起動する必要があります。)\nアップロードが完了すると、プラグイン管理の設定画面下部のインストール済みプラグインに Zoomプラグインが表示されているはずです。\n設定 プラグインを起動する前にZoomの接続設定を行う必要があります。\nZoom API Key/Secret取得 Zoomプラグインの設定を行うにはZoomのAPI KeyとAPI Secretが必要です。\n https://marketplace.zoom.us/ にアクセスし、ログインする 右上のメニューからDevelop \u0026gt; Bulid Appをクリックする JWTの Create ボタンをクリックし、任意のApp Nameを入力して Create ボタンを押します  必須項目を入力し Continue ボタンを押すと、API KeyとAPI Secretが表示された画面に遷移するためコピーしておきます  Mattermost Zooom Plugin設定 システムコンソール \u0026gt; プラグイン(ベータ版) \u0026gt; Zoomを開き、設定を入力していきます。\n Zoom URL: (パブリックのZoomサービスを使う場合は空欄) Zoom API URL: (パブリックのZoomサービスを使う場合は空欄) API Key: (先ほどコピーしておいたAPI Key) API Secret: (先ほどコピーしておいたAPI Secret) Webhook Secret: (再生成するボタンを押してランダム文字列を生成しておく)  以上の設定が完了したら、再びシステムコンソール \u0026gt; プラグイン(ベータ版) \u0026gt; プラグイン管理 \u0026gt; インストール済みプラグインの設定へ移動し、Zoomプラグインの有効にするボタンを押し、プラグインを起動してください。(もし、エラーとなっている場合は一度無効にするボタンで停止してから、もう一度起動し直してください)\nこのプラグインは起動中です。のメッセージが表示されていれば、起動完了です。もし、起動に失敗した場合は、システムコンソール \u0026gt; レポート \u0026gt; サーバーログからZoomプラグインのエラーログを確認してください。\n実行 プラグインの起動が完了すると、Mattermostのチャンネルヘッダ部分にビデオカメラのアイコンが表示されているはずです。\nこのアイコンをクリックすることで、チャンネルにZoomミーティングへの参加ボタンが投稿されます。\nMattermostのチャンネル参加者は、この参加ボタンをクリックすることでZoomミーティングに簡単に参加できるようになります。\nおわりに MattermostにもZoom以外にも、ビデオカンファレンスサービスと連携するための統合機能がコミュニティベースで公開されています。 https://integrations.mattermost.com/category/directory/video-conferencing/#main\n"},{"ref":"https://blog.kaakaa.dev/post/go-mod-in-company-proxy/","title":"Go Mod in Company Proxy","section":"post","date":"2020.04.03","body":"追記 単純にhttp_proxyとhttps_proxyを設定してないだけだった\u0026hellip;。\n(追記ここまで)\nGoをv1.14.1にアップデートし、go mod tidyを実行したところエラーが出た。\n$ go mod tidy go: github.com/mattermost/mattermost-server/v5@v5.21.0: Get \u0026quot;https://proxy.golang.org/github.com/mattermost/mattermost-server/v5/@v/v5.21.0.mod\u0026quot;: dial tcp 172.217.26.113:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. メッセージから会社のプロキシに引っかかってるんだろうなーという予想はたったが、対処法がわからない。ググって GOPROXY=directを付ければよさそうと思い、再度実行してみたがダメ。\n$ GOPROXY=direct go mod tidy go: github.com/mattermost/mattermost-server/v5@v5.21.0/go.mod: verifying module: github.com/mattermost/mattermost-server/v5@v5.21.0/go.mod: Get \u0026quot;https://sum.golang.org/lookup/github.com/mattermost/mattermost-server/v5@v5.21.0\u0026quot;: dial tcp 216.58.196.241:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. ただ、エラ〜メッセージは変わっているのでもう少し調べるとこんな情報。\nGo モジュールのミラーリング・サービス【正式版】 — プログラミング言語 Go | text.Baldanders.info\n チェックサム・データベース\n なるほど、確かに二番目のログは sum.golang.org に接続しようとしている。というわけで、GOSUMDB=off も付けてチェックサムデータベースへのアクセスも取りやめれば良い、と。\n$ GOPROXY=direct GOSUMDB=off go mod tidy go: github.com/mattermost/mattermost-server/v5@v5.21.0 requires go.uber.org/atomic@v1.5.1: unrecognized import path \u0026quot;go.uber.org/atomic\u0026quot;: https fetch: Get \u0026quot;https://go.uber.org/atomic?go-get=1\u0026quot;: dial tcp 216.58.199.243:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. はい。go.user.orgに接続できないとなりました。コレはプロキシ経由しないと無理だなぁ\u0026hellip;。どうすれば\u0026hellip;。\n"},{"ref":"https://blog.kaakaa.dev/post/mattercon2020/","title":"MatterCon2020 Report","section":"post","date":"2020.02.28","body":"Mattermost公式ブログでも公開されました。\nhttps://mattermost.com/blog/going-to-mattercon-as-a-mattermost-contributor/\nSummary  概要:  中南米・バハマで開催されたMattermost社のコミュニティイベント MatterCon2020 に招待されたので行ってきました   目的:  建前: OSSネイティブな企業の開発プロセス・営業の仕方などに関する知見の収集 本音: バハマとか人生で行くことないだろうし、せっかく招待されたのだから行ってみたい   感想:  MatterConはMattermost社のメンバ、コミュニティメンバともに気軽に話しかけられる貴重な機会。CEO/CTOとも気軽に話ができる。 Mattermostはコミュニティを大事にする会社でありゲストとして至れり尽せりでした 技術の話が主体ということはなく、参加者同士のコミュニケーションを重視しており、Mattermost社員、コントリビュータに関係なく様々な人と話すことができました Fun Cultureを作り様々な背景を持つ人々をコミュニティとして巻き込んで規模を大きくしていくことが、OSSネイティブな企業の特性を活かしたビジネスの仕方だと感じた    背景 まず、MattermostおよびMatterConについてと、私がMatterConに参加するまでの経緯を述べます。\nMattermostとは MattermostはSlack Alternativeを標榜している、オープンソースのチャットツールです。SlackやTeamsと違い、データも含めたチャット環境すべてを自分たちの管理下に置けることを重視しており、SaaS展開などを行っていないのが特徴です。\n昨年、TeamsのDAUがSlackを超えた1というニュースが流れるなど、ユーザー数的にはSlack/Teamsが頭ひとつ抜けている感じですが、チャットのような組織内のコミュニケーションに関するデータを組織外の環境に置くことに懸念を持つようなセキュリティ意識の高い組織などで、Mattermostのようなオンプレミス環境に構築できるチャットツールの採用が増えています。その需要の大きさを示すように、昨年、Mattermostは昨年$50Mの投資を受け Series B2 となりました。\nMatterConとは? MatterConとはMattermost社が主催するイベントであり、Mattermost社のハンドブックでは以下のように定義されています。\nhttps://handbook.mattermost.com/contributors/mattercon\n We try to get together every 12 months or so to get face-time with one another, build community, reinforce our leadership principles, and get some work done! Since our team is scattered all over the globe, we try to plan a different location for each MatterCon. MatterCon is not a mandatory trip or a department offsite, nor is it a vacation or incentive trip. It\u0026rsquo;s a chance for everyone to meet fellow Mattermost team-members across all departments and regions: part team building, part education, part community building, and hopefully all fun. This is a work trip with fun mixed in.\n Mattermostはフルリモートの会社のため、12ヶ月ごとに一同に介して顔を合わせる機会を作っており、それを MatterCon と呼んでいます。 また、Mattermostは、会社のミッションの一つとして オープンソースコラボレーション を掲げており3、その一環としてMatterConにコミュニティメンバーを招待しています。\n一昨年までは参加者の規模が2,30人程度だったようですが、昨年のMatterConからは100人ほどの規模で開催されているようです（正確な人数については把握しておりません）。過去のMatterConの模様はYouTubeで公開されています。\n Mattermost 2017 Core Committers Summit \u0026amp; Hackathon - Las Vegas - YouTube Mattermost | MatterCon 2018 | Community Meetup in Lisbon - YouTube Mattermost | MatterCon 2019 | Community Meetup in Dominican Republic - YouTube  参加経緯 私は現在、Mattermost公式のコミュニティメンバとしてMattermostの日本語化4、Twitter Mattermost日本語アカウント(@mattermost_jp)の管理などを行っています。また他にも、Mattermost関連の記事投稿(blog5, Qiita6)やHelp Wantedなどの軽微なIssueの解決などを行っています。もう2年も前の話ですがMattermost v4.6がリリースされた際にはMVP7にも選出していただきました。\n Mattermostへの貢献を始めたきっかけは、2016年ごろに職場でMattermostを使い始めたことに起因します。 その頃、ChatOpsが流行りはじめていたということもあり、オンプレミスで運用できるようなOSSのチャットツールを探していました。Mattermostを使い始める前にもKandanやLet\u0026rsquo;s ChatなどのOSSのチャットツールを試していたのですが、それぞれ他システムとの連携機能が不十分であったり、開発が活発でなかったりと問題が見えていました。そんな中、会社の同期が見つけてきたMattermostは、当時(v3.4ぐらい？)から機能も豊富で開発も非常に活発であり、とても魅力的なソフトウェア/プロジェクトでした。Matterostでいろいろ遊んでいるうちに小さな翻訳ミスを見つけ、元々OSSへの貢献に興味があった私は公式ドキュメントで貢献の仕方を調べ、翻訳の修正を送ったことがMattermostへの貢献の始まりでした。\n当時、一つ小さな修正を送るだけでコアメンバーの方がコミュニティ用のMattermost上ですぐにコメントをくれたことも非常に印象的でした。 さらに、MattermostはGolangやReact.jsなどの技術を利用していることも自分の興味を惹き、定期的にTシャツなどのSwagを定期的に送ってくれたりしたこともあり、段々と貢献の幅を広げていきました。\nそして今回、MatterConへ招待いただくこととなりました。\nMatterCon出発前 ここでは、Mattermostの概要や出発前のやり取り、旅程について簡単に述べます。\n概要  期間: 2020/2/22(Sat), 23(Sun) 場所: Hotel Melia Nassau Beach - All Inclusive, in Nassa 参加者: 100人ぐらい？  Mattermost Inc. Partner / Contributor SOs (Significant Others, 奥さんなど)    開催前 MatterCon開催前の動きとしては、おおよそ下記のような流れでした。\n (11月下旬) コミュニティMattermostで招待のDMが届く (1月上旬) 利用するフライトについて連絡 -\u0026gt; 予約されたフライト情報が送られてくる (1/24) MatterCon Guest用チャンネルが作成される  MatterCon開催前、開催期間中を通じて必要な情報はここに投稿される   (2/4) Conference Agenda発表  MatterCon開催中のスケジュールなど   (2/10) Guest Agenda発表  ゲスト向けの詳細ドキュメント(空港からのシャトルバスの乗り方など)    旅程 旅程は以下の通りでした。バハマまでは直行便がないため、帰りは乗り継ぎ14時間空いたりするなど足掛け30時間以上かかりました\u0026hellip;(流石にホテルを予約しましたが)。\n 2/21: NRT - DFW - NAS  乗り継ぎの待機時間(4h)含めて移動時間は20時間ほど ナッソーの空港から会場のホテルまではMattermost社手配のシャトルバスで10分ぐらい   2/22: MatterCon Day1 (Unconference, Activitiesなど) 2/23: MatterCon Day2 (Hungout, Partner Session, Lightning Talks, Dinnerなど) 2/24: NSA - DFW  乗り継ぎで 14時間空くのでDFW泊   2/25-26: DFW - NRT  DFWでの一泊も含めると、ナッソーから成田までは31時間ぐらい\u0026hellip;    MatterCon ここでは、MatterConの中で私が体験したことを述べます。\nMatterCon Day 0 (Arrival) 自宅から成田空港へ行き、成田(NRT)からダラス・フォートワース空港(DFW)へ。DFWで4時間ほど時間を潰しAmerican Airlinesでバハマ・ナッソーにあるリンデン・ピンドリング空港(NAS)へ。 コロナウイルスの影響もあり検疫等で時間がかかることを予想していたましが、拍子抜けするほど何もなく。出入国時に過去14日以内の中国滞在歴を聞かれたぐらいでした。 DFW - NAS のフライトの途中、バハマの入国カードが配られたのですが、その紙は2枚綴りになっており、2枚目は出国時に提出するバハマのアンケートになっている模様。さすが観光立国。\nナッソーのリンデン・ピンドリング空港からはシャトルバス。到着ターミナル出口には観光会社の方だと思われる人たちが10人以上。出発前に送付されたGuest Agendaに記載の通り、現地の観光会社であるMajestic Toursのマークを掲げている人を見つけて声かけ。陽気なおっちゃんに誘われてシャトルバスへ。その間に、Buddyの Miguel (@mgdelacroix) からMattermostのDMで「ホテルに着いたら会おう」というメッセージが来ているのに気付き、「ちょうどバス乗ったところだから数十分ぐらいで着くよ」と返信。MatterConでは、私のようなゲスト一人一人に対して滞在中に分からないことがあった時の相談相手としてMattermost社の人をBuddyとして充てがってくれていました。\nホテルまではバスで10分ほど。バスから見える風景は、道路脇に椰子の木🌴が並ぶまさに南国リゾートのそれでした。(写真看板奥の建物は別のホテル)\n 17:00ごろにホテルに到着してそのままチェックイン。受付の人も適度にフレンドリーで好印象。特に問題なくチェックインを済ませ、ロビーでBuddyのMiguelを探すとGitHubのアイコン通りの見た目だったのですぐに見つかり挨拶。ちなみにホテルのロビーはこんな感じでした。\n Miguelがホテル内を案内してくれるとのことなので、簡単に歩き回りながら案内してもらいました。案内してもらってる間、Miguelの持っているアタリのバッグばかりが目に入る\u0026hellip;。聞いてみるとVideoゲームが好きとのこと（その後、日本のアニメ・漫画の知識も豊富であることが判明）。\n案内の最後に部屋まで行く途中、「18:00から4Fの日本料理店でDinnerがあるけど、疲れてるなら休んでても良いし来たいなら来ても良いし自由にして」と労いの言葉をかけてくれました。とりあえず部屋に入って荷物を置いてシャワーを浴びていたら18:00を過ぎていましたが、せっかくの機会なのでDinnerの会場へ。\n受付の人に何といえば良いか迷いましたが、「Mattermost社の人いますか？」という聞き方をしたら通じたようで案内してもらいました。ただ、案内してもらったテーブルにBuddyの人はおらず\u0026hellip;テーブルの方の何人かがMattermostのTシャツを着ていたのでBuddyとは別テーブルに来てしまったと理解。少し戸惑っていると非常にフレンドリーにWelcomeしてくれたので空いてた席に着席。日本語を少し喋れる人がいたり、日本料理ということでちょっと会話に参加したり。英語が結構わからず戸惑いましたが楽しい雰囲気だったので楽しかった。2時間ほどしたら流石に眠くなってきたので先に退席して就寝。\n部屋に戻ってから、部屋の外を見ると疑いようもないリゾート感。パシャリ。\n Dinnerでは会えなかったけど、別テーブルで楽しんでたことをMiguelに連絡。\nMatterCon Day 1 (Unconference, Activities\u0026hellip;) 昨日の連絡の続きでMiguelと朝食に行く流れになったので、ありがたく同行。朝食はバイキング。色んな種類があり、なかなか美味。食事の途中でシンガポールのコントリビュータ @liusy182 とも同席したので初めましての挨拶。\nGreeting 朝食の後は、ホテル内の会議室でGreeting。\nGreetingの前に会場前でノベルティを配っていたので、Tシャツとステッカー、ノートとペンをもらいました。また、その場に@jasonblaisがいたので挨拶。彼は、私が初めてコントリビュートをした時にメッセージをくれたり、その後もよく気にかけてくれてコメントをくれたりしていたので、今回のMatterConで感謝を述べたい人の一人でした。彼がいなかったらここまでコントリビュートをしてなかったと思います。このタイミングではあまり時間もなかったので、後で改めて感謝の意を伝えました。\nGreeting会場は、会議室らしく机と椅子が並べられている部屋。Mattermost社の人たちは数日前からプライベートなカンファレンスを行ってたらしいが、この日からコミュニティメンバーも参加するということで改めてCEO/CTOから挨拶。\n Unconference 挨拶の後はUnconference。いくつかのトピックについて円座になってディスカッションすると言うもの。まず、Greetingと同じ部屋でディスカッションのトピックとそれを担当するMattermost社の開発者が紹介され、興味がありそうなところの議論に参加するという形。トピックはPlatform, Security, DevOps, Kubernetes, Mobile, Integrationsなどなど7,8トピックぐらい？ありました。Miguelの誘いもあり、Platformのディスカッションに参加。会話の内容としては、モバイルアプリでネットワーク切断中に投稿されたメッセージのWebSocketをどう扱うか、や、GraphQLの導入についての話でした。\nGroup Photo ランチの前にMatterCon2020用の黄色いTシャツを着てグループフォト撮影。\n Lunch Unconference後はランチ。自分と同じ日本人コントリビュータの @maruTA-bis5とご一緒させてもらう。 朝食と同じ場所と聞いていたけど、そのレストランが空いておらず、近くで掃除してた人に聞いてビーチ近くのレストランを紹介される。 ビーチのレストランで受付をしようとしたところ、昨年日本で行われたMattermostイベント 8で知り合ったNRIの方々や、その時に来日していたMattermost営業のSteveがいたので同席させてもらう。ありがたい。 日本人コミュニティとして初めましてをしていたが、次のアクティビティの集合時間が迫っていたり、忙しいのか中々オーダーを取りに来てくれないということもあり慌ただしくランチを済ませることに\u0026hellip;。\nActivities １日目の午後はActivity。 出発前のアンケートで下記の中から参加したいActivityに関するヒアリングがありました。\n Ardastra Gardens, Zoo and Conservation Centre City and Country Tour Swimming with pigs matterconandchill at the resort, swim in the pools, paddleboard, snorkelling or kayak at the private beach  街中ブラブラするのが好きというのと、何かお土産になりそうなのを探せないかということでナッソーの街へ行くというCity and Country Tourを選択。\n指定された時間にロビーへ行くと、朝食で一緒だった@liusy182がいたので一緒に行動。 まずはシャーロット砦9へ。シャーロット砦には説明員の方がおり、その方に砦の中を案内してもらう。説明員の方が一々オーバーリアクションで面白かった。シャーロット砦自体はそんなに広くないので、2,30分ぐらいで一通り案内も終え、最後は屋上を散策しながら写真を撮ってバスへ。高台に建てられてる建物といこともあり眺めがとても良かった。\n 次はナッソー市街へ。市街をバスで走った後、ラムケーキ屋10さんで停車。バハマではラムケーキが有名らしい。中に入って試食。甘さとアルコール感が強め。さぁ、ここから自由時間\u0026hellip;と思ったら、ナッソー市街で停車するのはココだけらしい。バスで回るだけだったのね\u0026hellip;お土産どうしよ。そう言ってても始まらないのでバスに乗ってまた移動。写真はナッソー市街にあるParliament Squareの銅像。\n 海岸線を20分ほど走った後、海岸に到着。綺麗な景色。ブラブラ歩いて写真を撮る。一通り歩き回って出発待ってると、Microsoftから数ヶ月前にMattermostにジョインしたという方が話しかけてくれたので少し会話。 そしてそのままバスに乗ってホテル着。 ナッソー市街歩けなかったのは残念だけど、色んな景色を見れたので満足でした。  MatterCon Day 2 (Hungout, Partner Session, Lightning Talks\u0026hellip;) Hungout 午前中はHungoutという名の自由時間。 MatterpollというMattermostの投票機能プラグインを一緒に開発しているMattermost社の @hanzei とIssueのトリアージ。@hanzei とは前身の matterpoll-emoji の頃から3年近くGitHub上で開発をしており、その方とリアルで顔を合わせる機械などは想像していなかったので不思議な気持ちでした。\n途中、Partner Sessionへ招待されたのでそちらへ。\nPartner Session (NDA) 内容はNDAらしいのでノーコメント。\nPartner Sessionの後は午前のHungoutで話をした問題について解決策を探る（結局うまく解決はできなかった）。部屋でコード書いていると、コントリビュータの@cometkim からランチのお誘いが。面識はなかったけど、名前は知っていたので快諾。\nLunch @cometkimとBuddyの@wiggin77と一緒にランチビュッフェへ。途中でCTOの@coreyhulenも一緒に。 @cometkimに話を聞くと、彼が最初にMattermost本体にPullRequest(CJK関連)11を送った時、そのPRに自分がコメントをしたのを覚えてくれていたらしく、今回ランチに誘ってくれたそう。その頃はちょうど自分もMattermost本体へのPRをはじめた頃で、CJK関係のPRだったので自分の環境で動かしてコメントした覚えがあります。コメントした時は、まさかこんな形で対面するなんて想像もしていませんでした\u0026hellip;不思議なものです。\nLightning Talks ランチの後は会議室でライトニングトーク。 参加者は開発者だけではないので、ライトニングトークの内容はツール/フレームワークの話から営業向けサービス、コミュニティに対する想いなど様々でした。途中、Zoomで発表しているコミュニティの方がおり、そのセッションは非常に盛り上がっていました。\n    Topic Presenter Notes     Maybe somthing about Airplanes Christopher Speller    mattermost-govet (Keeping code clean and consistent) Jesús Espino    Designing for Failure in Engineering Systems George Goldberg    When Marketing Met Automation: A Love Story Kendall Reicherter Marketing automation at a high-level; best practices; common use cases   Security smells in code reviews Juho Nurminen    Current state of React Native Miguel Alatzar    git commit -m \u0026ldquo;\u0026ldquo;Contributing to Mattermost\u0026rdquo; Rajat Varyani (Community Member)    Impact of good open source projects on building experience and confidence Allan Guwatudde (Community) This talk will mainly be about my journey as a self-taught developer and how working on the mattermost project as a contributor has helped me learn, build experience and confidence.   Is there life after Redux/REST? POC Mattermost GraphQL Eli Yukelzon    Matrix testing Mattermost permissions Martin Kraft    Default: Open? Jesse Hallam    Folded Reply Threads update Adam Clarkson this project is just getting started so ~10 min will be plenty to give folks an update on this highly anticipated feature   Introduction to Open Source Shota Gvinepadze University course build around contributing to Mattermost   Mattermost and Vulnerabilities Aaron Rothschild     やはりオープンソースコミュニティの集まりであるからか、コミュニティやオープンさに関する発表が多かった印象があります。個人的には、Mattermostで最も要望の多い12Folded Replyの機能に関する紹介が興味深かったです。\nDinner at beach 最終日のDinnerはビーチで。 最後にまたグループフォトを撮ってからディナーへ。\nグループフォト撮影後、砂浜に設置されたテーブルに着席。 CEO/CTOなどから挨拶があり、貢献してくれた方々にプレゼントがあるということで名前を呼ばれ取りに行く。 貰ったのは、PatagoniaのダウンやTシャツ、ステッカー、ボールペンなどのSwagでした。Patagoniaのダウンをプレゼントできるとは強いな\u0026hellip;。\n ビュッフェスタイルで食事を取り、食べ、飲み、眠くなったので就寝。夜のビーチは風も強くて少し肌寒く、貰ったPatagoniaのダウンを早速着たり、会場にあった焚き火の周りにどんどん人が集まっていました。\n MatterCon Day 3 (Departure) 3日目は特に何も予定がなく、2日目にコミュニティMattermostのGuest用チャンネルで通知のあった各ゲストのシャトルバスの時間になったらロビーに集まって空港へ向かうだけ。 他の方の出発時間にロビーにいって挨拶したり、ロビーで作業しながら時間を潰し、バスで空港へ。\n空港でチェックイン前に売店でラムケーキをいくつか買い、荷物に詰めてチェックイン（バハマは消費税が12%\u0026hellip;）。 チェックイン時（だったかな？）に入国カードに付いてた出国カード（バハマについてのアンケート）の提出を求められたので渡す。\n後は空港内で時間を潰してDFWへ。 DFWでは乗り継ぎに14時間空くのでBaggage Claimで荷物を受け取り、滞在予定のホテルであるHyatt Regency DFW13へ。 このホテルはターミナル内にあるのですが少し行き方が特殊で、C18あたりのゲートから駐車場に向かって直進していると\u0026quot;Hyatt Regency\u0026quot;と書かれた案内板があるので、階段を上り下りしながらそのままずっと直進することでたどり着けます。 ターミナルCのBaggage Claimからシャトルバスを依頼できる電話があるらしいのですが、歩いても10分は掛からないので荷物を持って階段を上り下りできるなら歩きで行った方が楽に感じました。\nそのままホテルに宿泊し、翌日の飛行機で成田空港まで帰ってきました。時差の関係もあり、ナッソーからの帰りのフライトは2泊3日の長旅となりました\u0026hellip;。\nおわりに 2日間と短い間でしたが非常に楽しく、また、自分の興味から始めたOSS活動が現実のイベント参加に結びつくという非常に興味深い体験でした。\nイベント全体を通して、コミュニティメンバそれぞれにBuddyを付けてコミュニケーションを取りやすくしたり、一人でいるとMattermost社の人が積極的に話しかけてくれていたりと、Mattermostがコミュニティメンバをゲストとして大切に扱おうという意識を強く感じました。 話しかけてくれた方には数ヶ月前にMattermostにジョインしたと話している方も多く、会社の規模がまだまだ大きくなっていっているという点も実感できました。また、CEO/CTOなどは動画等ではよく拝見していましたが、普通に食事も一緒にすることができたりと簡単にアクセスできすぎて非常に不思議な感じでした。\nイベントの雰囲気としては、OSSコミュニティの集まりということで技術方面の意識の強いイベントかと思っていましたが、開発職以外の方々も多く参加しており、また、Significant Othersとして家族を同伴している方も数多くいたため、全体としては開発以外の雰囲気も強かったように感じました。もちろんHungoutの時間などに開発者を捕まえて議論をすることもできるので、開発に関する議論を沢山したい場合はそのようにできたのだと思います。その点については、もう少し英語力を磨いておけばより深い議論もできたはずであり悔いの残る点でした。\nロケーションについては、リゾート地らしく基本的にはTシャツ一枚で過ごせる気候で過ごしやすかったです（雨が降ったあとなどは肌寒かったりもしましたが）。現地の人々もリゾート地らしく陽気な方々が多く、ホテルの近くを移動するだけならば治安的な心配は全くありませんでした。また、会場である Melia Nassau Beach は All Inclusive ということで、ホテル内の飲食が自由であるためにホテル外に出る必要がなかったのも治安が良いと感じる一因かと思います。後、当然ですがホテルのビーチは非常に綺麗でした。\n また来年も招待していただけるよう、時間を見つけて貢献を積み重ねていければと思います。\nPhotos https://www.dropbox.com/sh/clhwtcu1q370trf/AAARbty5pp7lhVCfQgsVyXq9a?dl=0\n  https://jp.techcrunch.com/2019/07/12/2019-07-11-microsoft-says-its-slack-competitor-teams-now-has-13-million-daily-active-users/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://mattermost.com/blog/yc-leads-50m-series-b-in-mattermost-as-open-source-slack-alternative/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://docs.mattermost.com/process/handbook.html#mission\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://docs.mattermost.com/developer/localization.html#translation-maintenance\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://blog.kaakaa.dev\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://qiita.com/kaakaa_hoe\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://developers.mattermost.com/contribute/mvp/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://www.sbbit.jp/eventinfo/52965/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://www.bahamas.com/vendor/fort-charlotte\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://www.thebahamasrumcakefactory.com/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/mattermost/mattermost-server/pull/4555\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://mattermost.uservoice.com/forums/306457-general/suggestions/19572469-make-threads-collapsible\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://www.hyatt.com/ja-JP/hotel/texas/hyatt-regency-dfw-international-airport/dfwap\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   "},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.20/","title":"Mattermost5.20の新機能","section":"post","date":"2020.02.17","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2020/2/14にMattermost v5.20.0がリリースされました。また、2/16にバグFixを含んだ v5.20.1 がリリースされています。\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost 5.20: New mobile editor, desktop dark theme, and more - Mattermost - Open Source, On-Prem or Private Cloud Messaging https://docs.mattermost.com/administration/changelog.html#release-v5-20-feature-release   モバイルアプリのメッセージ編集画面の改善 Mattermost v5.20.0と同時にリリースされているMattermostモバイルアプリv1.28.0で、@メンションやスラッシュコマンド呼び出しなど、よく使う機能にすぐにアクセスするためのボタンが追加されました。\n(公式ブログに掲載されている画像です)\n最新のメッセージへ移動するためのバナー 未読メッセージが多くあるチャンネルに、クリックすると最新の投稿へ移動するためのバナーが表示されるようになりました。\n(公式ブログに掲載されている画像です)\nmmctl のリリース リモートサーバーにあるMattermostを操作するためのCLIツールである mmctl がリリースされました。\nhttps://github.com/mattermost/mmctl\n同梱プラグイン セキュリティの問題などでMattermostサーバーをインターネットへ接続できないように設定していた場合、いくつかの同梱プラグインはプリインストールされた状態で利用することはできましたが、プラグインマーケットプレースを通じたプラグインの管理を行うことができませんでした。 しかし、Mattermost 5.20からはインターネットから切断されたサーバーであっても、Mattermost本体に同梱されたバイナリについてはマーケットプレースを通じて管理できるようになりました。同梱プラグインは公式チームが開発しているものに限ります。\nまた、マーケットプレース画面で、「公式プラグイン」「コミュニティプラグイン」「ベータ版」などを識別しやすくなりました。\n(公式ブログに掲載されている画像です)\nさらに、独自で開発したMattermostプラグインがある場合、下記フォームからプラグインの情報を送ることでMattermost Integrationsに追加することができます。 Mattermost Integrations and Installers\nデスクトップアプリのUI/UX改善  新しいダークテーマ タブをドラッグ＆ドロップで並べ替え可能に タブでメンションと未読を表すデザインを更新 (公式ブログに掲載されている画像です)  未読メッセージがある場合のfavicon 未読のメンションがある場合、faviconに赤いドットが付与されるようになりました おわりに 次のv5.21のリリースは2020/3/16(Mon)を予定しています。 そして機能追加が行われるv5.22は恐らく2020/4/17(Thu)のリリースになるかと思います。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/gradle-application-toolong/","title":"Gradle Application プラグインで生成したスクリプトが実行できないことがある","section":"post","date":"2020.01.06","body":"要約  Windowsのcmd.exeの制約により、GradleのApplicationプラグインで生成したBatファイルが実行不可能になることがあった Applicationプラグインが出力するBatファイル内でのクラスパスの指定を、jarファイル指定でなくディレクトリ指定となるよう設定を追加することにより回避可能となった 検証用プロジェクト: https://github.com/kaakaa/gradle-application-too-long-input-line  背景 GradleのApplicationプラグインを利用すると、CLIツールとして作成したJavaアプリを実行するためのスクリプトを生成することができる。\nplugins { id \u0026#39;application\u0026#39; } application.mainClassName = \u0026#39;sample.Main\u0026#39; main メソッドを持つクラスを application.mainClassName として指定し、Gradle Applicationプラグインの installDist タスクを実行することで、$buildDir/install/${APPLICATION_NAME} 配下に実行可能な形式のアプリケーションが出力される。\n$ ./gradlew installDist $ tree build/install/ build/install/ └── app ├── bin │ ├── app │ └── app.bat └── lib ├── deps.jar ... bin ディレクトリ配下にはUnix実行用のスクリプトファイルとWindows実行用のBATファイルが出力される。アプリケーションが依存するライブラリは lib 配下にまとめられ、実行用スクリプトファイルから lib 配下の依存ライブラリが参照されるようになっている。\n問題 Windows環境において、Applicationプラグインから出力されたBATファイルを実行すると、エラーとなることがあった。\n\u0026gt; build/install/gradle-application-too-long-input-line/bin/gradle-application-too-long-input-line.bat The input line is too long. The syntax of the command is incorrect. GitHub Actionsでの実行結果\n原因 Windowsのcmd.exeでは１行が8191文字を超えるようなコマンドは実行できない。\nコマンド プロンプト (cmd.exe) のコマンドライン文字列の制限\n Microsoft Windows XP 以降の Windows を実行しているコンピューターでは、コマンド プロンプトで使用できる文字列の最大長は 8191 文字です。\n GradleのApplicationプラグインは、実行スクリプトファイル内で依存ライブラリを set CLASSPATH=%APP_HOME%\\lib\\deps1.jar;%APP_HOME%\\lib\\deps2.jar;... のようにjarファイル単位でクラスパス文字列に結合しているため、依存ライブラリが多すぎると 8191文字制約 に引っかかることがある。\nサンプルBATファイル\n解決方法 実行用スクリプトファイルを生成した後、クラスパス指定に関する行をディレクトリ参照1つで済むように文字列置換することでこのエラーは回避可能。\n... tasks.withType(CreateStartScripts).each { task -\u0026gt; task.doLast { String text = task.windowsScript.text text = text.replaceFirst(/(set CLASSPATH=%APP_HOME%\\\\lib\\\\).*/, { \u0026#34;${it[1]}*\u0026#34; }) task.windowsScript.write text } } ... 参考: Workaround for gradle application plugin \u0026lsquo;the input line is too long\u0026rsquo; error on Windows\n上記の設定を build.gradle に追加し、再度BATファイルを生成するとエラーとなっていた行は下記のように置換されるため、文字数制限に抵触しなくなる。\n... set CLASSPATH=%APP_HOME%\\lib\\* ... サンプルBATファイル\nこの設定を加えることで、エラーが解消できた。\nGitHub Actionsでの実行結果\n (別の解決方法として、fatjarを作成してそのfatjarのみをクラスパスで参照するよう書き換えれば良いかとも思いましたが、libディレクトリ内のその他の依存関係を排除する方法が分からなかったので、そちらの方法は断念しました)\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.18/","title":"Mattermost5.18の新機能","section":"post","date":"2019.12.21","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2019/12/16にMattermost v5.18.0がリリースされました。\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost 5.18: ID-only option for push notifications (E20), one-click plugin updates, mark posts as unread, and more - Mattermost - Open Source, On-Prem or Private Cloud Messaging https://docs.mattermost.com/administration/changelog.html#release-v5-18-feature-release   モバイルアプリのクラッシュ Mattemrost 5.18と同日にアップデートされたモバイル向けアプリ(iOS, Android)でMattermostに接続できない問題が発生しているようです。\n問題の一つとして、新しいバージョンのアプリでMattermost 5.9より前のバージョンのMattermostサーバーへ接続しようとするとクラッシュするという問題があるようです。\n現在、Mattermost 5.9より前のバージョンに接続してもクラッシュしないようにする修正を加えた新しいバージョン(v1.26.1)がリリースされているようです。(AppStoreで確認しましたが、AppStoreにはまだリリースされていないようです) https://github.com/mattermost/mattermost-mobile/blob/master/CHANGELOG.md#mattermost-mobile-apps-changelog\n アップデート内容 (E20) モバイルアプリ向けプッシュ通知の改善 現在、モバイルアプリへのプッシュ通知は、通知内のメッセージ内容を含めてApple Push Notification Service (APNS) もしくは Google Firebase Cloud Messaging (FCM) を経由してデバイスへ送信されています。これは、非常に厳密なセキュリティやコンプライアンスが求められる組織では問題となり得ます。\nE20ライセンスに追加された ID-only オプションを利用すると、プッシュ通知内のペイロードにはメッセージIDのみが含まれるようになり、メッセージ内容がAPNSやFCMへ送信されることがなくなります。通知内のメッセージ内容については、デバイスから直接Mattermostサーバーへ取得しにいくようになります。\n1クリックでプラグインをアップデート インストールされているプラグインのアップデートが簡単になりました。\nMattermost v5.16で プラグインマーケットプレース の機能が追加されましたが、その プラグインマーケットプレース のページでインストール済のプラグインのアップデートを行えるようになりました。\nインストール済のプラグインの新しいバージョンがリリースされている場合、アップデートするというリンクが表示されます。\nアップデートするボタンをクリックとすると確認ダイアログが表示されます。リリースノートへのリンクも表示されているため、ここから更新内容を確認しにいくこともできます。\n未読としてマーク 新しいメッセージは、それが後で読み返したい重要なメッセージであっても、一度表示してしまうと既読としてマークされてしまい、他のメッセージに埋もれてしまっていました。 しかし、今回のアップデートにより追加された 未読としてマークする 機能を使うことで、後で見返したいメッセージを再度未読状態に戻すことができます。\n以下のサンプルは公式ブログからの転載です。\nアーカイブされたチャンネルの参照 アーカイブされたチャンネルを簡単に参照できるようになりました。\nまだベータ版の機能ですが、Mattermostサーバー内の config.json にある ExperimentalViewArchivedChannels の設定を true にすることで、参加可能チャンネルの一覧にアーカイブされたチャンネルを表示できるようになります。 (公式ドキュメントでは設定名が ViewArchivedChannels となっていますが、おそらく誤りだと思われるため修正のPRを出しています。)\nアーカイブチャンネルは普通のチャンネルと同じように開くことができますが、書き込みはできません。\nまた、この設定を有効にすると、アーカイブチャンネル内のコメントを検索できるようにもなります。\nその他の変更点  JIRAプラグインがアップデートされ、１チャンネルで複数のJIRAプロジェクトの通知を受けれるようになったり、通知のフィルタリングができるようになっているようです  今回のリリースとは関係ないとは思いますが、JIRAプラグイン用のドキュメントサイトもあるようです https://mattermost.gitbook.io/plugin-jira/   リモート端末からMattermostを操作できる新しいCLIツール mmctl が公開されています  https://github.com/mattermost/mmctl   (E10/E20) v5.16で追加されたゲストアカウント機能に、AD/LDAPとSAMLから直接ゲストアカウントを作成する機能が追加されました (E20)コンプライアンス用のActiance Export Toolで投稿/ファイルの削除/修正イベントを扱えるようになりました (E20) AD/LDAPグループ同期機能が実験的な機能(Experimental)からベータ版(Beta)となりました  コードブロックに行番号 シンタックスハイライト付きでコードブロックを投稿した際に、行番号が表示されるようになりました。\nMISC Mattermost Hackathon 11/22-26の間、Mattermostコミュニティのヴァーチャルハッカソンが開催されました。 以下の記事で、ハッカソンの成果が紹介されています。数が多すぎて見切れていませんが、Calendar PluginやAir Quality Index Pluginなど気になる物がいくつもあります。 https://mattermost.com/blog/mattermost-hackathon-2019-highlights/\nNRI x Mattermost社イベント動画 10月に行われた野村総合研究所主催のMattermostイベントの動画がYouTubeで見られるようです。 https://www.youtube.com/channel/UC-FNtllB7J7nAgxU5FXxyVQ\nLINC Biz - Mattermostベースサービス？ SHARPの子会社よりMattermostをベースとしていると思われるサービスが開始されました。（公式にMattermostを利用していると発表している訳ではないので、Mattermostを利用していないかもしれません）\nhttps://corporate.jp.sharp/news/191128-b.html\nおわりに 次のv5.19のリリースは2020/1/16(Thu)を予定しています。 そして機能追加が行われるv5.20は恐らく2020/2/17(Mon)のリリースになるかと思います。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermostthemes/","title":"Mattermostのテーマ集","section":"post","date":"2019.12.15","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost\nMattermost テーマ Mattermostではアカウント設定から画面の表示テーマを変更することができます。 ちょっと気分を変えたい時や、複数のインスタンスに参加している場合、自分が今どのインスタンスにいるかを識別しやすくするためにテーマを変えたりするかと思います。\nMattermostはデフォルトで4種類のテーマ (Mattermost, Organization, Mattermost Dark, Windows Dark) を選択することができ、さらにカスタムテーマを利用することで自由にカラーを設定できます。\nしかし、カスタムカラーを設定する場合、カラーを設定できる箇所が20箇所以上もあるため、一からテーマを作成するのはなかなか難儀かと思います。\nそこで、今回はMattermostのテーマを紹介しているサイトをいくつか紹介していきます。\nカスタムテーマの設定方法 テーマ紹介サイトを紹介する前に、カスタムテーマの設定方法について紹介します。\nカスタムテーマの設定方法は非常に簡単で、Mattermostテーマを表すJSON文字列をコピーして、アカウント設定のカスタムテーマの部分にペーストするだけです。\nペーストした時点で画面表示が変わるので、問題なさそうなら 保存 ボタンを押して変更を完了します。\nMattermostテーマを表すJSON文字列は、下記のような形式をした文字列です。\n{\u0026#34;sidebarBg\u0026#34;:\u0026#34;#146b3a\u0026#34;,\u0026#34;sidebarText\u0026#34;:\u0026#34;#f7f7f7\u0026#34;,\u0026#34;sidebarUnreadText\u0026#34;:\u0026#34;#eba828\u0026#34;,\u0026#34;sidebarTextHoverBg\u0026#34;:\u0026#34;#de161a\u0026#34;,\u0026#34;sidebarTextActiveBorder\u0026#34;:\u0026#34;#175b33\u0026#34;,\u0026#34;sidebarTextActiveColor\u0026#34;:\u0026#34;#ffa900\u0026#34;,\u0026#34;sidebarHeaderBg\u0026#34;:\u0026#34;#175b33\u0026#34;,\u0026#34;sidebarHeaderTextColor\u0026#34;:\u0026#34;#f7f7f7\u0026#34;,\u0026#34;onlineIndicator\u0026#34;:\u0026#34;#21e4a4\u0026#34;,\u0026#34;awayIndicator\u0026#34;:\u0026#34;#eba828\u0026#34;,\u0026#34;dndIndicator\u0026#34;:\u0026#34;#bb2528\u0026#34;,\u0026#34;mentionBj\u0026#34;:\u0026#34;#de161a\u0026#34;,\u0026#34;mentionColor\u0026#34;:\u0026#34;#ffa900\u0026#34;,\u0026#34;centerChannelBg\u0026#34;:\u0026#34;#ffffff\u0026#34;,\u0026#34;centerChannelColor\u0026#34;:\u0026#34;#333333\u0026#34;,\u0026#34;newMessageSeparator\u0026#34;:\u0026#34;#ffa900\u0026#34;,\u0026#34;linkColor\u0026#34;:\u0026#34;#016341\u0026#34;,\u0026#34;buttonBg\u0026#34;:\u0026#34;#1c8c4c\u0026#34;,\u0026#34;buttonColor\u0026#34;:\u0026#34;#ffffff\u0026#34;,\u0026#34;errorTextColor\u0026#34;:\u0026#34;#bb2528\u0026#34;,\u0026#34;mentionHighlightBg\u0026#34;:\u0026#34;#bb2528\u0026#34;,\u0026#34;mentionHighlightLink\u0026#34;:\u0026#34;#ffa900\u0026#34;,\u0026#34;codeTheme\u0026#34;:\u0026#34;solarized-light\u0026#34;,\u0026#34;mentionBg\u0026#34;:\u0026#34;#de161a\u0026#34;} また、Slackで設定しているテーマカラーを、そのまま流用することもできます。\nカスタムテーマ集 Mattermost Themes Mattermostのコミュニティメンバーが作成したGitHub Pagesサイトです。 現時点では、このサイトで最も多くのテーマが紹介されているようです。(Light Theme 16種類、 Dark Theme 14種類)\nこのサイトでは、テーマのサンプル画像をクリックするとJSON文字列がコピーされるので、そのままMattermostのカスタムテーマ設定の部分にペーストするだけでテーマを適用することができます。\nまた、このプロジェクトはGitHub上で公開されているため、自分のテーマを追加することもできます。 https://github.com/avasconcelos114/mattermost-themes\n公式ドキュメント 公式ドキュメントの Theme Color のページにいくつかテーマが紹介されています。現時点(2019/12/14現在)で紹介されているのは、以下の5つのテーマです。\n GitHub theme Monokai theme Solarized Dark theme Gruvbox Dark theme One Dark  このサイトでは、JSON文字列が直接表示されているため、これを選択してコピー、カスタムテーマ設定画面でペーストという流れになります。\n公式フォーラム 公式フォーラムでもテーマを共有するトピックが立っています。名前のついていないテーマもありますが、現時点(2019/12/14事典)で、14種類ほどのテーマが紹介されています。(One Dark等、他で紹介されているものと重複しているものもありそうですが\u0026hellip;）\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.16/","title":"Mattermost5.16の新機能","section":"post","date":"2019.10.19","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2019/10/16にMattermost v5.16.0がリリースされました。 既にv5.16.1のリリースが予定されています。v5.16.1に含まれる修正内容についてはChangelogを確認ください。\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost 5.16: Guest accounts, a new Plugin Marketplace, faster installation on desktops, and more - Mattermost - Open Source, On-Prem or Private Cloud Messaging Mattermost Changelog — Mattermost 5.16 documentation   アップデート内容 (E10/20) ゲストアカウント Enterprise版限定の機能です。 組織外のユーザーとのコラボレーションのために、限定的なアクセス権のみを持つゲストアカウントを作成できるようになりました。\nゲストアカウントは、招待されたチャンネルのみにアクセスでき、その他の公開チャンネルを検索したり、他のチャンネルに参加したりすることはできません。また、ダイレクトメッセージについても、招待されたチャンネルに参加しているユーザーのみにしか送信できず、その他のユーザーにはメッセージを送ることはできません。\nゲストアカウントの投稿や、プロフィールポップアップ画面には GUEST というバッチが付与されます。(画像は公式ブログから)\nゲストアカウントの設定・招待 ゲストアカウントはシステムコンソール画面から有効にできます。また、ゲストアカウントとして追加できるメールアドレスのドメインを制限することもできます。\nゲストアカウント機能を有効にしたのち、メインメニューの 招待する メニューをクリックすると、下記のようなメニューが表示されます。 ゲストアカウントを追加したい場合は、「ゲストを招待する」メニューを選択します。\n既に他のチームに参加しているユーザーをゲストアカウントとして追加したい場合はユーザー名を、まだMattermostアカウントを作成していない場合はメールアドレスを指定します。 ゲストとして追加するチャンネルは、公開チャンネル・非公開チャンネル共に選択することができます。\nメールアドレスを入力してゲストを招待すると、このようなメールが送信されます。\nまた、既に存在するアカウントをゲストアカウントへ降格させることもできます。\nプラグインマーケットプレース Mattermost統合機能のマーケットプレースにメインメニューからアクセスできるようになりました。 これによりシステム管理者は、現在使用しているバージョンのMattermostで利用可能なプラグインを簡単にインストールできるようになります。\nメインメニューの プラグインマーケットプレース メニューからマーケットプレースを開けます。 プラグインマーケットプレースから、インストールしたいプラグインの横にある インストール ボタンをクリックするだけでプラグインをインストールできます。\n現在は、Mattermostチームによって検証されたプラグインのみが表示されます。コミュニティメンバによって開発されたプラグインは https://integrations.mattermost.com/ から探すことができます。\nまた、このマーケットプレース用のサーバーをセルフホストすることもできます。\nhttps://github.com/mattermost/mattermost-marketplace\n上記リポジトリをcloneし、plugins.jsonを編集して make run-server を実行するだけで、独自のマーケットプレースサーバーを構築できます。（ただ、ローカルマシンで試してみたところ、プラグインのインストールが完了してもインストール中の表示が消えなかったりしたので、実際に利用する場合は注意してください）\nマーケットプレースサーバーをセルフホストした場合、そのサーバーURLをシステムコンソールから設定することにより、セルフホストしたマーケットプレースに接続できるようになります。\nその他の変更点 Internet Explorer 11のサポート終了 v5.16.0より Internet Explorer 11(IE11) のサポートが終了しました。今後、Internet Explorer での Mattermost の動作は保証されません。 この決定の背景等についてはフォーラムの投稿にまとめられています。\n今後は、IEの代わりに下記のクライアントを使用することが推奨されています。\n  Mattermost Desktop App for Windows, Mac and Linux Chrome for Windows, Mac and Linux Firefox for Windows, Mac and Linux Safari for Mac, usually available on all Macs by default Microsoft Edge for Windows, usually available on all Windows 10 machines by default   Mattermostがサポートしているクライアントのバージョンについては https://docs.mattermost.com/install/requirements.html#pc-web で確認できます。\nMSIインストーラーによるDesktopアプリインストールの効率化 Mattermost Desktop v4.3.0から、MSIインストーラーによるMattermost Desktopアプリのインストールが可能になりました。 また、Windowsのグループポリシーを設定することで、下記を制御することが可能になりました。\n アプリの自動アップデート機能の有効/無効 サーバーの追加/削除機能の有効/無効 デフォルトサーバーリストの有効/無効  詳しくは https://docs.mattermost.com/install/desktop-msi-gpo.html を参照してください。\nMattermost Desktopアプリのデスクトップ通知方式変更 Mattermost Desktopアプリ v4.3.0から、セキュアでないhttpプロトコルからのデスクトップ通知の送信方式が変更されました。 Mattermost Desktopアプリ v4.3.0を使用している場合は、Mattermostサーバーを v5.16.0+, v5.15.1, v5.14.4, v5.9.5のいずれかのアップデートする必要があります。\nインタラクティブダイアログの改善 Mattermostのインタラクティブダイアログで使用できる要素が追加されました。\n ダイアログの上部にMarkdown形式の説明文を追加することができるようになりました 画面上で表示されないパスワード型のテキストを使用できるようになりました チェックボックス型の要素を利用できるようになりました ラジオボタンを利用できるようになりました  上記のダイアログを生成するためのコードは https://gist.github.com/kaakaa/a159cdc51a96b2daa41d84b2d1e2c218#file-mm_v5-16_interactive_dialog-go-L34 にあります。\nmisc Hacktoberfest Hacktoberfest returns! Contribute to open source projects and win free swag - Mattermost - Open Source, On-Prem or Private Cloud Messaging\nHacktoberfestは、10月中に4つGitHub上でPullRequestsがMergeされるとTシャツなどのノベルティがもらえるオンライン上のイベントです。\nMattermostでは今年もHacktober向けのIssueを多く用意しています。興味のある方は、まず https://hacktoberfest.digitalocean.com/ で参加登録をしてから、下記のIssueリストから手をつけられそうなものを探してみてください。\nhttps://github.com/mattermost/mattermost-server/labels/Hacktoberfest\nNRI x Mattermost社 イベント 先日、Mattermost社が参加する初の日本でのイベントが、野村総合研究所主催で行われました。 イベント・セミナー | aslead/アスリード | 野村総合研究所(NRI)\nイベントに合わせて野村総合研究所によるMattermostの紹介記事が公開されています。 NRIが全社利用するビジネスチャットツールMattermostのご紹介\nおわりに 次のv5.17のリリースは2019/11/15(Fri)を予定しています。 そして機能追加が行われるv5.18は恐らく2019/12/16(Mon)のリリースになるかと思います。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/github_actions/","title":"新しくなったGitHub ActionsでHugoブログのデプロイをしてみた","section":"post","date":"2019.08.31","body":"はじめに CI/CD機能が付いて新しくなったGitHub Actionsが使えるようになったので、Travisでビルド/デプロイしていたブログをActionsに移行してみました。\nGitHub Actionsのベータプログラムには下記サイトから応募できます。 https://github.com/features/actions\n前提 今まで利用していたTravisの設定ファイルはこちら。\nnotifications: email: false sudo: false dist: trusty language: go env: - HUGO_VERSION=0.51 go: - \u0026#39;1.10\u0026#39; install: true before_script: - wget https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_${HUGO_VERSION}_Linux-64bit.deb - sudo dpkg -i hugo_${HUGO_VERSION}_Linux-64bit.deb script: - git submodule update --init - hugo -v deploy: provider: pages local-dir: public skip-cleanup: true github-token: $GITHUB_TOKEN keep-history: true on: branch: master Hugoのインストールとビルドを行い、pagesのproviderを使ってgh-pagesブランチにデプロイしています。(GoとHugoのバージョンが古いですね\u0026hellip;むしろGoはいらないんじゃないような\u0026hellip;)\n移行 GitHub Actionsの作成 Actionsを使いたいリポジトリのタブの部分に Actions というメニューが生えているため、そこをクリックします。\nまだActionsが設定されていない場合は、Workflowのサンプルがいくつか表示されています。 自分は何も分からなかったので右上の Set up a workflow yourself のボタンを選択しました。\nすると、 .github/workflows/main.yml というファイルにサンプルのワークフローの定義ファイルを作成する画面に移ります。CircleCIの設定ファイルによく似てますね。\n右ペインに簡単な説明が書かれているのでそれを見たり、ドキュメントを見たりしながら編集していきます。\n完成品 (main.yml) とりあえず動くものが出来ました。\nname: Deploy Pages on: push: branches: - master jobs: deploy: runs-on: ubuntu-latest  steps: - name: Checkout uses: actions/checkout@v1 - name: Build and Deploy uses: JamesIves/github-pages-deploy-action@master env: ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }} BRANCH: gh-pages FOLDER: public HUGO_VERSION: 0.57.2 BUILD_SCRIPT: |wget https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_${HUGO_VERSION}_Linux-64bit.deb dpkg -i hugo_${HUGO_VERSION}_Linux-64bit.deb git submodule update --init hugo -v Build and Deploy というステップで、JamesIves/github-pages-deploy-actionという他の人の作ったGitHub PagesをデプロイするActionsを使っています。CircleCIで言うところのOrbでしょうか（あまり知らない）。\nSecrets env: ACCESS_TOKEN: のところで secrets.ACCESS_TOKEN と言う変数を使っていますが、これはリポジトリのSettingsメニューから設定できる変数を使っているようです。 Settings \u0026gt; Secrets \u0026gt; Add a new secretを選択し、変数名とその値を入れるとActionsの定義ファイル(main.yml)でその変数を使えるようになります。\n詳しくは公式ドキュメントを。\n微妙な点 このステップの BUILD_SCRIPT のところでHugoでのビルドを行っているのですが、ここでHugoのインストールまでここでやっているのがちょっと微妙です。別のステップを作って、その中でHugoのインストールを行ってみたりしたのですが、hugoコマンドが見つからないと言うエラーとなり、別のステップでの変更は持ち込めないようでした。 なんかやり方あるのかな？\n動作確認 コミットを契機にビルドが開始される設定となっているので、.github/workflows/main.yml をコミットすると、Actionsが開始されます。結果はActionsタブから確認できます。ビルドログも見れます。\nおわりに 深くは使ってないので判断はできませんが、GitHubだけで完結できるのは楽ですね。\n今年の初めぐらいにTravisがIderaに買収されたり、Travisのエンジニアが解雇されたりとTravis周りはキナ臭い話が多く、それを機にCircleCIに移行するプロジェクトも多かったと思いましたが、そこでビッグウェーブに乗らずに移行しなかったために難なくGitHub Actionsに移れてよかったです。果報は寝て待てですね（動きが遅かっただけ）。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.14/","title":"Mattermost5.14の新機能","section":"post","date":"2019.08.29","body":"Mattermost記事まとめ: https://blog.kaakaa.dev/tags/mattermost/\nはじめに 2019/8/16にMattermost v5.14.0がリリースされました。 その後すぐにv5.14.1のリリースが予告され、2019/8/28にキーボードアクセシビリティのバグ修正を含むv5.14.1がリリースされました。 この記事では、アップデートの内容について簡単に紹介していきます。\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost 5.14: Accessibility improvements, enhanced Jira integration, LDAP group sync upgrade, and more - Mattermost - Open Source, On-Prem or Private Cloud Messaging Mattermost 5.14.1 released - Mattermost - Open Source, On-Prem or Private Cloud Messaging Mattermost Changelog — Mattermost 5.14 documentation   アップデート内容 アクセシビリティの改善 Mattermostの画面上をキーボードで移動できるようになりました。\nデスクトップアプリ上では F6、Webブラウザ上では Ctrl + F6 で、サイドバー、ヘッダー、投稿表示部分などにカーソルを移動することができます。 また、TABボタンで画面上のボタンやリンクにカーソルを移動することができ、ENTERキーで操作することができます。\nまた、スクリーンリーダーとの相性がさらに良くなりました。\n視覚的な障碍のある方にもMattermostを効果的に利用してもらえるよう、ボタンやリンク、アプリ表示部分の読み上げがより正確になりました。\n詳しくは Keyboard Accessibility — Mattermost 5.14 documentation を参照ください。\nMattermostは米国リハビリテーション法第508条の遵守に取り組んでおり、継続的にアクセシビリティの改善を行なっています。 Voluntary Product Accessibility Template (VPAT) — Mattermost 5.14 documentation\nJIRA連携機能の改善 Mattermostに同梱されているJIRAプラグインがアップデートされました。 より効率的に作業を行える多くの機能が追加されています。\n 全ての更新、割り当て、コメントを自動で通知する専用のJIRAチャンネル  JIRAの情報を一箇所に集めることで、全ての更新を把握するためにメールに頼る必要が無くなります   あるJIRAプロジェクトから特定のMattermostチャンネルに通知を簡単に送信する機能  チャンネル管理者は、JIRAプロジェクトやイベントに基づいてチャンネルに送信される通知を設定できルため、手動でWebHookを設定する必要が無くなります   JIRAのIssueを作成、管理、閲覧でき、通知の設定を管理できるスラッシュコマンド  詳しくは mattermost/mattermost-plugin-jira: JIRA plugin for Mattermost 🔌 を参照してください。\nLDAPグループ管理 (E10/E20) LDAPグループ同期機能によるチームとチャンネルの管理に関して新たなオプションが追加されました。\n今回追加されたオプションでは、Mattermost v5.12で追加されたCLIのグループコマンドに加え、システムコンソールに追加された新しいチーム/チャンネルのページからLDAPグループ同期によるメンバーシップの管理を行うことができるようになりました。\n詳しくは Using AD/LDAP Synchronized Groups to Manage Team or Private Channel Membership — Mattermost 5.14 documentation を参照してください。\n未読メッセージが見つけやすく チャンネルを開いたときに、もっとも古い未読メッセージが自動で表示されるようになりました。これにより未読メッセージを追うために投稿を遡ってスクロールする必要が無くなりました。\nその他 IEサポートの廃止 2019/10/16リリース予定のMattermost v5.16からInternet Explorerのサポートが廃止されます。 End of support for Internet Explorer 11 coming in October\nMattermostがサポートしているブラウザは Software and Hardware Requirements から確認できます。\n破壊的変更  内向き/外向きのウェブフック編集画面で、他のユーザーが作成したウェブフックを見ることができなくなりました。システム管理者は全てのウェブフックを見ることができます Google Single Sign-On (E20) の機能を利用している場合、ログインに利用するサービスが Google+ から Google People に変更されたため、設定の変更が必要です。詳しくは Google Single Sign-On (E20) を参照してください。  インストール済みプラグインの追加 Jenkins, Antivirus, GitLabのプラグインがデフォルトインストール済みプラグインとして追加されました。 それぞれのプラグインの機能については下記を参照してください。\n mattermost/mattermost-plugin-jenkins: A Mattermost plugin to interact with Jenkins mattermost/mattermost-plugin-antivirus: Antivirus plugin for scanning files uploaded to Mattermost mattermost/mattermost-plugin-gitlab: GitLab plugin for Mattermost  ウェブフック投稿のアイコンに絵文字 内向きのウェブフックのペイロードに icon_emoji というフィールドが追加され、ここに絵文字名を指定してウェブフックを飛ばすと、ウェブフックにより作成された投稿のプロフィール画像に絵文字が表示されるようになりました。\ncurl -v -XPOST -H 'Content-Type: application/json' -d '{\u0026quot;text\u0026quot;: \u0026quot;hello\u0026quot;, \u0026quot;icon_emoji\u0026quot;:\u0026quot;+1\u0026quot;}' https://example.com:8065/hooks/XXXXXXXXXXXXXXXXXXXXXXXXXX ↑ のようなリクエストを送ると ↓ のような投稿が作成されます。\nmisc 以下、最近あまり追えてないですがMattermostチームでの気になる動きについて紹介します。\nPlugin Marketplace 最近、新しいバージョンが増えるごとにMattermost本体に同梱されるプラグインが増えるなど、MattermostチームはPlugin機能に力を入れているようです。 その中の大きな動きの一つとして、Mattermost が Plugin Marketplace の開設があります。 https://github.com/mattermost/mattermost-marketplace\n全容はわかりませんが、システムコンソール画面でプラグインのURLを指定するだけで、プラグインをインストールできる仕組みを開発しているようです。（一時期masterブランチから起動すると画面が見れましたが、今は見れなくなっているようです）\nPrivate Cloud (k8s) もう一つの気になる動きとして、MattermostコアチームのチャットでPrivate Cloudというチャンネルが立っており、k8s関係のツールの開発が進んでいるようです。\n mattermost/mattermost-operator: Mattermost Operator for Kubernetes mattermost/mattermost-helm: Mattermost Helm charts for Kubernetes  こちらも全容は掴めておりませんが、OSSプロジェクトらしくドキュメントが公開されているため、興味のある方はそちらを参照してください。 https://drive.google.com/drive/folders/1iayrTYRjQXpdqUAB4pbrnn9QQh_g8oNC\nおわりに 次のv5.15のリリースは2019/9/16(Mon)を予定しています。 そして機能追加が行われるv5.16は恐らく2019/10/16(Wed)のリリースになるかと思います。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/plugin-template/","title":"Mattermostプラグイン用のリポジトリテンプレート","section":"post","date":"2019.07.13","body":"Mattermost Plugin用テンプレートリポジトリ Mattermostにはプラグイン機能があり、サーバーサイド/フロントエンド共に独自の拡張機能を追加することができます。 Mattermostプラグインの開発方法はMattermostプラグインの作り方 · kaakaa blogにも書きましたが、一から作るとなると準備するファイルも多く大変です。\nそこで、Mattermostプラグインの開発を楽にするため、MattermostチームがGitHubのテンプレートリポジトリ機能を利用して作成しているテンプレートリポジトリを使ったプラグイン開発方法について紹介します。\n mattermost/mattermost-plugin-starter-template: Build scripts and templates for writing Mattermost plugins.  このテンプレートリポジトリを使用することで、動作するプラグインがある状態から開発を始めることができ、必要な機能を開発することに集中することができるようになります。\nテンプレートリポジトリを使用してMattermostプラグインを開発する 0. Mattermostプラグイン開発環境について プラグイン開発を行うには下記の開発環境が必要です。\n サーバー側のプラグイン実装を行う場合  Go: 1.12   webapp (フロントエンド) 側のプラグイン実装を行う場合  Node 10.15.3+ npm 6.4.1+   どちらでも必要  GNU Make    プラグイン開発向けの開発環境はまとめられていなようですが、Mattermost本体の推奨環境に沿うのが安全だと思います。\n 参考  https://developers.mattermost.com/contribute/server/developer-setup/ https://developers.mattermost.com/contribute/webapp/developer-setup/    1. テンプレートからリポジトリを作成する まず、テンプレートリポジトリを元に、作成したいプラグイン用のリポジトリを作成します。\nmattermost/mattermost-plugin-starter-templateをブラウザで開くと、Use this templateというボタンがあります。\nこのボタンを押すとリポジトリ作成画面へ遷移するので、そこでリポジトリ名を入力してリポジトリを作成するだけでテンプレートからリポジトリを作成できます。\nテンプレートリポジトリの動作はリポジトリのForkと似ていますが、下記の点でForkとは異なります。\n  新しいフォークは、親リポジトリのコミット履歴すべてを含んでいますが、テンプレートから作成されたリポジトリには、最初は 1 つのコミットしかありません。 フォークへのコミットはコントリビューショングラフに表示されませんが、テンプレートから作成されたリポジトリへのコミットはコントリビューショングラフに表示されます。 フォークは、既存のプロジェクトにコードをコントリビュートするための一時的な方法となります。テンプレートからリポジトリを作成することは、新たなプロジェクトを初めから素早く始める方法です。   引用元: テンプレートからリポジトリを作成する - GitHub ヘルプ\nSecurity Alert テンプレートからリポジトリを作成したときに、セキュリティ脆弱性に関するアラートが出ることがあります。\nこれは、リポジトリが依存しているライブラリに脆弱性が含まれる可能性があることを示しており、本体のテンプレートリポジトリ側でも随時ライブラリのアップデートは行われいますが、リポジトリを作成するタイミングによってはこの通知が出てしまうことがあります。\nリポジトリ内の脆弱な依存関係を表示・更新する - GitHub ヘルプを参考にするなどして、ライブラリのアップデートを行ってください。\nテンプレートリポジトリの内容について テンプレートリポジトリに含まれるファイルは下記の通りとなります。\n. ├── .circleci/ - CircleCI設定ファイル(プロジェクト依存の情報がないのでこのまま使用できます) ├── assets/ - プラグインから利用するファイル(アイコン画像など)の格納先 ├── build/ - Makefileから呼ばれるビルド用のスクリプト格納ディレクトリ 基本的にこのディレクトリのファイルは編集しません。 ├── public/ - (assetsと同じ用途？) ├── server/ - サーバー用のプラグインコードが格納ディレクトリ ├── webapp/ - フロントエンド用のプラグインコードディクトり ├── .editorconfig - editorconfigの設定ファイルです https://editorconfig.org/ ├── .gitignore ├── CHANGELOG.md - 更新履歴を記述ファイル（手動更新） ├── go.mod - Go(サーバープラグイン)の依存ライブラリ管理ファイル ├── go.sum - 同上 ├── LICENSE - Apache License v2のライセンスファイル ├── Makefile - ビルド用のMakefile ├── plugin.json - プラグインのメタデータを記述するファイル ┗── README.md 2. プラグインをビルドする 作成したプラグインをcloneして、ビルドしてみましょう。\n2.1. 前準備 まず、リポジトリをクローンします。\ngit clone --depth 1 https://github.com/mattermost/mattermost-plugin-starter-template 注意: https://github.com/mattermost/mattermost-plugin-starter-templateの部分は作成したリポジトリのURLに変更してください。\nテンプレートリポジトリは、ほぼ何も変えなくてもそのままでビルド・デプロイを行うことができます。ただ、plugin.json に書かれているプラグインのIDなど必ず変更しておくべき箇所が何点かあります。\n plugin.json  https://github.com/mattermost/mattermost-plugin-starter-template/blob/master/plugin.json#L2 idは必ず変更してください。併せてname、descriptionなども変えておくと良いと思います。 このファイルの内容については Manifest Reference を参照してください、   LICENSE  ライセンスの著作権者の欄がプレースホルダーとなっているため、自身の情報に変更しておきましょう https://github.com/mattermost/mattermost-plugin-starter-template/blob/master/LICENSE#L189  Copyright [yyyy] [name of copyright owner] =\u0026gt; Copyright 2019 Yusuke Nemoto     README.md  内容がテンプレートリポジトリのものになっているため更新しておきましょう    上記を変更したら、まずはプラグインをビルドしてみましょう。\n2.2. ビルド $ make 上記コマンドを実行するだけでビルドが完了します。 ビルドが正常に終了すると、dist/というディレクトリが作成され、その中に .tar.gz のファイルがあるはずです。これがMattermostプラグインファイルになります。\nこの .tar.gz ファイルをアップロードすることでMattermostプラグインを有効にすることができます。プラグインのアップロード方法などは下記記事で紹介しているので参照ください。\n https://blog.kaakaa.dev/post/mattermost/plugin_tutorial/  2.3. 動作確認 このテンプレートリポジトリのプラグインが持つ機能は、プラグイン用に新しいエンドポイントを作成するのみのため、動作確認もこれで行います。\n$ curl http://localhost:8065/plugins/${PLUGIN_ID}/ Hello, world! http://localhost:8065はMattermostのSiteURLに、${PLUGIN_ID} は plugin.json に記述したプラグインIDに置き換えて実行してください。\n便利なプラグインアップロード方法 プラグインの開発を始めると、コード修正 -\u0026gt; アップロード -\u0026gt; 動作確認というフローを繰り返すことになります。その度に画面からアップロードするのは面倒です。 そこで、テンプレートリポジトリのMakefileにはコマンドラインからプラグインのビルド -\u0026gt; アップロードを行ってくれるmake deployというタスクがあります。\nこのタスクを実行するには、下記のように環境変数にMattermostサーバーのURLとアップロードするMattermostユーザーの認証情報を設定し、タスクを実行するだけです。\nexport MM_SERVICESETTINGS_SITEURL=http://localhost:8065 export MM_ADMIN_USERNAME=admin export MM_ADMIN_PASSWORD=password make deploy もし、すでに同じIDのプラグインがアップロード済みでも新しいプラグインに上書きを行ってくれます。この方法だと、プラグインのバージョンが下がっている場合でも強制的に上書きされてしまうので注意が必要です。\nこのアップロード方法は開発時のみの利用が推奨されています。\n3. プラグインの開発を開始する プラグインのアップロードが完了し、動作することまで確認できたらあとは機能の開発を進めていくだけです。\nここで、もしサーバー側の機能のみを実装する場合は、webappディレクトリは削除しても構いません。逆にフロントエンド側のみの機能を実装する場合は server ディレクトリを削除できます。この辺りはMakefile内でディレクトリの存在確認を行い、よしなに動作してくれます。\nプラグインの開発については下記のサイトの情報が参考になると思います。\n Plugins (Beta) mattermost/mattermost-plugin-demo: A demo of what Mattermost plugins can do. Mattermostプラグインの作り方 · kaakaa blog  また、Mattermostコアチームによるプラグイン開発に関する会話は下記のチャンネルで行われています。\n https://community.mattermost.com/core/channels/developer-toolkit  "},{"ref":"https://blog.kaakaa.dev/post/concurrent_parallel/","title":"ConcurrentとParallel","section":"post","date":"2019.07.06","body":"はじめに O\u0026rsquo;Reilly Japan - Go言語による並行処理\nを読んでいると、気になるフレーズが出てきました。\n 「並行性はコードの性質を指し、並列性は動作しているプログラムの性質を指します。」\n 「そうなの？」と思い某所で呟いてみると、色々情報が集まったのでまとめます。\nGo言語におけるConcurrent/Parallelの解釈 最初に、「並行性はコードの性質を指し、並列性は動作しているプログラムの性質を指します。」のについて。\n原文では\n Concurrency is a property of the code; parallelism is a property of the running program.\n となっているようです。(参照: O\u0026rsquo;Reilly Concurrency in Goの読書メモ - Qiita)\nまた、Go言語に関する書籍である背景を鑑みると、Rob Pike先生の下記の言葉に基づいた解釈のような気がします。\nConcurrency is not parallelism - The Go Blog  In programming, concurrency is the composition of independently executing processes, while parallelism is the simultaneous execution of (possibly related) computations.\n ここではハッキリとConcurrency is the composition、Parallelism is the simultaneous executionと言っています。それぞれの言葉を具象化するとthe composition ⊃ code、the simultaneous execution ⊃ running programと言い換えられる気がするので、書籍の言葉はここからきているのでは無いかと思われます。\nその他のConcurrent/Parallelに関する話 ここからは余談になりますが、Go言語に限らずConcurrent/Parallelについて語られている情報について触れていきます。\n並列(Parallel)と並行(Concurrent)の違いについて - Togetter このまとめ自体は2011年のものなので古い（とはいえ並行/並列という概念についていえば古いということは無い）ですが、ここから参照されている下記の記事が個人的にはわかりやすかったです。\nparallel と concurrent、並列と並行の違い - 本当は怖い情報科学 このエントリではこのように説明されています。\n  Concurrent（並行）は「複数の動作が、論理的に、順不同もしくは同時に起こりうる」こと Parallel（並列）は、「複数の動作が、物理的に、同時に起こること」   元の「並行性はコードの性質を指し、並列性は動作しているプログラムの性質を指します。」というフレーズに照らして考えてみると、\n Concurrent(並行)は「複数の動作が、論理的に、順不同もしくは同時に起こりうる」ということですので、同時実行されるという事実を記述したコードがConcurrentであるという説明は合っている気がします また、Parallelも同様に「複数の動作が、物理的に、同時に起こること」ということなので、「（複数のコアを使うなどして）動作しているプログラムの性質を刺す」という説明と合うと思います  Concurrent = 論理的 = code、Parallel = 物理的 = 動作するプログラムと考えると、しっくりくるような気がします。 (ただし、後で説明しますがConcurrent/Parallelは対義語などではなく、また並べて比較されるような言葉では無いため、Concurrent/Parallelを論理的/物理的と単純に解釈するのは危険です)\n1. Introduction - Parallel and Concurrent Programming in Haskell [Book]  A parallel program is one that uses a multiplicity of computational hardware (e.g., several processor cores) to perform a computation more quickly. The aim is to arrive at the answer earlier, by delegating different parts of the computation to different processors that execute at the same time.\nBy contrast, concurrency is a program-structuring technique in which there are multiple threads of control. Conceptually, the threads of control execute “at the same time”; that is, the user sees their effects interleaved. Whether they actually execute at the same time or not is an implementation detail; a concurrent program can execute on a single processor through interleaved execution or on multiple physical processors.\n 次に、Haskellに関する書籍でのConcurrent/Parallelの説明。\nこの説明でもConcurrencyはプログラムの構造化技法、Parallel Programは多数のハードウェアを同時に使うものといっており、今までの理解と相違無いように読めます。\nまた、Concurrent(並行)については\n Whether they actually execute at the same time or not is an implementation detail\n と、「実際に同時に実行されるかどうかは実施の詳細による」と、実際の動作についてはConcurrentの範疇ではないと言っています（ここでimplementation=実装と訳すと混乱するため実施と訳しています）。\nまた、Parallel(並列)については、\n The aim is to arrive at the answer earlier, by delegating different parts of the computation to different processors that execute at the same time.\n 「処理高速化を目的に複数の異なるプロセッサで同時に処理を実行すること」と、実施形態について意味していることが分かります。\nここまでで、Concurrentはプログラム技法やコードなど実施形態の構成を表すために使われることが多く、Parallelは実際に複数のプロセッサを使って処理を行うなど実施形態について意味する言葉だと理解することができ、そもそも並べて比べるような言葉でないことが分かってきます。\n\u0026lt;=: Serial vs Parallel, Sequential vs Concurrent 最後にこちらの記事。\nタイトルからConcurrent/Parallelの対義語はそれぞれSequential/Serialだと言っています。 このエントリではConcurrencyをSequentialの対義語、つまり同時発生のような意味合いで使っているためConcurrent is the compositonという捉え方で読むと少し違和感を覚えますが、どのように同時発生的な事象を扱うかという方法論だと捉えると、今までのエントリで言っている事と変わらない気がします。\nそして何より、Concurrent/Parallelそれぞれの対義語を意識することでその違いがより明確になります。\nまた、このエントリの最後の方の例で面白い例があり、並列な実行基盤の上で動作しているSequentianなプロセスはdeterministicであり、並列な実行基盤の上で動作しているConcurrentなプロセスはnon-deterministicであるということです。この概念についてはまだ消化しきれていませんが、Concurrentが同時発生的な概念であると考えると正しい気がします。\nおわりに 本エントリでは、Concurrent/Parallelについて調べました。 ここで挙げた情報源は公式な定義というわけでは無い（あったら教えてください）ため、どこかの解釈に誤りがある可能性があります。ただ、各所で語られている論理をまとめたことで、個人的にはそれぞれの言葉の意味するところが明確になったような気がします。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.12/","title":"Mattermost5.12の新機能","section":"post","date":"2019.06.16","body":"はじめに 2019/6/13にMattermost v5.12.0がリリースされました。 この記事では、アップデートの内容について簡単に紹介していきます。\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost 5.12: Infinite scrolling, bot accounts, deeper Jira integration, and more - Mattermost Private Cloud Messaging Mattermost Changelog — Mattermost 5.12 documentation   アップデート内容 Mattermostへのフィードバック Mattermostの改善を目的とした、ユーザーへのアンケート機能が追加されました。 これにより、Mattermostの使い勝手に関するアンケートメッセージがBotから送信されるようになります。\nMattermostを5.12にアップデートすると、実際にアンケートが送信される前に、システム管理者に対してアンケートが予定されていることを伝える電子メールかダイレクトメッセージが送信されると思います。アンケートは3週間後に設定されているはずです。\n現在、アンケートは英語で送信されるため、アンケートが送信されるとユーザーが混乱してしまう場合など、アンケートをを実施したくない場合は、システムコンソール \u0026gt; プラグイン \u0026gt; Net Promoter Score \u0026gt; Enable Net Promoter Score Surveyを無効に設定してください。\n無限スクロール チャンネル内の古い投稿を見るとき、もっとメッセージを読み込むというリンクをクリックする必要がなくなりました。チャンネルの一番上までスクロールすると、自動で古いメッセージの読み込みが開始されます。\n(この機能はIE11では利用できません)\nBotアカウント MattermostでBot用のアカウントを作成できるようになりました。Botアカウントは電子メールやパスワード、またはその他の認証方法を必要とせずにユーザーとやり取りができるアカウントです。これにより、統合機能用のダミーのアカウントを作る必要がなくなります。\nさらに、Botアカウントは下記のような特徴を持ちます。\n 非公開チーム、非公開チャンネル、ダイレクトメッセージなど、どのチャンネルにも投稿することができます 統合機能をBotアカウントに関連づけておくことで、その統合機能を開発したユーザーが退職した後も統合機能を使い続けることができるようになります Botアカウントはサーバー上の誰もがやり取り可能で、どのチーム、チャンネルにも追加することができます  また、Enterprise版においてBotアカウントはライセンス上のユーザーとしてカウントされません。\nBotアカウントについて詳しくは下記のドキュメントを参照してください。 https://docs.mattermost.com/developer/bot-accounts.html\nJiraプラグインのアップデート MattermostにバンドルされているJiraプラグインのバージョンが2.0になりました。このアップデートにより、MattermostとJiraをより深く統合することができるようになりました。\n Issue作成、更新、コメント追加をMattermostチャンネルに通知 Jira Issueの作成や、Mattermost上のコメントのJira Issueへの反映、また、Issueの状態の更新などをMattermostから実行  より詳しい情報は、下記を参照してください。 https://github.com/mattermost/mattermost-plugin-jira#jira-20-features\nデフォルトプラグインの追加 Mattermost 5.12から、さまざまなプラグインがMattermostにデフォルトでバンドルされるようになりました。\n GitHub Plugin: GitHubの通知やリマインドをMattermostに投稿することができるプラグイン。SaaS版やオンプレミスのGitHub Enterpriseにも対応しています。 Autolink Plugin: あるテキストを自動でハイパーリンク化することができるプラグイン。(例えば、Issue TrackerのIssue番号を投稿すると、自動でリンクに変換してくれます) Custom Attributes Plugin: ユーザープロフィールのポップオーバーに属性を追加するプラグイン Welcome Bot Plugin: 新規メンバーが追加された時にメッセージを通知するプラグイン Amazon SNS CloudWatch plugin: Amazon CloudWatchのアラートをAWS SNS経由でMattermostに通知できるようになるプラグイン。  他にも下記サイトから様々なMattermostの拡張機能を検索することができます。 https://integrations.mattermost.com/\nシステムコンソール画面の再構築 Mattermost 5.12からシステムコンソール画面の構成が変わりました。\nこの変更は、Mattermost Private Cloudなど、システムコンソールを使わず環境変数でMattermostの設定を指定する際に、よりロジカルにしたいという意図があるそうです。\nE20版のみの追加機能  非公開チーム/チャンネルに関する権限の管理を個別に操作することなく、AD/LDPグループを通じて管理できるようになりました。 Elasticsearchの自動補完機能により検索機能を利用する際にユーザー/チャンネルが入力しやすくなりました  モバイルアプリのタブレット向け改善 モバイルアプリ v1.20もリリースされています。\n チャンネルサイドバーが表示され続けるようになりました iOSでキーボードが表示されている際、スワイプダウンすることでキーボードを閉じることができるようになりました  そのほかの変更については下記を参照ください。 https://github.com/mattermost/mattermost-mobile/blob/master/CHANGELOG.md#1200-release\n破壊的変更 Mattermost v5.10以前のバージョンからアップデートをする場合、統合機能に関する下記の破壊的変更があります。\n (v5.12~) プラグインAPI DeleteEphemeralMessage の引数が(userId string, post *model.Post)から(userId, postId string)に変更 (v5.11~) 統合機能で既に投稿されている投稿の内容を更新する際、投稿のProps属性をUpdate.Props == nil のようにnilを指定してクリアする方法は利用できなくなりました。代わりにUpdate.Props == {}のように、空の要素を指定する必要があります。  おわりに 次のv5.13のリリースは2019/7/16(Tue)を予定しています。 そして機能追加が行われるv5.14は恐らく2019/8/16(Fri)のリリースになるかと思います。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost%E3%83%81%E3%83%BC%E3%83%A0%E3%81%8A%E6%B0%97%E3%81%AB%E5%85%A5%E3%82%8A_10%E3%81%AE%E7%94%9F%E7%94%A3%E6%80%A7%E5%90%91%E4%B8%8A%E3%83%8F%E3%83%83%E3%82%AF/","title":"Mattermostチームお気に入り・10の生産性向上ハック","section":"post","date":"2019.05.26","body":"The Mattermost team’s 10 favorite productivity hacks\n先日、Mattermostチームがよく使っている時間節約のためのMattermostのショートカットやハックに関する記事を公開されていましので、内容を紹介します。\n1. /rent-a-carlos MattermostチームのCarlosが開発した、同僚の手を借りるのを簡単にするプラグイン。 /rent-a-carlosのスラッシュコマンドを使って、他のユーザー向けのタスクをダイレクトメッセージとして作成できます。\n2. タイムスタンプを右クリックして投稿へのリンクを取得する Mattermostの投稿へのリンクをは、投稿のドロップダウンメニューから取得できます。しかし、リンクを取得するまでには何回かボタンをクリックする必要があります。\nこの投稿へのリンクは、投稿のタイムスタンプをクリックすることでも取得できるため、タイムスタンプを右クリックしてリンクのアドレスをコピーすることで少し時間を短縮することができます。\n3. TODOリストとしてフラグを利用する TODO管理のアプリケーションを導入する代わりに、Mattermost上の重要なメッセージにフラグを付けることでTODOリストを代用することができます。\n投稿のタイムスタンプの横にあるフラグアイコンをクリックすることでフラグを立てることができ、Mattermost画面右上のフラグアイコンをクリックすることで、今までフラグを立てた投稿の一覧を表示することができます。 フラグを立てた投稿は自分だけが表示可能なため、自分用のTODOリストとして活用することができます。\n4. キーボードショートカット キーボードショットカットではチャンネルの移動やファイルのアップロード、情報の表示などを素早く行うことができます。 CTRL + / (MacではCMD + l)を入力してショートカットメニューを表示してみてください。\n5. SHIFT+UPでスレッドへの返信 SHIFT + UP (MacではOPTION + SHIFT + UP)のショートカットを使うことで特定のスレッドに素早く返信できるようになります。\n6. 検索機能 組織の知識はMattermostに蓄積されているため、多くの人がGoogleを利用するようにMattermostの検索機能を使用しています。 特定の結果を検索するためにfrom:, in:, on:, before:, after: のなどのパラメーターを使って、検索機能を便利にすることができます。\n7. 重要なメッセージをチャンネルにピン留めする フラグは重要なメッセージを内緒でキープすることができる機能です。一方、投稿のピン留めは重要なメッセージをチャンネル内の全員に対してキープする機能です。 投稿のドロップダウンメニューから投稿のピン留めを実行することで、メッセージをチャンネルにピン留めすることができます。ピン留めされたメッセージを確認するにはMattermost画面の右上にある押しピンのアイコンをクリックしてください。\n8. サイドバー構成（実験的な機能） まだ実験的な機能ではありますが、アカウント設定 \u0026gt; サイドバー \u0026gt; チャンネルのグループ化とソートから設定できるサイドバー構成オプションはMattermost上での作業を効率化すると確信しています。 未読メッセージのあるチャンネルをグループ化したり、投稿がもっとも最近行われた順にチャンネルをそーとしたり、全てのチャンネル種別（公開チャンネル・非公開チャンネル・ダイレクトメッセージ）を一つのリストの結合したりできます。\n9. +:絵文字名:による絵文字リアクション Mattermostを使えば使うほど、絵文字の名前に詳しくなっていくはずです。 メッセージ入力欄で+:絵文字名:と入力してメッセージを送信すると、一つ前の投稿に対して絵文字リアクションを付けることができます。少しずつ時間を節約して会話をもっと楽しみましょう。\n10. CTRL + K / CMD + Kによるチャンネル切り替え とても重要なもう一つのショートカットは、実は全てのMattermostインスタンスに目立つように表示されていました。 チャンネル切替 - CTRL + K\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.10/","title":"Mattermost5.10の新機能","section":"post","date":"2019.04.21","body":"はじめに 2019/4/16にMattermost v5.10.0がリリースされました。 この記事では、アップデートの内容について簡単に紹介します。\n変更内容の詳細については公式のリリースを確認してください。\n Mattermost 5.10: Single sign-on for mobile, richer integrations and more - Mattermost Private Cloud Messaging Mattermost Changelog — Mattermost 5.10 documentation   アップデート内容 Interactive ephemeral messages 今まで、MattermostのInteractive Messages(ユーザーが操作可能なボタンやメニューを含む投稿)は、全ユーザーが閲覧可能な形式でしか作成することができませんでした。 今回のバージョンアップにより、自分だけが閲覧可能なInteractive Messagesを作成可能になりました。\nこれにより、例えば個人単位で機能のOn/Offを切り替えられるプラグインなどで自分だけが見れるメッセージにOn/Off切り替えボタンを表示するなど、よりパーソナライズされたメッセージを作成できるようになります。\nこの機能はプラグイン用のAPIから使用できるようです。（Go言語ドライバからは作成することができないようでした。） プラグイン用のサンプルコードは下記になります。\nhttps://gist.github.com/kaakaa/b040bcd0a6fdccc18b3daaea214c6112#file-mm_v5-10_ephemeral_interactive_message-go\n(実験的な機能) Mattermost設定のデータベース化 最近、MattermostではKubernetes環境向けのデプロイやコンテナ化に注力しており、そのために、サーバー間で安定した設定のやり取りを行う方法が求められています。今まで、MattermostのサーバはJSONファイルによって管理されてきましたが、このバージョンからMattermostの設定をデータベースに格納することができるようになりました。\nまだドキュメント化はされていないようですが、mattermost config migrateコマンドで設定できるのだと思われます。 https://github.com/mattermost/mattermost-server/blob/master/cmd/mattermost/commands/config.go#L71\nドキュメント化されてないことからも分かるように、この機能はまだ実験的な機能なため、強い要望が無い限りは使用しないほうが良いと思います。\nその他の変更 Message Attachmentのタイトルに絵文字/ハイパーリンクが利用可能に Message Attachmentsのタイトル部分に絵文字とリンクを使用できるようになりました。 また、Message Attachmentsのボタンには絵文字を使用できるようになりました。\n上記投稿を作るサンプルコードは下記になります。 https://gist.github.com/kaakaa/b040bcd0a6fdccc18b3daaea214c6112#file-mm_v5-10_decoration_message_button-go\nMessage Buttonでは絵文字のみ利用可能に。\nメッセージ入力ボックスにチャンネル名が表示されるように メッセージ入力ボックスに何も入力していない状態の時に表示されるメッセージに、チャンネル名が含まれるようになりました。\nExcel から Markdownテーブルへの変換 Excelのセルをコピーし、そのままMatterostのメッセージ入力欄に貼り付けるとMarkdownテーブル形式に変換して貼り付けてくれる機能が追加されました。 Excelだけでなく、Googleスプレッドシートからでも同様のことが行えます。\n実験的機能がシステムコンソールから設定可能に システムコンソール \u0026gt; 詳細 \u0026gt; 実験的機能から、実験的な機能の設定を行えるようになりました。 細かな設定含めて多くの項目がありますが、サイドバー構成を有効にすることで使えるようになる、「未読チャンネルのグループ化」などは便利です。\nただ、「実験的な機能」とあるように、動作が保証されている機能ではない点に注意が必要です。\nモバイルアプリのアップデート v5.10.0のリリースと同日の4/16にMattermostのモバイルアプリの最新版v1.18.0もリリースされました。 主な変更内容は下記になります。\n Office365 SSO / Integrated Windows Authentication(IWA) のサポート Message Attachmentのタイトルに絵文字やハイパーリンクが使用可能に 投稿を長押しした時のメニューに「返信する」が追加  詳細な変更内容についてはmattermost-mobile/CHANGELOG.md at master · mattermost/mattermost-mobileを参照してください。\n その他 Mattermost Plugin Bounty Program 要望の多いMattermostプラグインについて、報奨金を出してコミュニティに開発してもらおうというMattermost Plugin Bounty Programが公開されています。（４つの募集プラグインについて、すでにすべてコミュニティメンバがアサインされている模様）\nhttps://forum.mattermost.org/t/mattermost-plugin-bounty-program/6857\n募集されているのは下記4つのサービス/OSSのプラグインです。\n Cisco WebEx Meetings Server Skype for Business Jenkins GitLab  開発したプラグインをGitHubにApache 2.0 or MITライセンスで公開することが条件となっているため、これらのプラグインは誰でも利用できる形になるかと思います。\nWrite a Review on Mattermost 「Mattermostについてのレビューを送って$20のギフトカードをもらおう」という旨のキャンペーンが行われています。 （現在でも受け付けているのか、日本でもギフトカードを受け取れるのか、等の詳細については不明です。すいません。）\nCapterra | Review Software\nSoftware Design 3/18発売のSoftware Deisign4月号から、4か月間の短期連載でMattermostに関する紹介記事を書かせていただいています。 書店などで見かけたらぜひ手に取ってみてください。\nhttps://gihyo.jp/magazine/SD\nおわりに 次のv5.11のリリースは2019/5/16(Fri)を予定しています。 そして機能追加が行われるv5.12は恐らく2019/6/16(Tue)のリリースになるかと思います。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.8/","title":"Mattermost5.8の新機能","section":"post","date":"2019.02.18","body":"はじめに 2019/2/15にMattermost v5.8.0がリリースされたので、アップデートの内容について簡単に紹介します。\n詳細については公式のリリースを確認ください。\n Mattermost 5.8: MFA for Team Edition, LDAP group sync, improved image performance and more - Mattermost Private Cloud Messaging Mattermost Changelog — Mattermost 5.8 documentation   アップデート内容 Team Editionに多要素認証機能が追加 コミュニティからの要望として、今までEnterprise Edition限定機能であったGoogle Authenticatorによる多要素認証機能がOSS版であるTeam Editionでも利用できるようになりました。 これにより、悪意のある第三者によるなりすましなどのリスクを低減することができます。 今回Team Editionに追加された多要素認証機能はユーザーが自ら設定を行うことで有効になるものであり、サーバー内すべてのユーザーに多要素認証を強制する設定はEnterprise Edition限定機能のままです。\n多要素認証の設定を行うには、まず システムコンソール \u0026gt; 認証 \u0026gt; 多要素認証 \u0026gt; 多要素認証を有効にする を有効にします。 多要素認証を有効にすると アカウント設定 \u0026gt; セキュリティー \u0026gt; 多要素認証 のメニューが現れるため、多要素認証をあなたのアカウントに追加する をクリックしGoogle Authenticatorの設定を行います。 画面の指示に従い、QRコードをスキャンするかシークレットコードを入力し、アカウントをGoogle Authenticatorに登録します。すると、登録したアカウントの多要素認証コードがGoogle Authenticatorに表示されるので、そのコードを画面下の\u0026quot;多要素認証コード\u0026quot;欄に入力し、「保存」ボタンを押します。 多要素認証コードが正しく入力されると、多要素認証の登録完了画面が表示されます。 以降、このMattermostにログインする際にはユーザー名/パスワードによるサインインの後、多要素認証コードの入力を求める画面が表示されるようになります。ここには登録時と同様、Google Authenticatorで表示される多要素認証コードを入力することでログインを完了することができます。 (E20) LDAPグループ機能の追加 LDAPのグループに基づいてデフォルトのチームやチャンネルのメンバーシップを自動同期できる機能がE20版のベータ機能として追加されています。 グループ同期機能は今後も機能追加が行われる予定であり、E10版でも利用可能になる予定とのことです。\n画像プロキシのデフォルト化 v5.8.0より画像プロキシがデフォルトで有効になりました。今後は画像プロキシによりキャッシュが行われるため、画像を含む投稿の表示が高速になります。また、Mattermost内で通信が完了するため、サードパーティーのサービスを使用するよりプライバシー性の向上が期待できます。\nその他の変更   @channel, @all, @hereなどによるチャンネル全体へのメンションを通知として受け取るかどうかを設定できるようになりました   スラッシュコマンドを実行した際、スラッシュコマンドを実行したチャンネル以外にもメッセージを投稿できるようになりました\n model.CommandResponseに追加されたChannelIdフィールドを指定することで実現できます。（サンプルコード） コマンド実行ユーザーが所属しているチャンネル以外のチャンネルに投稿しようとするとエラーとなります    おわりに 次回のv5.9のリリースは2019/3/15(Fri)を予定しています。 そして機能追加が行われるv5.10は恐らく2019/4/16(Tue)のリリースになるかと思います。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/plugin_tutorial/","title":"Mattermostプラグインの作り方","section":"post","date":"2019.01.01","body":"(追記 2020/04/12)\n本記事でも使用しているdepがもうメンテナンスされておらず、本記事で紹介している内容でMattermostの最新版を利用したプラグインの開発が困難になっているようです。\n今後Mattermostプラグイン開発を始める場合、Mattermostプラグイン用のリポジトリテンプレート でも紹介していますが、Mattermost公式チームがメンテナンスしているテンプレートリポジトリ https://github.com/mattermost/mattermost-plugin-starter-template を利用することを推奨します。\n(追記おわり)\nはじめに 2017/11/16にリリースされたMattermost v4.4.0で、Mattermost自体の機能拡張を行うためのプラグイン機能が追加されました。 その後、2018/08/16にリリースされたMattermost v5.2.0で、破壊的変更となるプラグインアーキテクチャの一新が行われ、現在も新たな拡張ポイントやAPIが追加され続けています。\nMattermostプラグインでは、サーバーサイド(Go言語)とフロントエンド(React.js)両方の拡張が行えます。サーバーサイドを拡張したい場合はGo言語、フロントエンドを拡張したい場合はJavascripnt(React.js)を書くことになります。 Mattermostプラグインを実装することで、新たなユーザーがチーム/チャンネルに参加した際の処理を追加したり、投稿を表すReactコンポーネントを自作のものに置き換えるなど、今まで手を入れることができなかった部分にまで機能追加を行うことができるようになります。\n今回は、簡単な実装例を交えながらMattermostプラグインの作成方法について紹介していきたいと思います。\nこの記事で紹介しているコードは、下記のリポジトリで公開しています。 https://github.com/kaakaa/mattermost-plugin-first (Mattermost v5.6を対象に動作確認を行なっています）\nStep 1: プラグイン開発・アップロード まず、何も機能を持たない空のプラグインを作成し、そのプラグインをアップロードするまでのフローを見ていきます。\nマニフェストファイル Mattermostプラグインの実体は.tar.gz形式のファイルとなります。 .tar.gzファイルの中身として最低限必要なファイルはマニフェストファイルだけです。\nJSON形式(plugin.json)かYAML形式(plugin.yaml)で、プラグインのID、名前、バージョンや実行バイナリのパスなどのメタ情報を記述するファイルです。\nマニフェストファイル記述できる内容については、下記のリファレンスを参照してください。 https://developers.mattermost.com/extend/plugins/manifest-reference/\nまず、下記のようにマニフェストファイルを作成します。\n{ \u0026#34;id\u0026#34;: \u0026#34;org.kaakaa.mattermost-plugin-first\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Mattermost Plugin Sample\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;このプラグインはQiita記事用のMattermostプラグインです。\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34; } プラグイン作成 上記のマニフェストファイルを含む.tar.gzファイルを作成するため、下記のようなMakefileを作成します。（makeの環境がない場合は、手動でコマンドを実行しても構いません）\nPLUGIN_ID ?= org.kaakaa.mattermost-plugin-first PLUGIN_VERSION ?= 0.0.1 BUNDLE_NAME ?= $(PLUGIN_ID)_$(PLUGIN_VERSION).tar.gz build: rm -rf dist/ mkdir -p dist/$(PLUGIN_ID) cp plugin.json dist/$(PLUGIN_ID)/ cd dist \u0026amp;\u0026amp; tar -cvzf $(BUNDLE_NAME) $(PLUGIN_ID) @echo plugin built at: dist/$(BUNDLE_NAME) make buildを実行することでdist/org.kaakaa.mattermost-plugin-first_0.0.1.tar.gzというファイルが作成されます。\nプラグインアップロード用の設定 作成したプラグインをアップロードしていきます。 まず、プラグインをシステムコンソールからアップロードできるようにするために、Mattermostサーバーの設定ファイル(config.json)を編集します。\n... }, \u0026#34;PluginSettings\u0026#34;: { \u0026#34;Enable\u0026#34;: true, \u0026#34;EnableUploads\u0026#34;: true, \u0026#34;Directory\u0026#34;: \u0026#34;./plugins\u0026#34;, ... Mattermost設定ファイル内のPluginSettingsにあるEnableとEnableUploadsをtrueにし、Mattermostサーバーを再起動します。\nプラグインのアップロード Mattermostの システムコンソール \u0026gt; プラグイン(ベータ版) \u0026gt; 管理画面からプラグインをアップロードします。\nファイルを選択する ボタンを押し、先ほど作成したdist/org.kaakaa.mattermost-plugin-first_0.0.1.tar.gzを選択し、アップロードボタンを押すことでプラグインがアップロードされます。 プラグインが正常にアップロードされるとインストール済みプラグインに表示されます。\nアップロードされたプラグインの有効にするボタンを押すことでプラグインを有効にすることができますが、現在はプラグインの実装が行われていないため、エラーメッセージ「このプラグインを起動できませんでした。エラーに関するシステムログを確認してください。」が表示されるはずです。\nStep 2: サーバーサイドプラグインの実装 Step 1で作成したプラグインにサーバーサイドの実装を加えていきます。 serverというディレクトリを作成し、そこにGoコードを書いていきます。\nroot/ ├ dist/ │ └ org.kaakaa.mattermost-plugin-first_0.0.2.tar.gz ├ server/ │ ├ main.go │ ├ plugin.go │ └ Gopkg.toml └ plugin.json 依存ライブラリの管理にはgolang/depを使用しています。\nmain.go まずGo言語のmainメソッドでMattermostプラグインを認識させるためにplugin.ClientMainメソッドを呼び出し、自作のPlugin用の構造体(FirstPlugin)を読み込ませます。\npackage main import \u0026#34;github.com/mattermost/mattermost-server/plugin\u0026#34; func main() { plugin.ClientMain(\u0026amp;FirstPlugin{}) } この自作のFirstPlugin構造体にプラグインの実装を追加していきます。\nplugin.go FirstPlugin構造体に最低限求められるのは、plugin.MattermostPluginを継承することです。 plugin.MattermostPluginを継承することでMattermostプラグインとして認識され、この構造体の持つAPIというフィールドを通じてプラグイン用の各種APIを実行できるようになります。 実際のAPIの呼び出し方については、次のhooks.goのセクションで説明しています。\npackage main import \u0026#34;github.com/mattermost/mattermost-server/plugin\u0026#34; type FirstPlugin struct { plugin.MattermostPlugin } これでサーバーサイドのプラグインを実装することはできましたが、このプラグインはまだ何の機能も持っていません。 Mattermost本体の動作に影響を及ぼすには、いずれかのHooksを実装する必要があります。\nhttps://developers.mattermost.com/extend/plugins/server/reference/#Hooks\nhooks.go ここでは、MessageWillBePostedのHooksを実装し、Mattermost上にQiitaのリンクを含む投稿が行われた際に自動で#Qiitaというハッシュタグを付与する機能を実装していきます。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/mattermost/mattermost-server/model\u0026#34; \u0026#34;github.com/mattermost/mattermost-server/plugin\u0026#34; ) func (p *FirstPlugin) MessageWillBePosted(c *plugin.Context, post *model.Post) (*model.Post, string) { if strings.Index(post.Message, \u0026#34;https://qiita.com/\u0026#34;) == -1 { return post, \u0026#34;\u0026#34; } p.API.LogDebug(\u0026#34;Qiita link is detected.\u0026#34;) post.Message = fmt.Sprintf(\u0026#34;%s #Qiita\u0026#34;, post.Message) post.Hashtags = fmt.Sprintf(\u0026#34;%s #Qiita\u0026#34;, post.Hashtags) return post, \u0026#34;\u0026#34; } MessageWillBePostedメソッドを実装することで、ユーザーから投稿されたメッセージがDBに保存される直前に実行される処理を記述できます。 ここでは、投稿内容にhttps://qiita.com/というURLを含む場合に、自動で#Qiitaというハッシュタグを付与するよう実装になっています。\n途中でp.API.LogDebugというメソッドを利用してログ出力を行なっています。このメソッドを通じて出力されたログは下記のように システムコンソール \u0026gt; ログ に出力されます。\n 2018-12-31T21:42:59.988+0900\tdebug\tapp/plugin_api.go:623\tQiita link is detected.\t{\u0026ldquo;plugin_id\u0026rdquo;: \u0026ldquo;org.kaakaa.mattermost-plugin-first\u0026rdquo;}\n Gopkg.toml ここまで書けたら、依存ライブラリを取得するためにdepコマンドを使用します。\nserverディレクトリ配下でdep initを実行することで、依存ライブラリの検出・取得を行うことができます。\n$ cd server $ dep init ビルド サーバーサイドの実装を含むプラグイン .tar.gzファイルを作成していきます。\nまず、plugin.jsonにサーバーサイドのプラグインを認識させるためにserverというセクションを追加します。\n{ \u0026#34;id\u0026#34;: \u0026#34;org.kaakaa.mattermost-plugin-first\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Mattermost Plugin Sample\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;このプラグインはQiita記事用のMattermostプラグインです。\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.2\u0026#34;, \u0026#34;server\u0026#34;: { \u0026#34;executables\u0026#34;: { \u0026#34;linux-amd64\u0026#34;: \u0026#34;server/dist/plugin-linux-amd64\u0026#34;, \u0026#34;darwin-amd64\u0026#34;: \u0026#34;server/dist/plugin-darwin-amd64\u0026#34;, \u0026#34;windows-amd64\u0026#34;: \u0026#34;server/dist/plugin-windows-amd64.exe\u0026#34; }, \u0026#34;executable\u0026#34;: \u0026#34;\u0026#34; } } serverセクションには、.tar.gzファイル内のGoバイナリの位置を指定します。executableセクションでは各OSごとのバイナリを指定することもできます。\nplugin.jsonに書かれた構成通りに.tar.gzファイルが作成されるよう、Makefileを下記のように修正します。\nPLUGIN_ID ?= org.kaakaa.mattermost-plugin-first PLUGIN_VERSION ?= 0.0.2 BUNDLE_NAME ?= $(PLUGIN_ID)_$(PLUGIN_VERSION).tar.gz build: mkdir -p server/dist cd server \u0026amp;\u0026amp; env GOOS=linux GOARCH=amd64 GO build -o dist/plugin-linux-amd64 cd server \u0026amp;\u0026amp; env GOOS=darwin GOARCH=amd64 GO build -o dist/plugin-darwin-amd64 cd server \u0026amp;\u0026amp; env GOOS=windows GOARCH=amd64 GO build -o dist/plugin-windows-amd64.exe rm -rf dist/ mkdir -p dist/$(PLUGIN_ID) cp plugin.json dist/$(PLUGIN_ID)/ mkdir -p dist/$(PLUGIN_ID)/server/dist cp -r server/dist/* dist/$(PLUGIN_ID)/server/dist cd dist \u0026amp;\u0026amp; tar -cvzf $(BUNDLE_NAME) $(PLUGIN_ID) @echo plugin built at: dist/$(BUNDLE_NAME) make buildを実行することでサーバーサイドの実装を含むプラグインファイルが作成されます。\nプラグインアップロード・有効化 先ほどと同様、システムコンソール \u0026gt; プラグイン(ベータ版) \u0026gt; 管理 よりプラグインファイルをアップロードし、同画面から有効にするリンクをクリックしてプラグインを有効化します。今度は「このプラグインは起動中です。」というメッセージが表示されると思います。\n動作確認 まとめ 以上のように、Mattermostプラグインのサーバーサイドの実装を行うことができます。 今回は触れませんが、サーバーサイドの拡張ポイント(Hooks)は他にも数多くあるのでユースケースに合致する組み合わせを探して見てください。\nhttps://developers.mattermost.com/extend/plugins/server/reference/#Hooks\n OnActivate / OnDeactivate  プラグインを有効化/無効化した時に呼ばれるメソッド このメソッド内でRegisterCommand/UnregisterCommandのAPIを実行し、スラッシュコマンドを追加するようなプラグインで利用することができます (ExecutedCommandのHooksも実装する必要がある)   ExecutedCommand  プラグインを通じて追加されたコマンドが実行された時に呼ばれるメソッド   ServeHTTP  プラグイン専用のエンドポイントを追加することができます 追加されたエンドポイントのルートは ${MATTERMOST_SITEURL}/plugins/${PLUGIN_ID}/ になります   OnConfigurationChange  プラグインの設定が変更された時に呼び出されるメソッドです マニフェストファイルにsetting_schemaセクションを追加することで、プラグインの設定画面が出現します    Step 3: フロントエンドプラグインの実装 最後にフロントエンドプラグインの実装について見ていきます。\nフロントエンドの拡張ポイントは下記に挙げられています。 https://developers.mattermost.com/extend/plugins/webapp/reference/#registry\n今回はregisterChannelHeaderButtonActionを使い、チャンネルヘッダーボタンから投稿を作成するサンプルを作っていきます。\nroot/ ├ dist/ │ └ org.kaakaa.mattermost-plugin-first_0.0.3.tar.gz ├ server/ │ ├ ... ├ webapp │ ├ src/ │ │ ├ index.js │ │ └ action.js │ ├ package.json │ └ webpack.config.js └ plugin.json index.js プラグインの読み込みと実装をindex.jsというファイルに書いていきます。\nconst React = window.React; const {Glyphicon} = window.ReactBootstrap; import {createPluginPost} from \u0026#39;./action\u0026#39; window.registerPlugin(\u0026#34;org.kaakaa.mattermost-plugin-first\u0026#34;, new Plugin()); class Plugin { initialize(registry, store) { registry.registerChannelHeaderButtonAction( \u0026lt;Glyphicon glyph=\u0026#34;pencil\u0026#34; /\u0026gt;, (channel) =\u0026gt; { createPluginPost(channel.id)(store.dispatch, store.getState) }, \u0026#39;First Plugin\u0026#39;, \u0026#39;This is plugin tooltip\u0026#39;, ) } } フロントエンドプラグインはwindow.registerPluginメソッドにプラグインIDとプラグインを実装したクラスのインスタンスを与えることで読み込まれます。 プラグイン実装クラス(Plugin)はinitializeメソッドを持ち、このメソッドの第一引数であるregistryが持つメソッドを呼び出すことで機能を追加することができます。\n今回はチャンネルヘッダーボタンを追加する部分を実装するため、registry.registerChannelHeaderButtonActionを呼び出しています。\nこのメソッドの第１引数には、ボタンのアイコンとなるReact要素を指定します。\nMattermostプラグインではReact Bootstrapがexportされているため、const {Glyphicon} = window.ReactBootstrap;と書くことでReact Bootstrapの機能をimportすることができます。(exportされているライブラリ一覧はExported Libraries and Functions)。\n第２引数にボタンが押された時の動作を記述します。今回は投稿を作成するcreatePluginPostという処理をactionsとして実装しました。 第３引数には、複数のプラグインがregisterChannelHeaderButtonActionを実装していた場合に、ドロップダウンメニューとして使われるテキストです。 第４引数にはチャンネルヘッダボタンのツールチップテキストです。\naction.js チャンネルヘッダーボタンを押した時に行われる処理をaction.jsに書いています。 MattermostのJavascriptドライバーであるmattermost-reduxを利用して、簡単なメッセージを投稿する機能を下記のように実装しています。\nimport {createPost} from \u0026#39;mattermost-redux/actions/posts\u0026#39;; import {getCurrentUserId} from \u0026#39;mattermost-redux/selectors/entities/users\u0026#39;; export function createPluginPost(channelId) { return async (dispatch, getState) =\u0026gt; { const state = getState(); const userId = getCurrentUserId(state) const post = { channel_id: channelId, user_id: userId, message: \u0026#34;Post from webapp plugin\u0026#34;, } return await dispatch(createPost(post)); } } ビルド まず、plugin.jsonにフロントエンドのプラグインを認識させるためにwebappというセクションを追加します。\n{ \u0026#34;id\u0026#34;: \u0026#34;org.kaakaa.mattermost-plugin-first\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Mattermost Plugin Sample\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;このプラグインはQiita記事用のMattermostプラグインです。\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.3\u0026#34;, \u0026#34;server\u0026#34;: { \u0026#34;executables\u0026#34;: { \u0026#34;linux-amd64\u0026#34;: \u0026#34;server/dist/plugin-linux-amd64\u0026#34;, \u0026#34;darwin-amd64\u0026#34;: \u0026#34;server/dist/plugin-darwin-amd64\u0026#34;, \u0026#34;windows-amd64\u0026#34;: \u0026#34;server/dist/plugin-windows-amd64.exe\u0026#34; }, \u0026#34;executable\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;webapp\u0026#34;: { \u0026#34;bundle_path\u0026#34;: \u0026#34;webapp/dist/main.js\u0026#34; } } 実装してきた.jsファイルを、マニフェストファイルで指定したしたwebapp/dist/main.jsにバンドルされるようにwebpack.config.jsを用意します。 （フロントエンドに明るくないので公式のサンプルをベースにしています）\nvar path = require(\u0026#39;path\u0026#39;); module.exports = { entry: [ \u0026#39;./src/index.js\u0026#39;, ], resolve: { modules: [ \u0026#39;src\u0026#39;, \u0026#39;node_modules\u0026#39;, ], extensions: [\u0026#39;*\u0026#39;, \u0026#39;.js\u0026#39;, \u0026#39;.jsx\u0026#39;], }, module: { rules: [ { test: /\\.(js|jsx)$/, exclude: /node_modules/, use: { loader: \u0026#39;babel-loader\u0026#39;, options: { presets: [\u0026#39;@babel/preset-env\u0026#39;,\u0026#39;@babel/preset-react\u0026#39;], plugins: [ \u0026#39;transform-class-properties\u0026#39;, \u0026#39;@babel/plugin-proposal-object-rest-spread\u0026#39; ], }, }, }, ], }, externals: { react: \u0026#39;React\u0026#39;, redux: \u0026#39;Redux\u0026#39;, \u0026#39;react-redux\u0026#39;: \u0026#39;ReactRedux\u0026#39;, }, output: { path: path.join(__dirname, \u0026#39;/dist\u0026#39;), publicPath: \u0026#39;/\u0026#39;, filename: \u0026#39;main.js\u0026#39;, }, }; 下記のようなpackage.jsonを用意し、npm installしてからnpm run buildを実行し、正常にコマンドが完了すれば準備は完了です。\n{ \u0026#34;name\u0026#34;: \u0026#34;webapp\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.3\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Post today\u0026#39;s metal from channel header button\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;src/index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;webpack --mode=production\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;mattermost-redux\u0026#34;: \u0026#34;^5.6.2\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@babel/core\u0026#34;: \u0026#34;^7.2.2\u0026#34;, \u0026#34;@babel/plugin-proposal-object-rest-spread\u0026#34;: \u0026#34;^7.2.0\u0026#34;, \u0026#34;@babel/preset-env\u0026#34;: \u0026#34;^7.2.3\u0026#34;, \u0026#34;@babel/preset-react\u0026#34;: \u0026#34;^7.0.0\u0026#34;, \u0026#34;babel-loader\u0026#34;: \u0026#34;^8.0.4\u0026#34;, \u0026#34;babel-plugin-transform-class-properties\u0026#34;: \u0026#34;^6.24.1\u0026#34;, \u0026#34;babel-plugin-transform-object-rest-spread\u0026#34;: \u0026#34;^6.26.0\u0026#34;, \u0026#34;webpack\u0026#34;: \u0026#34;^4.28.3\u0026#34;, \u0026#34;webpack-cli\u0026#34;: \u0026#34;^3.1.2\u0026#34; } } 最後にルートディレクトリにあるMakefileを下記のように編集し、でmake buildを実行することで、フロントエンドプラグインを含むプラグイン.tar.gzファイルがdistディレクトリ内に作成されるはずです。\nPLUGIN_ID ?= org.kaakaa.mattermost-plugin-first PLUGIN_VERSION ?= 0.0.3 BUNDLE_NAME ?= $(PLUGIN_ID)_$(PLUGIN_VERSION).tar.gz build: mkdir -p server/dist cd server \u0026amp;\u0026amp; env GOOS=linux GOARCH=amd64 GO build -o dist/plugin-linux-amd64 cd server \u0026amp;\u0026amp; env GOOS=darwin GOARCH=amd64 GO build -o dist/plugin-darwin-amd64 cd server \u0026amp;\u0026amp; env GOOS=windows GOARCH=amd64 GO build -o dist/plugin-windows-amd64.exe cd webapp \u0026amp;\u0026amp; npm run build; rm -rf dist/ mkdir -p dist/$(PLUGIN_ID) cp plugin.json dist/$(PLUGIN_ID)/ mkdir -p dist/$(PLUGIN_ID)/server/dist cp -r server/dist/* dist/$(PLUGIN_ID)/server/dist mkdir -p dist/$(PLUGIN_ID)/webapp/dist; cp -r webapp/dist/* dist/$(PLUGIN_ID)/webapp/dist/; cd dist \u0026amp;\u0026amp; tar -cvzf $(BUNDLE_NAME) $(PLUGIN_ID) @echo plugin built at: dist/$(BUNDLE_NAME) プラグインアップロード・有効化 先ほどと同様、システムコンソール \u0026gt; プラグイン(ベータ版) \u0026gt; 管理 よりプラグインファイルをアップロードし、プラグインを有効化します。\n動作確認 まとめ 以上のように、Mattermostプラグインのフロントエンドの実装を行うことができます。 他にも多くの拡張ポイントがあるので、実装方法については公式のサンプルリポジトリの実装を参照してみてください。 https://github.com/mattermost/mattermost-plugin-demo\nおわりに 以上がMattermost severプラグインの開発方法になります。\n今まではMattermostを他のシステムと連携する場合、連携機能専用のサーバーを立ち上げなければならず、連携機能が増えるたびにサーバーを運用する手間が増えていましたが、プラグイン機能を使うことで運用の手間をMattermostインスタンスに一元化することができます。\nまた、プラグイン機能では今まで以上に細かな動作にまで手を加えることができるようになりました。 例えば、mattermost/mattermost-plugin-antivirusのようにファイルがアップロードされた際に、そのファイルに対してセキュリティのチェックをかけたりできるようになります。\nSlackとは違い、オンプレミスでの運用もメインターゲットとなるMattermostでは、プラグイン機能によるインフラ運用コストの削減や、企業特有のポリシーを実装するための細かなカスタマイズ性は非常に大きなメリットとなります。 プラグイン実装にまつわる本体のアップデートの追従などのメンテナンスコストは今後問題となる可能性がありますが、その辺りをどのようにクリアしていくかを含め、開発に協力しながらウォッチしていければと思います。\n参考資料 開発者向けドキュメント  https://developers.mattermost.com/ https://github.com/mattermost/mattermost-developer-documentation  このサイトでは、プラグイン開発についてだけでなく、その他の統合機能であるウェブフックやスラッシュコマンドなどの開発方法や、Mattermostへのコントリビュート手順などについてもまとめられています。\nサンプルプラグイン  https://github.com/mattermost/mattermost-plugin-demo  公式で開発されているデモ用のプラグインです。 プラグイン向けに提供されている拡張ポイントの多くを利用しているので、実装する際の参考になると思います。\n https://github.com/mattermost/mattermost-plugins  このリポジトリでは、Official/Unofficial問わずMattermostプラグイン開発プロジェクトのGitHubリポジトリがまとめられています。 文書よりも動くコードのほうが分かりやすいという方には参考になると思います。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.6/","title":"Mattermost5.6の新機能","section":"post","date":"2018.12.16","body":"はじめに 2018/12/14にMattermost 5.6.0がリリースされたので、アップデートの内容について簡単に紹介します。\n詳細については公式のリリースを確認ください。\n Mattermost Changelog — Mattermost 5.6 documentation Mattermost 5.6: Interactive message dialogs, new admin tools, Ukrainian language support and more - Mattermost Private Cloud Messaging   2018/11/16にMattermost 5.5.0がリリースされていましたが、事前の予告通りBug Fixと小さな改善しかなかったため記事は書きませんでした。 今後も目ぼしい昨日がなければ奇数バージョンのリリースについては記事を書かないつもりです。\n Mattermost Changelog — Mattermost 5.6 documentation Mattermost 5.5: Web conferencing integration, Hacktoberfest contributions and more - Mattermost Private Cloud Messaging   アップデート内容 インタラクティブダイアログ インタラクティブボタンやスラッシュコマンドなどの連携機能への操作に対して、ダイアログを表示することができるようになりました。\nInteractive Dialogs — Mattermost 5.6 documentation スラッシュコマンドからダイアログを呼び出す場合のサンプルコードは下記のようになります。 https://gist.github.com/kaakaa/1f87869f0d6520a2f645f8af014be1a5\nユーザー体験の向上 ダイレクトメッセージ作成画面で、グループメッセージを検索可能に ダイレクトメッセージの追加画面で、グループメッセージ（複数人でのダイレクトメッセージ）を検索できるようになりました。 ファイルアップロード時のプログレスバー ファイルをアップロードした際に、アップロード完了までのプログレスバーが表示されるようになりました。\n管理者バッジ 投稿者のアイコンをクリックすることで開くプロフィールポップオーバーに、管理者であることを示すバッジが表示されるようになりました。\nその他の改善 管理者向けコマンドラインツール改善 mattermostコマンドにウェブフックやカスタムスラッシュコマンドを操作するコマンドなどが追加されています https://docs.mattermost.com/administration/changelog.html#command-line-interface-cli\nスラッシュコマンドに複数レスポンス スラッシュコマンドを実行した際、複数のレスポンスを一度に返せるようになりました。\nサンプルコード: https://gist.github.com/kaakaa/b040bcd0a6fdccc18b3daaea214c6112\nWebRTC機能の廃止 ベータ版として提供されていたWebRTC機能が廃止されました。代わりにZoom, BigBlueButton, Kopanoなどのプラグインの使用が推奨されています。 https://forum.mattermost.org/t/built-in-webrtc-video-and-audio-calls-removed-in-v5-6-in-favor-of-open-source-plugins/5998\nサポート言語の追加 ウクライナ語がサポートされ、サポート言語が16言語になりました。また、ルーマニア語がベータ版として追加されています。 その他にもチェコ語、セルビア語、スウェーデン語の翻訳作業も始まっているようです。\nまた、シンガポール国立大学がMattermostを採用したというニュースもありました。 下記の記事ではコストとスケーラビリティの点でMattermostが採用されるまでの経緯が綴られています。 The National University of Singapore chooses Mattermost for student-faculty collaboration - Mattermost Private Cloud Messaging\nモバイルアプリの改善  メンションのハイライト ピン留め機能のサポート ジャンボ絵文字のサポート ネットワーク問題が発生した際の自動再接続機能によるネットワーク接続の改善  その他のアップデート内容については下記を参照ください https://github.com/mattermost/mattermost-mobile/blob/master/CHANGELOG.md#1150-release\nデスクトップアプリ Mattermostデスクトップアプリ v4.2.0のリリースも行われています。 https://mattermost.com/download/#mobile\n Ctrl/CMD+F でMattermostのメッセージが検索できるようになりました 英語・ポルトガル語・スペイン語(スペイン/メキシコ)のスペルチェック機能が追加されました コンピューターの電源をONにした際に自動で起動する設定がデフォルトで有効になりました（アプリの設定で無効にすることもできます） MacOS向けの .dmg インストーラーが追加されました  その他のアップデート内容については下記を参照ください https://github.com/mattermost/desktop/blob/master/CHANGELOG.md#release-v420\nおわりに 次回のv5.7のリリースは2019/1/16(Fri)を予定しています。 そして機能追加が行われるv5.8は恐らく2019/2/15(Fri)のリリースになるかと思います。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.4/","title":"Mattermost5.4の新機能","section":"post","date":"2018.10.27","body":"はじめに 2018/10/16にMattermost 5.4.0がリリースされたので、アップデートの内容について簡単に紹介します。\n詳細については公式のリリースを確認ください。\n Mattermost Changelog — Mattermost 5.4 documentation Mattermost 5.4: User-focused features, new data export tool, mobile enhancements and more - Mattermost Private Cloud Messaging   アップデート内容 ユーザーの生産性向上のための改善 メッセージ作成中の表示 メッセージ作成中に別のチャンネルに移動した際、チャンネルの表示アイコンが変更されるようになり、送信前のメッセージが残っていることが一目でわかるようになりました。 サイドバーとチャンネル切替画面で確認できます。\nジャンボ絵文字 絵文字だけの投稿を行った際、絵文字が大きく表示されるようになりました。 大きさは ### :+1: と同じぐらいなので、Markdown形式で # :+1: とすればより大きな絵文字を表示することもできます。\nダイレクトメッセージ・グループメッセージを指定した検索 以前より、メッセージ検索ボックスで in: と入力することで検索対象のチャンネルを指定して検索することができましたが、v5.4から in: でのチャンネル指定にダイレクトメッセージチャンネルとグループメッセージチャンネルを指定できるようになりました。\nメッセージ入力ボックスの拡張 長いメッセージを入力する際、メッセージ入力ボックスの高さが今まで以上に拡張されるようになりました。 v5.3以前は7行程度までの表示でしたが、v5.4以降は13行ほど表示できるようになっています。\nInteractive Messageにセレクトメニューが追加 Interactive Messageのアクションとして、ボタンだけでなくセレクトメニューを指定できるようになりました。\nコードブロックのCTRL + ENTERでの送信 アカウント設定 \u0026gt; 詳細 \u0026gt; CTRL + ENTER でメッセージを投稿するをオフにしている場合に限り、アカウント設定 \u0026gt; 詳細 \u0026gt; CTRL + ENTERでコードブロックメッセージを送信しますというメニューが現れます。 これを オン にすると、”```” で始まるコードブロック入力中はENTERキーで改行を入力でき、その状態でCTRL + ETNERを押すとコードブロック終了の ”```” を入力しなくてもコードブロックとしてメッセージを送信することができます。\nピン留めされたメッセージの更新 ピン留めされた投稿のサイドバーを開いた状態でチャンネルを切り替えると、ピン留めされた投稿のサイドバーの内容も切り替え先のチャンネルの内容に切り替わるようになりました。\nMattermostサーバーの統合 新たなデータエクスポート用のCLIツールが追加され、複数のMattermostサーバーをマージできるようになりました。 このツールで現在エクスポート可能なデータは、基本的なデータである投稿・ユーザー・返信・チーム・チャンネルのみですが、コミュニティによってより多くのデータが対象になるよう改善が進められています。\nBulk Export Tool — Mattermost 5.4 documentation Bulk Loading Data — Mattermost 5.4 documentation\n10月中に開催されているHacktoberを利用して多くの機能拡張が行われている最中です。Search · bulk export\n管理機能 参加/脱退メッセージの非表示オプション アカウント設定 \u0026gt; 詳細 \u0026gt; 参加/脱退メッセージを有効にする をオフにすることで、ユーザーがチャンネルに参加・脱退した時に表示されるシステムメッセージを非表示にすることができるようになりました。\n数百人が参加するようなチームだとタウンスクエアなどのチャンネルが参加通知ばかりになり会話をしにくいこともあるため、そのような場合に有効な設定です。\nチーム管理者に他ユーザーの投稿の編集権限を付与するかの設定 システムコンソール \u0026gt; 全般 \u0026gt; ユーザーとチーム \u0026gt; チーム管理者が他者の投稿を編集できるようにする からチーム管理者に他ユーザーの投稿を編集する権限を付与するかどうかを設定することができるようになりました。 この設定に関わらずシステム管理者は常に他ユーザーの投稿を編集することができます。\nコンプライアンス E20: カスタム利用規約 E20版限定ですが、利用者独自の利用規約を設定し、その規約に同意しないと利用できないよう設定することができるようになりました。 企業・組織内で運用する場合に必要になる機能かと思います。\nシステムコンソール \u0026gt; カスタマイズ \u0026gt; 法的事項とサポート \u0026gt; カスタム利用規約を有効にする(ベータ版) から設定することができます。\nモバイルアプリの改善  投稿に対するハッシュタグを利用することができるようになりました リアクション絵文字を長押しすることで、誰がリアクションしたかを確認できるようになりました iPhone XR、 XS、 XS Maxのサポートが追加されました  おわりに 次回のv5.5のリリースは2018/11/16(Fri)を予定しています。\n次回のリリースから、Mattermostは新しいリリースサイクルを採用し、奇数月のリリースはバグフィックスなどの品質向上に関する修正のみを加えたリリース、偶数月に新規機能の追加を含むリリースを行うそうです。\nDocument minimum server version for plugin API methods by hanzei · Pull Request #9616 · mattermost/mattermost-server\n Mattermost is moving to a different release cycle starting in October, where\n every second month we have a feature release (October, December, February, ..), and every second month we have a quality/bug fix release (November, January, ..). So given this is not a bug fix, it\u0026rsquo;s shipped in v5.6 by default.    Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.3/","title":"Mattermost5.3の新機能","section":"post","date":"2018.09.20","body":"はじめに 2018/09/14にMattermost 5.3.0がリリースされたので、アップデートの内容について簡単に紹介します。\n詳細については公式のリリースを確認ください。\n Mattermost Changelog — Mattermost 5.3 documentation Mattermost 5.3: Enhanced search on desktop and mobile, plugin hackathon highlights and more - Mattermost Private Cloud Messaging   v5.3.0のリリース作業でミスがあり翻訳が一部壊れています。英語以外の翻訳版を利用されている場合はv5.3.1を利用してください。 Mattermost 5.3.1 released - Mattermost Private Cloud Messaging\nアップデート内容 日付指定検索 Mattermostメッセージ検索機能で投稿日付を指定できるようになりました。\n before:YYYY-MM-DD: 指定日付より前の投稿を検索 on:YYYY-MM-DD: 指定日付に行われた投稿を検索 after:YYYY-MM-DD: 指定日付より後の投稿を検索  また、右上の検索欄にafter:、on:、before:を入力することで、日付選択モーダルが現れます。\nSAMLユーザーへのID設定 ID ProviderとしてSAMLを設定している場合、過去に無効化されたユーザーと同じメールアドレスを持つユーザーを新たに追加すると、無効化されたユーザーの履歴にアクセスできてしまうという問題がありました。 この問題を解決するために、メールアドレスの代わりとなるIDを指定することができるようになりました。 IDを指定することができるようになったことにより、結婚による姓の変更などに起因するメールアドレスの変更にも対応できるようになりました。\nプラグインハッカソンの成果 2018/8/16,17に行われたMattermostプラグインハッカソンで開発されたプラグイン機能の紹介です。\n RSS feed: RSSのフィードを行えるプラグインのようです RSSのフィードを購読する連携機能のようです。この機能はプラグインではないですが、プラグインハッカソン中に開発された成果として紹介されていたようです Webcome bot: 新しくチームに加入したユーザーにウェルカムメッセージを投稿できます Matterpoll: Mattermost上で投票を行える機能です /remind: 指定した時間が経過した後にリマインドをしてくれるプラグインです。 Crosspost: つのチャンネルを複数のMattermostサーバーとリンクすることができ流ようです Auto-translator: Amazon Translateを使って様々な言語を英語に自動変換するプラグインです  その他にもリッチなエディタ機能を追加するプラグインや、表示時間をユーザーのローカルタイムゾーンに合わせてくれるプラグインなどの開発が行われています。 また、Mattermost CTOによるハッカソンの振り返りやプラグインのビデオチュートリアルなどが公開されています。\nその他 リックソフトがMattermostとパートナー契約を締結 ニュースリリース：20180920 リックソフト Slackライクなオンプレミス型チャットツール Mattermostのパートナー契約を締結\nアトラシアン社のパートナー企業として有名なリックソフト社がHipChat Server販売終了を受け、Mattermostとのパートナー契約を締結したそうです。 私の知る限りでは、国内初のパートナー企業となるかと思います。（他にあったらゴメンナサイ） Mattermost Partner Programs — Mattermost 5.3 documentation\nMatterpoll 現在、Mattermostプラグイン機能を活用した投票機能であるMatterpollというOSSを開発しています。 まだ安定バージョンではないため今後も破壊的変更が入る可能性は高いですが、もしご興味がある方がいらっしゃいましたら導入・Contributeをお願いします。 matterpoll/matterpoll: Poll command for Mattermost\nおわりに 次回のv5.4のリリースは2018/10/16(Tue)を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.2/","title":"Mattermost5.2の新機能","section":"post","date":"2018.08.23","body":"はじめに 2018/08/16にMattermost 5.2.0がリリースされたので、アップデートの内容について簡単に紹介します。\n詳細については公式のリリースを確認ください。\n Mattermost 5.2: Upgraded plugin system, search archived channels, Romanian language support and more - Mattermost Private Cloud Messaging Mattermost Changelog — Mattermost 5.2 documentation   v5.2.0でアーカイブ後のチャンネル内容を検索できる機能が追加されましたが、この機能に不具合が発生している為、この機能をデフォルトでOffとする変更を加えたv5.2.1のリリースに向けた作業が進んでいます。もし、同様の事象が発生している場合は修正版のリリースをお待ちください。\nアップデート内容 プラグインシステムのアップデート Mattermost v4.4からベータ版として利用可能だったプラグイン機能のアーキテクチャが刷新されました。\nこのアップデートにより、下記のような機能が利用可能になっています。\n プラグインからのログ出力 - 新しいロギングAPIを使ってMattermost本体のサーバーログにプラグインからログを出力できるようになりました カスタムWebSocketイベント - サーバーサイドでプラグイン独自のWebSocketイベントを送信できるようになり、また、クライアントサイドでそのイベントを扱う機能が追加されました APIの拡張 - サーバーサイド・クライアントサイド共に利用できるAPIが追加されました CLIでの管理 - Mattermostのコマンドラインインターフェースからプラグインを直接管理できるようになりました  このアップグレードにより、以前のアーキテクチャー向けに開発されたプラグインは動作しなくなっています。以下のマイグレーションガイドを参考に新しいプラグインアーキテクチャーに対応してください。 Migrating Plugins from Mattermost 5.1 and earlier\n今回の変更の詳細については、Mattermostフォーラムの投稿にまとめられています。 Plugin System Upgrade in Mattermost 5.2 - Announcements - Mattermost Peer-to-Peer Forum\nかいつまむと\u0026hellip;\n MattermostのUIコンポーネントを拡張する際、今までは単一の(React)コンポーネントを複数のプラグインから拡張することはできませんでしたが、今回のアップグレードにより可能になりました 今まではサーバーサイドのプラグインにGo言語のプラグイン機構を使用していましたが、今回のアップデートからhashicorp/go-pluginを使用するようになりました  より詳しく知りたい場合は、デモプラグイン　や　サンプルプラグイン、または開発者向けドキュメントなどを参考にしてください。\n (モバイルアプリはプラグインにまだ対応していないようなので、モバイルアプリをよく利用する環境の場合はプラグインインストール時に注意してください)\nアーカイブされたチャンネルの検索 Mattermostの画面からアーカイブされたチャンネルを閲覧・検索できるようになりました。 詳細については公式ドキュメントを確認してください。\n埋め込みMattermost(ベータ版) OAuth2.0を通じて、Mattemostを別のアプリやウェブサイトに埋め込むことができるようになりました。 詳しく知りたい場合は、サンプルのChromeエクステンションや、公式ドキュメントを参照してください。\n (サイト内チャットのような埋め込みではなく、Mattermost起動ボタンを配置できるようになったということですかね？)\nルーマニア語のサポート 今バージョンよりMattermostの表示言語にルーマニア語が選択可能になりました。 現在、Mattemostでは15言語をサポートしています。\n日本語の翻訳ももちろんあり、下記サイトから翻訳作業を行うことができますので気になる点があれば報告をお願いします。 Welcome | Mattermost Translation Server\nモバイルアプリでのディープリンク パーマリンクよりMattermostのモバイルアプリが自動で開くようになりました。 Android、iOSアプリ共に対応しています。\n詳しくは公式ドキュメントを参照してください。\nその他 アンチウイルスプラグイン(ベータ版) mattermost/mattermost-plugin-antivirus: Antivirus plugin for scanning files uploaded to Mattermost ClamavNetを利用して、Mattermostへアップロードしたファイルのウイルススキャンを行うプラグインのようです。\nGitHubプラグイン(ベータ版) mattermost/mattermost-plugin-github: Experimental GitHub plugin for Mattermost Written for Mattercon Hackathon 2018 GitHubと連携するプラグインです。GitHub Enterpriseで使おうとしましたが、まだバグがあるようで動きませんでした。\nプラグインハッカソン'18 プラグインアーキテクチャーの刷新を記念して、オンラインカンファレンスサービスであるZoomを利用したVirtual Hackasonが8/16,17に開催されました。 Virtual Hackathon! | Meetup\nハッカソン向けのプラグインアイデア集は下記に記載されています。 https://docs.google.com/spreadsheets/d/1Xxy4J7wtchtCMXVBxl0TL2h0uHOet96w6KIGFKuwYvs/edit#gid=0\n後日、ハッカソンで開発したプラグインを披露する場が設けられていたのですが、そちらの模様は下記にアップロードされています https://drive.google.com/drive/folders/1cJJZVUYax33GFoE6ckRT9TSL3kLfScya\nおわりに 次回のv5.3のリリースは2018/9/14(Fri)を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.1/","title":"Mattermost5.1の新機能","section":"post","date":"2018.07.23","body":"はじめに 2018/07/16にMattermost 5.1.0がリリースされたので、アップデートの内容について簡単に紹介します。\n詳細については公式のリリースを確認ください。\n Mattermost 5.1: New GIF selector, auto-linking plugin, subpath support and more - Mattermost Private Cloud Messaging Mattermost Changelog — Mattermost 5.1 documentation  アップデート内容 Gfycat MattermostでGIF動画を簡単に入力できるようになりました。 絵文字選択メニューからGfycatのGIF動画を検索・選択し、入力することができます。\nシステムコンソール \u0026gt; カスタマイズ \u0026gt; GIF(Beta) \u0026gt; GIF選択機能を有効にするから、この機能の有効/無効を切り替えられます。 GfycatのAPIキーを設定する必要がありますが、最初から利用可能なAPIキーが入力されているため、自分のAPIキーを使いたいなどの理由がない限り変更する必要はありません。\nGIFアニメーションの表示をOFFにしたい場合、/collapseというメッセージを投稿することでGIFの自動表示をOFFにすることができます。 自動表示を再度ONにする場合は/expandというメッセージを投稿してください。\nAutolink 投稿がデータベースに保存される直前に処理を追加できるプラグインAPIを利用したAutoLinkプラグインの紹介です。\nmattermost/mattermost-plugin-autolink: Automatically rewrite text matching a regular expression into a markdown link.\nこれにより、ある特定の文字列を入力した場合に自動でリンク文字列に変換することができます。\nAutoLinkプラグインの最新リリースバージョンはv0.3.0ですが、このバージョンはMattermost v5.2で導入される新しいプラグイン機構に基づいて作成されているため、Mattermost v5.1で利用する場合はAutoLinkプラグイン v0.2.0を利用してください。\nサブパスでのMattermostのホスト https://mattermost.example.com/mattermostのようなサブパスでのMattermostのホスティングが可能になりました。 システムコンソール \u0026gt; 全般 \u0026gt; 設定 \u0026gt; サイトURL でサブパスを含むURL(https://mattermost.example.com/mattermost)を設定し、サーバーを再起動することで有効になります。\nモバイルアプリ  アナウンスバナーでのMarkdown記法がサポートされました Android向けにドロワーレイアウトの方法を変更し、チャンネルの切り替えがし易くなりました プッシュ通知から投稿を取得する際の読み込み速度の向上  そのほか、多くの改善が行われています。 mattermost-mobile/CHANGELOG.md at master · mattermost/mattermost-mobile\nまた、先月リリースされたv1.9.0で正常に日本語入力ができないという問題がありましたが、2018/7/4にリリースされたv1.9.3にて解消されています。\n(E20) コンプライアンスレポートのアップグレード 参加、脱退、ファイルアップロードなどのイベントのCSV形式でのエクスポートが可能となりました。 コンプライアンスエクスポート機能はE20ライセンスのみの機能になります。\nCSVエクスポートのサンプルファイルが下記よりダウンロードできます。 https://github.com/mattermost/docs/blob/master/source/samples/csv_export.zip\nおわりに 次回のv5.2のリリースは2018/8/16を予定しています。\n Mattermost 日本語(@mattermost_jp)さん | Twitter でMattermostに関する日本語の情報を提供しています。\n"},{"ref":"https://blog.kaakaa.dev/post/growi%E3%81%8B%E3%82%89mattermost%E3%81%B8webhook%E9%80%9A%E7%9F%A5%E3%82%92%E8%A9%A6%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F/","title":"GrowiからMattermostへWebhook通知を試してみた","section":"post","date":"2018.07.08","body":"はじめに Growiではイベントの通知先としてSlack Incoming Webhookを指定することができます。 Slack代替OSSであるMattermostはWebhookの仕様もSlackに準拠しているため、Slack Incoming Webhook通知の機能を利用してMattermostへ通知を送れるか試してみました。\n 動作環境  Growi 3.1.12 Mattermost 5.1.0-rc1    Mattermostの設定 まず、Mattermost側にGrowiからのWebhookを受け取るための内向きのウェブフックを作成します。 別記事にて内向きのウェブフックの作成手順について書いたものがありますので、こちらの手順については下記の記事を参考にしてください。 参考: esa.ioからMattermostへのWebhook送信を試してみた\n作成したMattermostの内向きのウェブフックのURLをコピーしておきます。\nGrowiの設定 次にGrowiの設定を行います。\n管理 \u0026gt; 通知設定より通知設定画面を開き、Webhook URLにMattermostで作成した内向きのウェブフックのURLを入力します。 \u0026lt;img alt=\u0026ldquo;スクリーンショット 2018-07-07 23.33.30.png\u0026rdquo; src=\u0026ldquo;https://qiita-image-store.s3.amazonaws.com/0/9891/b1c969f0-862e-10d7-baad-f719142031a5.png\u0026quot; width=\u0026ldquo;70%\u0026quot;Saveボタンを押すことでGrowi側の設定は完了です。\n通知の確認 Growi側で新しい投稿を作成します。\nここで、Mattermostへの通知を送信するには、投稿作成画面の右下にあるSlack通知のチェックボックスをチェックし、その隣の通知先欄に通知を送信したいMattermostのチャンネルのIDを入力する必要があります。 MattermostのチャンネルIDはチャンネルのURLから確認できます: https://${SITE_URL}/${TEAM}/channels/${チャンネルID}。\n上記の通知先の指定を行なってからGrowiの投稿を作成すると、Mattermostへ下記のような通知が送信されます。\n"},{"ref":"https://blog.kaakaa.dev/post/esa.io%E3%81%8B%E3%82%89mattermost%E3%81%B8%E3%81%AEwebhook%E9%80%81%E4%BF%A1%E3%82%92%E8%A9%A6%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F/","title":"esa.ioからMattermostへのWebhook送信を試してみた","section":"post","date":"2018.07.07","body":"はじめに esa.ioのWebhook送信先としてMattermostが選べるようになったので試してみました。 ReleaseNotes/2018/06/21/Discord・Microsoft Teams・MattermostへのWebhookを追加しました - docs.esa.io\n使用しているMattermostのバージョンはMattermost v5.1.0-rc1になります。\nMattermostの設定 まず、Mattermost側にesa.ioからのWebhookを受け取るための内向きのウェブフックを作成する必要があります。\nMattermostのメインメニューから統合機能を選択します。 統合機能のメニューから内向きのウェブフックを選択し、内向きのウェブフックを追加するボタンを押します。 ウェブフックを作成する際に必須の項目はタイトルと、通知を投稿するチャンネルのみですので、この２つは必ず指定してください。その他の情報は必要に応じて指定してください。 入力か完了したら保存するボタンを押します。\nすると、新しい内向きのウェブフックが作成されるため、表示されているURLをコピーしておきます。 これでMattermost側の設定は完了です。\nesa.ioの設定 次にesa.ioの設定を行います。\nhttps://{team}.esa.io/team/webhooksよりウェブフックのメニューを開き、Add webhookボタンを押します。 ウェブフックのメニューからMattermostを選択し、Incoming Webhook URLに、先ほどコピーしたMattermostの内向きのウェブフックのURLをペースとします。 Labelやチェックボックスなどは必要に応じて変更してください。今回は投稿を作成した際に通知が飛ぶようにするため、**on post create (only ShipIt)**にチェックをしています。 Saveボタンを押してウェブフックが作成されたらesa.ioの設定も完了です。\n通知の確認 esa.io側のウェブフックの設定を行なった段階で、Mattermostへ通知が飛びます。 Mattermostで内向きのウェブフックを作成した時に選択したチャンネルを開いてみましょう(\\( ⁰⊖⁰)/)。 次に、esa.io側で新しい投稿を作成し、ShipItします。 すると、Mattermostの方に通知が飛びます。 投稿されるメッセージはesa.io側のChange logの内容のようです。 リンクになっているesa.ioへの通知テストをクリックすると、esa.ioで作成された投稿へ飛ぶことができます。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-5.0/","title":"Mattermost5.0の新機能","section":"post","date":"2018.06.18","body":"はじめに 2018/06/15にMattermost 5.0.0がリリースされたので、アップデートの内容について簡単に紹介します。\n詳細については公式のリリースを確認ください。\n Mattermost 5.0: Intercept and modify posts, advanced permissions, longer posts and more – Mattermost Mattermost Changelog — Mattermost 5.0 documentation  メジャーバージョンアップについて Upcoming Changes with Mattermost v5.0 - Announcements - Mattermost Peer-to-Peer Forum 今回メジャーバージョンアップが行われた理由として、Enterprise版向けの高度な権限設定機能を追加するにあたり、データベースへ大きな変更が必要となったことが挙げられています。 また、データベースへの影響の他にも今回のメジャーバージョンアップにより以下の変更が行われています。\n サイトURLの設定が必須に Mattermost APIv3の廃止 管理者向けCLIツールの名称がplatformからmattermostに変更  その他のアップデートにおける注意点について、詳しくはImportant Upgrade Notesを参照してください。\nアップデート内容 プラグインによる投稿の検閲 Mattermostのプラグインに、投稿内容がデータベースに保存される直前・直後に処理を差し込めるAPIが追加されました。 Hooks.MessageWillBePosted\nこの機能を使うことで、有害な言葉を含む投稿をできなくしたり、個人情報のような重要な文字列を別の言葉に置き換えることなどができるようになります。\n以下のリンクから、Mattermost CTOによるこの機能の解説動画を見ることができます。\n Coming soon: (APIv4) Mattermost Post-Intercept - YouTube Coming soon: (APIv4) Mattermost Post-Intercept - Feature Idea Discussion / Design Feedback Request - Mattermost Peer-to-Peer Forum  上記YouTube動画の書き起こし    また、Mattermostプラグインの開発方法については下記のドキュメントを参考になります。 Plugins (Beta)\n(E10/E20)高度な権限設定 Enterprise版の機能として、チーム/チャンネル/投稿の作成・修正・削除に関する権限設定を柔軟に行えるようになりました。\n権限設定はJSONファイルとしてエクスポート/インポートすることもできます。\nまた、E20プランの場合、追加で下記のような権限設定も可能となります。\n システム全体の設定だけでなくチームごとに権限設定可能 追加のチャンネル権限設定(読取専用チャンネルの作成、@all/@channel/@hereの使用制限、メンバー管理の制限) ユーザー単位やLDAPのグループ単位の権限付与  この機能についての開発チーム/ビジネスチームに対するデモの様子がYouTubeに上がっています。\nMattermost | Permission Schemes demo - YouTube Mattermost 5.0 | Advanced Permissions Demo and Q\u0026amp;A - YouTube\nまた、権限管理機能に関する今後のロードマップについては、下記で触れられています。 Upcoming Permissions changes: Schemes, Roles, Guest Accounts, Channel Permissions - Announcements - Mattermost Peer-to-Peer Forum\nPhase 1 (v4.9, April 2018): Backend work already implemented. No visible changes for end users or Admins. Phase 2 (v5.0, June 2018): Permission Schemes. Phase 3 (Q4 2018): Channel Permissions and Guest Accounts. Phase 4 (Q1 2019): Supplementary Roles to grant individuals extra permissions. Phase 5 (TBD): Supplementary Roles that can be synced with and granted to AD/LDAP groups. チャンネル管理の権限設定や、ゲストアカウントの作成等が2018/4Qに予定されています。 ゆくゆくはAD/LDAPグループとMattermostの権限管理の同期も挙げられており、エンタープライズユーザーに対して親和性のあるコミュニティ基盤を目指していることが見て取れます。\n投稿の最大文字数の拡大 今まで一つの投稿に含められる最大の文字数は4,000文字でしたが、今回のバージョンから最大文字数が16,383文字に引き上げられました。 これにより、大きなMarkdownのテーブルなども投稿可能になります。\nこの機能を有効にするには使用しているデータベースのマイグレーションが必要になります。\n使用しているデータベースがMySQLの場合は\nALTER TABLE Posts MODIFY COLUMN Message TEXT; PostgreSQLの場合、\nALTER TABLE Posts ALTER COLUMN Message TYPE VARCHAR(65535) を実行し、Mattermostを再起動することで有効になります。 Postsテーブルが巨大な場合、パフォーマンスに影響が出る可能性があるため、ユーザーの少ない時間帯に実行することが推奨されています。\nEnterprise版の機能がTeam Edition(OSS版)に Enterprise版でしか使用できなかった下記の機能がOSS版であるTeam Editionでも使用可能となりました。\nカスタムブランディング  Custom Branding Tools — Mattermost 5.0 documentation   ログイン画面に組織独自の画像やテキストを設定可能に 設定: システムコンソール \u0026gt; カスタマイズ \u0026gt; 独自ブランド設定  チーム毎のテーマ設定  チーム毎にMattermost画面のテーマカラーを変更可能に 設定: アカウント設定 \u0026gt; 表示 \u0026gt; テーマ \u0026gt; (テーマ変更後全ての自分のチームに新しいテーマを適用するのチェックを外して更新)  パスワードルールの設定  パスワードのルール(パスワードの最低の長さ、英数字記号を必須とするかなど)を設定可能に 設定: システムコンソール \u0026gt; セキュリティ \u0026gt; パスワード  参加・脱退メッセージの結合 今まではチャンネル参加/脱退メッセージが一つ一つ投稿されていましたが、これらのメッセージが連続した場合、まとめて表示されるようになりました。\nモバイルアプリの改善  Androidユーザー向けの初回ロード時間の改善 プッシュ通知画面の改善  その他の変更点についてはmattermost-mobile/CHANGELOG.md at master · mattermost/mattermost-mobileを参照してください。\nデスクトップアプリの改善  メモリキャッシュ削除間隔の見直しによるパフォーマンス改善 新しい\u0026quot;Enable GPU Hardware acceleration\u0026quot;オプションによる安定性の向上、および動作可能時間の改善 UI更新によるUXの改善  その他の変更点についてはdesktop/CHANGELOG.md at master · mattermost/desktopを参照してください。\nその他 Extended Support Release いくつかの顧客からの要望を受け、Mattermost v4.10について１年間のセキュリティバックポートが行われます。 毎月のアップデートが負担になっている場合、作業負荷を軽減することができるようになります。\nおわりに 次回のv5.1のリリースは2018/7/16を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-4.1/","title":"Mattermost4.10の新機能","section":"post","date":"2018.05.19","body":"はじめに 2018/05/16にMattermost 4.10.0がリリースされたので、アップデートの内容について簡単に紹介します。\n詳細については公式のリリースを確認ください。\n Mattermost 4.10: Up to 90% faster first load time – Mattermost Mattermost Changelog — Mattermost 4.10 documentation  アップデート内容 メッセージ読み込みの高速化 ページを更新した後、メッセージを読み込む速度が以前より90%以上も高速化されたようです\n公開チャンネルを非公開チャンネルに 既存の公開チャンネルを非公開チャンネルに変更できるようになりました。 途中から協力会社の方々がチームに加入し、今までの会話を見えないようにしくてはいけない状況などに有効です。\n非公開チャンネルに変更しても、今まで投稿されたメッセージは残ります。 ただし、チャンネルに貼られたファイルへのリンクURLなどは、非公開チャンネルに変更してもアクセス可能なままとなる点に注意が必要です。 また、非公開チャンネルを公開チャンネルに変更することはできません。\nモバイルアプリのアップデート  画像ダウンロード高速化 チャンネルミュート(v4.9.0~)のサポート フラグを付けた投稿と@でメンションされた投稿へサイドバーのボタンからアクセス可能に 検索画面で投稿が日付で分割して表示されるように 無効化されたユーザーがメンバーリストから除外されるように  その他のアップデート内容については下記リンクから https://github.com/mattermost/mattermost-mobile/blob/master/CHANGELOG.md#v180-release\nその他 Mattermost v5.0 次回のリリース(2018/6/15)はMattermost v5.0のリリースになるようです。\nv5.0で行われる破壊的変更については、今の所下記にまとめられています。\nUpcoming Deprecated Features in Mattermost v5.0\n APIv3の廃止 CLIツールとして配布されているplatformコマンドの名称変更 サイトURL設定の必須化 デスクトップ通知持続時間設定の廃止 スラッシュコマンド実行時のGETリクエスト送信方式の変更 自動リンク設定の追加(リンクとして認識されるプロトコル(現在はhttp,mailtoなど)をシステムコンソールから指定可能に) チーム削除APIのpermanentパラメータ無効化設定の追加 ChannelモデルからExtraUpdateAtフィールドの削除 [E20] CSVコンプライアンスエクスポートの刷新  Mattercon Mattermostの社員やコントリビューターを集め、ポルトガル・リスボンで行われたMattercon2018の報告が上がっています。\nハイライト MatterCon 2018 Community Meetup Highlights – Mattermost\nハッカソン MatterCon 2018 Hackathon Highlights – Mattermost\nパネルディスカッション https://www.youtube.com/watch?v=3NWCIoys6vM\u0026amp;t=645s\nMattercoin 毎月6日あたりから開始される新バージョンのRelease Candidateのテストに協力するとMattercoinというコインが貰えるようです。\nEarn a Mattermost Bug Hunter Coin - YouTube\nおわりに 次回のv5.0のリリースは2018/6/15を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-4.9/","title":"Mattermost4.9の新機能","section":"post","date":"2018.04.17","body":"はじめに 2018/04/16にMattermost 4.9.0がリリースされたので、アップデートの内容について簡単に紹介します。\n詳細については公式のリリースを確認ください。 Mattermost 4.9: Muted channels, team icons, Global Relay and more – Mattermost Mattermost Changelog — Mattermost 4.9 documentation\nアップデート内容 チャンネルのミュート デスクトップ通知やメール通知の有無をチャンネルごとに設定できるミュート機能が追加されました。\nスラッシュコマンド /mute を実行することで、現在のチャンネルをミュートすることができます。 /mute ~[チャンネル名]とすることで、指定したチャンネルをミュートすることもできます。\nミュートされたチャンネルはチャンネル名の文字色が薄くなります。(上記画像ではタウンスクウェアチャンネル) また、メンションがあった場合のチャンネル横の通知数は表示されたままになります（上記画像ではミュート機能のテストチャンネル）\nチームメイトの名前の表示方法 チームメイトの名前の表示方法を柔軟に設定できるようになりました。 ユーザー名/ニックネーム/氏名から選ぶことができます。\nシステム管理者は システムコンソール \u0026gt; 全般 \u0026gt; ユーザーとチーム \u0026gt; チームメイトの名前の表示 から、この設定のデフォルト値を設定することができます。\nチームアイコンのカスタマイズ 左サイドバーに表示されるチームアイコンを設定することができるようになりました。 チームの設定 \u0026gt; チームアイコン からアップロードすることができます。\nGlobal Relayコンプライアンスの自動エクスポート(E20) E20プランの顧客を対象に、組織内のポリシーを遵守するためのGlobal Relay形式でのメッセージの自動エクスポートができるようになりました。 (v4.5からActiance XML形式のエクスポートには対応していました)\nモバイルアプリのエンハンス 先日リリースされたモバイルアプリ 1.7.0 versionでは、下記のような機能追加が行われました。\n 他のアプリからMattermostへの添付ファイルを共有できるようになりました Markdown形式のテーブルを確認することができるようになりました (投稿の?)パーマリンクをアプリ内で開くことができるようになりました(今までは別ブラウザが立ち上がっていました) アナウンスバナーが表示されるようになりました アプリが今までより素早く立ち上がるようになりました  Coming Soon: Advanced Permissions(E10, E20) 顧客からの要望を受け、より細かな権限管理が行えるようになります。 今回のリリースではバックエンドの変更のみのため、ユーザーから行える変更はまだありません。\n今後、顧客の要望に合わせた様々な権限設定を予定しており、2018年夏リリース予定のMattermost5.0で次のフェーズを公開するつもりです。\nその他 公式Docker compose 今回のリリースに伴う変更により、Breaking Changeとなりそうな変更が加えられています。（未確認） Release 4.9.0 · mattermost/mattermost-docker\nホスト上のディレクトリをマウントしている場合に、UID/GIDを適切に設定しなくてはならなくなったようです。 また、Mattermostアプリケーションの起動ポートについて、以前は80番ポートを使用していましたが、今回のリリースから8000番ポートを利用するように変更されたため、設定変更が必要となる場合があります。\n公式のdocker-compose.ymlを利用している場合は注意してください。\nMattermost 5.0で廃止となる機能 2018年夏リリース予定のMattermost v5.0で廃止となる機能についての議論が開始されています。 以前からアナウンスされていたAPI v3の廃止のほか、管理用のCLIツールであるplatformコマンドの名称変更などが予定されています。 Upcoming Deprecated Features in Mattermost v5.0\nTwitter: mattermost_jp １年ほど更新の無かったMattermostの日本語版Twitterアカウントですが、Mattermostに関する日本語のツイートがほぼ毎日あるのに更新がないのは勿体無いと思い、Mattermostチームからログイン権限をもらいMattermostに関する情報の発信を始めました。 Mattermostに関する日本語の情報をツイートしているので、フォローいただければと思います。 Mattermost 日本語(@mattermost_jp)さん | Twitter\nベストエフォートで運営しています。\nおわりに 次回のv4.10.0のリリースは2018/5/16を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-4.8/","title":"Mattermost4.8の新機能","section":"post","date":"2018.03.18","body":"はじめに 2018/03/16にMattermost 4.8.0がリリースされたので、アップデートの内容について簡単に紹介します。\n詳細については公式のリリースを確認ください。 Mattermost 4.8: Faster loading assets with Amazon CloudFront and simplified SAML migration – Mattermost Mattermost Changelog — Mattermost 4.8 documentation\nアップデート内容 Amazon CloudFrontサポート 画像やJavaScriptファイルなどの静的リソースをAmazon CloudFrontでホストできるようになりました。 これにより、キャッシュのパフォーマンスが改善され、Mattermostのチームメンバーが世界中に散らばっていても短いロード時間でMattermostを使用することができます。\n設定方法については以下のドキュメントを参照してください。 Configuring CloudFront to host Mattermost static assets — Mattermost 4.8 documentation\nSAMLマイグレーションコマンド(E20) ユーザーを簡単にSAML 2.0へマイグレートできるコマンドラインツールが追加されました。 認証にOkta, OneLogin, Microsoft\u0026rsquo;s Active Directyory Federation Serviceを使用している会社でシングルサインオンが可能になります。\nプラットフォームの改善  DBクエリやWebSockeイベントの最適化によりロード時間が短縮されました 20MB以上のファイルをアップロードが可能となるiOSのエンドポイントが作成されました タブレット画面でチャンネルヘッダーを見やすくの検索バーの変更など、Webアプリにいくつかの修正が行われました プロフィール写真への属性追加など508complianceの改善が行われました  508complianceとは、身体障害を持つ人に対するアクセシビリティを向上することを義務付けた米国の法律だそうです リハビリテーション法第508条 - Wikipedia   内向きのウェブフックがマルチパートやフォームを受け入れられるようになりました  Extended Support Release 現在、Mattermostは毎月16日に新しいバージョンをリリースし、３リリース前までセキュリティ修正のバックポートを行うというポリシーでリリースが行われていますが、 Mattermostの顧客やコミュニティメンバーからリリース頻度を落として欲しいという要望が上がっているようです。\nそこで、最大で1年間セキュリティ修正などのクリティカルな修正をバックポートするExtended Support Releaseを作成する案が検討されており、それについて意見を募集しています。 Extended Support Release Discussion\nその他(APIv3について) 先月のリリースでAPIv3がdeprecatedとなりましたが、APIv3はMattermost v5.0で削除される予定です。 APIv3からAPIv4へのマイグレーションについては下記を参考にしてください。 Mattermost API Reference\n気になるMattermost v5のリリース時期ですが、「v5で削除される機能のアナウンスは２ヶ月前の6月にするのが良いだろう」という話がされているので8/16になるのかな、と思っています。 おわりに 次回のv4.9.0のリリースは2018/4/16を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-4.7/","title":"Mattermost4.7の新機能","section":"post","date":"2018.02.17","body":"はじめに 2018/02/16にMattermost 4.7.0がリリースされたので、追加された機能などについて簡単に紹介します。\n詳細については公式のリリースを確認ください。 Mattermost 4.7: Enhanced image preview and thumbnails, faster load times, upgraded desktop app – Mattermost Mattermost Changelog — Mattermost 4.7 documentation\nまた、Compliance Export機能に問題があったようで、近々v4.7.1のリリースが予定されています。\n新機能 画像サムネイルの改善 画像サムネイルの見た目が改善されました。\n添付画像ファイルが一つの場合、サムネイルが自動で拡大表示されるようになっています。\n複数ファイルが添付された場合のサムネイル表示も若干変更されています。 ダウンロードボタンが付与されたことで、プレビューを開かずにダウンロードができるようになっています。\nロード時間の短縮  カスタム絵文字のロードが非同期処理となり、最初のページンのロード時間が高速化されました チャンネル名の補完処理が最適化されました 不要なメタデータを削除したことで、ほとんどの画像のサイズが25%以上削減され、パフォーマンスが改善されました  画像プロキシ クライアントからの画像のリクエストをプロキシサーバーへ直接送信することができるようになりました。 これにより、画像はプロキシサーバーにキャッシュされるためパフォーマンスが向上します。また、画像がキャッシュされるため、リンク先の画像が消失することを心配する必要がなくなりました。\n不要な場合にフルサイズの画像をダウンロードする必要もなくなりました。 さらに、willnorris/imageproxyを利用すると、画像のリサイズなどが可能となるImageProxyOptionの設定ができるようになります。\n画像プロキシは システムコンソール \u0026gt; ファイル \u0026gt; ストレージ から設定できます。\nDesktopアプリ 4.0 デスクトップアプリのメジャーアップデート版であるv4.0がリリースされています。 desktop/CHANGELOG.md at beta-4.0 · mattermost/desktop\n UX改善: 予期せずアプリが終了した際に再度アプリを開くためのダイアログや、ビデオ通話のためにマイクやあカメラへのアクセスを求めるダイアログなどが追加されました。また、ページをロードしている間、Mattermostアイコンのアニメーションが表示されるようになりました。 ディープリンク: mattermost://を通じたディープリンクプロトコルをサポートしました。ユーザーがmattermost://で始まるリンクをクリックすることで、デスクトップをアプリを開いたり、特定のチャンネルへジャンプすることができます。 デプロイの簡易化: 管理者がエンドユーザーへMattermostデスクトップアプリをサイレントデプロイするのがとても簡単になりました。  これらの新機能の他にアーキテクチャーの変更も行われています。\n\u0026lsquo;未読\u0026rsquo; サイドバー設定 未読メッセージのあるチャンネルをサイドバーの一番上にまとめて表示する実験的な機能を追加しました。 Account Settings — Mattermost 4.7 documentation\nMattermostの設定ファイルconfig.jsonのExperimentalGroupUnreadChannelsの設定値をdefault_onもしくはdefault_offとすると、アカウント設定 \u0026gt; サイドバー \u0026gt; 未読チャンネルのグループ化 より未読チャンネルをグループ化するかの設定を行うことができます。 ExperimentalGroupUnreadChannelsの設定値がdisabledだと、サイドバーのメニューが表示されません。\nその他のサイドバーに関する改善にも取り組んでいるそうです。\nその他(APIv3について) 先月のリリースでAPIv3がdeprecatedとなりましたが、APIv3はMattermost 5.0で削除される予定です。 APIv3からAPIv4へのマイグレーションについては下記を参考にしてください。 Mattermost API Reference\nおわりに 次回のv4.8.0のリリースは2018/3/16を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-4.6/","title":"Mattermost4.6の新機能","section":"post","date":"2018.01.27","body":"はじめに 2018/01/16にMattermost 4.6.0がリリースされたので、追加された機能などについて簡単に紹介します。\n詳細については公式のリリースを確認ください。 Mattermost 4.6: Faster channels, enhanced 508 compliance – Mattermost Mattermost Changelog — Mattermost 4.6 documentation\n新機能 今回のリリースでは年末年始の休暇を挟んだこともあり、大きな新機能のリリースは無く、改善系の更新が多かった模様です。\nWebアプリのパフォーマンス改善 MattermostのWebアプリのパフォーマンスが改善されました。\n 同じチーム内でチャンネルを切り替える際の時間が、最大で45%ほど短縮されたようです チャンネルを切り替えた際のメモリ使用量が最大で85%削減されたようです アイコンやロゴのサイズも70-80%ほど削減されたようです  通知設定のデフォルト値の更新 デフォルト通知設定がMattermostユーザー・コミュニティによって推奨された設定に変更されたようです。\n デスクトップ通知はメンションとダイレクトメッセージがあった時のみ通知されます モバイルプッシュ通知はユーザーが離席中かオフラインの時のみ通知され、オンラインの際は通知されません ファーストネームでのメンションでは通知されません  上記の通設定は、アカウント設定よりいつでも変更できます。\nAPIv4が公式APIに 今回のリリースより、APIv3がdeprecatedになり、APIv4が公式のAPIとなりました。 APIv3はサポート対象外となり、Mattermost5.0で削除されます。\nAPIv3からAPIv4へのマイグレーションについてのTIPSが下記にあります。 Mattermost API Reference\nオープンソースプロジェクト Mattermost Poll Integration with Firebase Firebaseを利用したMattermost上での投票機能のようです。 jedfonner/MattermostOnFire: Firebase Realtime Database and Firebase Cloud Function code to power a Mattermost slash command for creating a poll using Mattermost Interactive Buttons.\nCloudApp Integration デスクトップのキャプチャやGIF動画などを作成できるサービスであるCoundAppとMattermostとの連携機能のようです。 Mattermost Integration I CloudApp Video Screen Recorder\nMVP 私事ですが、今回のv4.6リリースのMVPに選ばれていました。 大きな貢献はまだできていないですが、日本語の翻訳や、細々したコントリビュートなどが評価されたものと思っています。 また、年末年始の休暇中に時間を割くようなワーカホリックな国民性の賜物かと思っています。\nおわりに 次回の v4.7.0のリリースは2018/2/16を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost%E3%81%ABredash%E3%81%AE%E3%83%81%E3%83%A3%E3%83%BC%E3%83%88%E3%82%92%E8%B2%BC%E3%82%8A%E4%BB%98%E3%81%91%E3%82%8B/","title":"MattermostにRedashのチャートを貼り付ける","section":"post","date":"2018.01.03","body":"はじめに Redashでアクセス数を可視化してるのですが、わざわざRedashを開くのが面倒になってきたのでMattermostからRedashのチャートを取得できるkaakaa/matter-redashというものを作りました。\nSlackだとRedash連携は色々あるのにMattermostでは見当たらない = 作るしかない。 re:dashにslack bot機能が追加されたよ！ - Qiita hakobera/redashbot: Slack Bot for re:dash\nどんなもの？ MattermostのSlash Commandとして動きます。\nどうやって動かす？ kaakaa/matter-redash: Redash integrations for MattermostのREADMEに書いています。\nどういう風に動いてる？  MattermostのSlash Commandでmatter-redashへリクエスト飛ばす 引数で指定されたチャート画像のスクリーンショットを取得 Mattermostへアップロード＆チャートを投稿  という流れです。\n以下、いくつかつまづいたところ。\nRedash Redashからチャート画像を取得するために/embed APIを使用しています。（RedashのAPI Specはどこかに無いだろうか・・） redash/embed.py at 1ef2238d65c0c87ed0bc74141cca44b7766b8453 · getredash/redash\nこのAPIを叩くとSVG入りのHTMLが取得でき、そのままではMattermostでレンダリングできないのでGoogleChrome/puppeteerを使ってスクリーンショットを撮り、その画像ファイルをMattermostにアップロードしています。\nconst embedUrl = util.format('%s://%s/embed/query/%d/visualization/%d?api_key=%s', protocol, redashHost, queryId, visualizationId, config.redash.apiKey); console.log('Redash Embed URL: %s', embedUrl); // eslint-disable-line no-console | const file = await webshot(embedUrl); | const webshot = async (url) =\u0026gt; { const tmpFile = tempfile('.png'); const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(url); await page.screenshot({path: tmpFile}); await browser.close(); return tmpFile; }; そこら辺の実装方法についてはhakobera/redashbotを参考にさせていただきました。\nMattermost Personal Access Token MattermostにAPI経由で画像ファイルをアップロードするために投稿権限が必要で、今の所Personal Access Tokenのみサポートしてます。 なので、MattermostはPersonal Access Tokenが実装されたv4.1.2以上である必要があります。\nPublic Link Mattermost上でチャート画像を見やすくするため、一旦チャート画像をメッセージの添付ファイルとして投稿し、[ファイルに対する公開リンク](Sharing Files — Mattermost 4.5 documentation)を取得し、Message Attachmentsとして投稿するようにしています。\n// Upload webshot image file const imageFormData = new FormData(); imageFormData.append('files', fs.createReadStream(file)); imageFormData.append('channel_id', req.body.channel_id); const uploadFile = await client.uploadFile(imageFormData, imageFormData.getBoundary()); // Get public link of uploaded file const fileId = uploadFile.file_infos[0].id; const post = await client.createPost({ channel_id: req.body.channel_id, message: 'This message is posted solely to get the public link and should be deleted immediately.', file_ids: [fileId] }); const link = await client.getFilePublicLink(fileId); console.log('Mattermost Public Link: %s', link.link); // eslint-disable-line no-console // Response to Mattermost res.header({'content-type': 'application/json'}); res.send(commandResponse(url, link.link)); // Delete unnecessary post. client.deletePost(post.id); 最後に不要なPostを削除していますが、これはMattermostの仕様上、一度Postに対する添付ファイルとして投稿しないとファイルの公開リンクを取得できないためです。 なので、実行ごとに(このメッセージは削除されました)という投稿が発生していまうので少し気持ち悪いです。\n注意点 Personal Access TokenもPublic Linkも設定で無効にできたりするので、システムコンソールから有効にしておく必要があります。\nおわりに とりあえず運用してみて、使えそうならShare your Mattermost projects | MattermostからMattermostチームに報告する所存。\nあと、Mattermostプラグインとして作り直したいな。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-4.5/","title":"Mattermost4.5の新機能","section":"post","date":"2017.12.24","body":"はじめに 2017/12/16にMattermost 4.5.0がリリースされたので、追加された機能などについて簡単に紹介します。\n詳細については公式のリリースを確認ください。 Mattermost 4.5: Zoom plugin for video, audio and screen sharing, plus new mobile features - Mattermost Mattermost Changelog — Mattermost 4.5 documentation\n新機能 Zoomプラグイン Mattermost上から簡単にビデオカンファレンスサービスであるZoomを利用できる機能がプラグインとして追加されました。 このプラグインのソースコードも独立のリポジトリとして公開されているため、サーバープラグインのリファレンス実装として参考になりそうです。 mattermost/mattermost-plugin-zoom: Zoom plugin for Mattermost\nただ、このプラグインを利用するために必要なZoomのAPI KeyなどはZoomの有料のDevelopersアカウントを作成する必要がありそうです。 My Account – Zoom Developers\nE20: Actianceコンプライアンスエクスポート 企業ではコンプライアンス上、Mattermost上の投稿やデータなどを保持しておく必要があり、そのためのポリシーを自社で策定したりしています。 上記を満たすためのアーカイブ機能として、自動でMattermost上のデータをサードパーティシステムであるActianceにエクスポートするための機能が追加されたようです。 Compliance Export Beta (E20 Add-On) — Mattermost 4.5 documentation\nモバイルアプリのアップデート  VideoやPDF, MS Office製品のファイルなどを閲覧できるようになりました  タップするとダウンロードが始まり\u0026hellip;\nPDFやPPTXファイルなどはこんな感じで表示されます。\n  モバイルアプリ上でもスラッシュコマンドを選択式に入力できるようになりました   iOSアプリの3Dタッチ機能を利用して既読操作を簡単に行えるようになったようです\n  Markdownのイメージ記法を利用すると、投稿内でレンダリングされるようになりました。（以前はURLリンクを表示する形式だった模様）\n  iPhone Xをサポートしたようです\n  API Version 3 Deprecated Jan. 16, 2018 以前よりアナウンスされていましたが、Mattermost API v3が次回のリリース日である2018/1/16に廃止になります。\nオープンソースプロジェクト（コミュニティ機能） Giphy Integration on AWS Lambda AWS Lambdaを利用したGiphyとの連携機能のようです。 pableu/mattermost-giphy-lambda: AWS Lambda Function to create a Slash-Command for Giphy-Integration in Mattermost\nMantisBT Plugin Integration Issue TrackerであるMantisBTとの連携機能のようです。 aalasolutions/MantisBT-Mattermost: Mantis integration plugin with Mattermost\nLaravel Web Framework for Mattermost PHP driver PHPのフレームワークであるLaravelと連携する機能のようです。 gnello/laravel-mattermost-driver: A Laravel integration for the package php-mattermost-driver\nおわりに 次回のv4.6.0のリリースは2018/1/16を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-4.4/","title":"Mattermost4.4の新機能","section":"post","date":"2017.12.24","body":"はじめに 2017/11/16にMattermost 4.4.0がリリースされたので、追加された機能などについて簡単に紹介します。(投稿日現在(2017/12/24)の最新版はv4.5.0です)\n詳細については公式のリリースを確認ください。 Mattermost 4.4: Plugin support in beta, plus new “Do Not Disturb” mode - Mattermost Mattermost Changelog — Mattermost 4.5 documentation\nv4.4.0リリース以降、セキュリティアップデートやバグ修正が加えられ、4.4系の現在の最新リリースはv4.4.5となっています。 この記事ではv4.4.0リリース時に加えられた新機能のみについてのみ記述しています。その他の修正内容については、上記のChangelogを確認してください。\nプラグイン機能 Mattermostのサーバーサイド、クライアントサイドのそれぞれに独自の機能を追加するためのプラグイン機能が使えるようになりました。\nクライアントプラグインでは、プロフィールポップオーバーやサイドバーなど、画面上の要素を上書きすることができます。 コアメンバーによるサンプル実装が下記で公開されています。Reactのコンポーネントを上書きしているようです。 jwilander/hovercardexample: Example hovercard webapp plugin for Mattermost\nサーバープラグインでは、JIRAやGitLab,Jenkinsなどのサードパーティーシステムと容易に連携できるようになります。 現在のMattermostでは、JIRA Webhook Plugin (Beta)がプリインストールされています。\n作成したプラグインはtar.gzの形式で圧縮し、画面UIからアップロードすることもできます。 Plugins (Beta) — Mattermost 4.5 documentation\n取り込み中(Do Not Disturb)ステータス 今まであったステータスであるオンライン(Online)、離席中(Away)、オフライン(Offline)に加え、集中したい時間など通知を受け取りたくない場合のステータスである取り込み中(Do Not Disturb / DNDが追加されました。\n画面左上のユーザーアイコンかスラッシュコマンド /dnd より設定できます。\nE20: SAML AuthenticationによるAD/LDAP同期 AD/LDAPによる認証を有効にしている場合に、AD/LDAP上で無効になったユーザーを自動でMattermostでも無効にできるようになりました。 この機能はSlackにはないMattermost独自の機能だとのことです。\nNew Open Source Projects Built on Mattermost オープンソースのMattermostをベースとしたコミュニティによるアプリ・システムが100を超えたとのことです。 公開されている連携機能は下記のページから探すことができます。 Apps and Integrations - Mattermost\nMattermostと連携する機能を作成した場合、下記より報告すると上記のページで紹介されます。 Share your Mattermost projects | Mattermost\n拙作の投票機能もどきも掲載してもらっています。\nMattersend Python Integration Mattermostの内向きのWebhookを通じてテキストを送信するための Python3 製CLIツールです。 joho1968/mattermostsendpy: Simple CLI utility for posting text to a Mattermost Incoming Webhook, written in Python 3\nSensu Monitoring Service SensuによるヘルスチェックやKPIなどのモニタリングをMattermost上で行える連携アプリです。 mattronix/handler-mattermost: mattermost plugin for sensu\nSpy Bot Integration あるユーザーがオンラインになったかどうかを監視するBotのようです。どのような場合に利用するのだろう\u0026hellip;？ prabhu43/mattermost-spybot: Spybot for mattermost\nおわりに 次回のv4.5.0のリリースは2017/12/16に行われました。\n 拙作の紹介ばかりな気がしますが、Interactive Message Buttonsの機能を利用したサンプルアプリの紹介を下記のページで行なっているので興味があればご覧ください。 打ち合わせ みんな多忙で 草生えるwww - Qiita\n"},{"ref":"https://blog.kaakaa.dev/post/%E6%89%93%E3%81%A1%E5%90%88%E3%82%8F%E3%81%9B-%E3%81%BF%E3%82%93%E3%81%AA%E5%A4%9A%E5%BF%99%E3%81%A7-%E8%8D%89%E7%94%9F%E3%81%88%E3%82%8Bwww/","title":"打ち合わせ みんな多忙で 草生えるwww","section":"post","date":"2017.12.21","body":"字（草）余り。\n この記事はFUJITSU Advent Calendar 2017 - Qiita 22日目の記事です。 記事の内容は全て個人の見解であり、執筆内容は執筆者自身の責任です。所属する組織は関係ありません。\nはじめに 打ち合わせの調整を依頼されて、みんな多忙で入れる隙間も無いと草生えますよね。\n生やしましょう。\nMattermostでスケジュール可視化\u0026amp;調整 去年に引き続きMattermostネタです。 (去年は技術記事じゃなかったことを反省しながら)\nMattermostはMattermost Inc.社が開発しているSlack AlternativeなOSSのチャットツールです。 https://about.mattermost.com/ https://github.com/mattermost\n MattermostのInteractive Message Button使って何か作りたくて、スケジュール可視化\u0026amp;チャットから会議予約なモノを作りかけました。\nkaakaa/matter-meeting: [PoC] Sending meeting request to Exchange from Mattermost\n実用的なところまで行き着けなかったので表現弱めに。コンセプト実装とお受け取りください。\n概要 こんな感じで動きます。\nMattermostから打ち合わせ参加者のメアドを指定すると、現在から1週間後までの参加者全員のスケジュールをGitHubの草風に表示。さらにはInteractive Message Buttonから会議予約を飛ばすこともできたりします。\nExchangeから予定を取得にはEWSのGetUserAvailabilityというAPIを利用しており、このAPIが全員の予定の中から空いている時間をqualityというフィールド付きで返してくれます。SuggestionQuality | Ews JavaScript Api。 qualityはどうも0～3までの整数で表されるようなので、その値をそのまま草の濃淡として表示しています。\n草の色は白に近いほど皆の予定が空いており、緑が濃いほど予定が詰まっていることを示しています。\nつまり、みんな忙しいと草生えるwww （深夜帯が草だらけなのは実装の都合上です。要検討事項。）\n構成 ざっくりこんな構成で動いてます。\nSlash Commandからリクエストを受けると、Exchange Serverへ問い合わせをし、そのレスポンスからMattermostへのBot投稿と草用のSVG画像を生成。 Bot投稿のボタンを押すと、Exchangeへ会議予約のリクエストが送られるという感じ。\nExchangeサーバーに繋ぐ部分にews-javascript-apiを使ってるのに引きずられて、慣れないNode.js使ってるのでPromiseの使い方がとても怪しい。 （そして型がない言語だからか、コード書いててもmodelが生えない…草は生えるのに…）\n要素技術の紹介 Mattermost Custom Slash Command Mattermostでは自作のSlash Commandsを登録できます。 少し前にこれを使って投票機能みたいなのも作ってました。\n今回は自作Slash CommandsサーバーのレスポンスにMesssage Attachmentsを使用し、ちょっとリッチなフォーマットで反応できるようにしています。\nMessage Attachmentsは、Slash Commandsのレスポンスとして下記のようなJSONをMattermostに返すと\n{ \u0026#34;attachments\u0026#34;: [ { \u0026#34;fallback\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;#FF8000\u0026#34;, \u0026#34;pretext\u0026#34;: \u0026#34;This is optional pretext that shows above the attachment.\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;This is the text of the attachment. It should appear just above an image of the Mattermost logo. The left border of the attachment should be colored orange, and below the image it should include additional fields that are formatted in columns. At the top of the attachment, there should be an author name followed by a bolded title. Both the author name and the title should be hyperlinks.\u0026#34;, \u0026#34;author_name\u0026#34;: \u0026#34;Mattermost\u0026#34;, \u0026#34;author_icon\u0026#34;: \u0026#34;http://www.mattermost.org/wp-content/uploads/2016/04/icon_WS.png\u0026#34;, \u0026#34;author_link\u0026#34;: \u0026#34;http://www.mattermost.org/\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Example Attachment\u0026#34;, \u0026#34;title_link\u0026#34;: \u0026#34;http://docs.mattermost.com/developer/message-attachments.html\u0026#34;, \u0026#34;fields\u0026#34;: [ { \u0026#34;short\u0026#34;: false, \u0026#34;title\u0026#34;:\u0026#34;Long Field\u0026#34;, \u0026#34;value\u0026#34;:\u0026#34;Testing with a very long piece of text that will take up the whole width of the table. And then some more text to make it extra long.\u0026#34; }, { \u0026#34;short\u0026#34;:true, \u0026#34;title\u0026#34;:\u0026#34;Column One\u0026#34;, \u0026#34;value\u0026#34;:\u0026#34;Testing\u0026#34; }, { \u0026#34;short\u0026#34;:true, \u0026#34;title\u0026#34;:\u0026#34;Column Two\u0026#34;, \u0026#34;value\u0026#34;:\u0026#34;Testing\u0026#34; }, { \u0026#34;short\u0026#34;:false, \u0026#34;title\u0026#34;:\u0026#34;Another Field\u0026#34;, \u0026#34;value\u0026#34;:\u0026#34;Testing\u0026#34; } ], \u0026#34;image_url\u0026#34;: \u0026#34;http://www.mattermost.org/wp-content/uploads/2016/03/logoHorizontal_WS.png\u0026#34; } ] } こんな感じの投稿を作ってくれます。\n(参考: Message Attachments — Mattermost 4.5 documentation)\nメッセージが5行以上の時は省略表示もしてくれるのも良い感じです。 最近、Mattermostのコアチームを真似てGHEのアクティビティをMattermostに流したりしてるのですが、コレを使うと長いIssueでも良い感じに表示してくれるので気に入ってます。\nInteractive Message Button ChatOps黎明期のBotはメッセージを投稿するだけでしたが、最近のBotはメッセージに選択肢を付けてくれます。 Slackには昔からある機能みたいで、GolangでSlack Interactive Messageを使ったBotを書く - Mercari Engineering Blogを見ながら面白そうだな～なんて思ってたら、Mattermostにもやってきました。（PLT-6403: Interactive messages by ccbrown）。 Mattermostでは今のところボタンのみの対応ですが。\n（参考: Interactive Message Buttons (Beta) — Mattermost 4.5 documentation）\n今回は、調整した予定の中でもっとも参加可能人数が多い時間をInteractive Message Buttonとして表示しています。多すぎると訳分からなくなりそうだったので最大１０個まで表示。 ボタンを押すと会議出席依頼が飛ばせるというアレ。べんり。\nInteractive Message Buttonの作り方は、先述のMessage Attachmentsのレスポンスの中にintegrationというフィールドとして指定することで作れます。\nんで、ボタンを押すとhttpリクエストが飛ばされるというアレ。夢が広がりますね。はい。\nボタンだけでも十分遊べそうですが、セレクトボックスとかチェックボックスなんかも加わると更に夢が広がりそうだなぁ。まとまった時間とってコントリビュートしたいなぁ。\nExchange 予定の取得や会議予約を飛ばしたりするのはews-javascript-apiを使っています。 昔はews-java-apiを使って遊んでいましたが、歳のせいかJavaを書くのが辛くなってきました。\news-javascript-apiはユースケース情報が転がってない気がするので、こんな感じで増やしていけると良いですね。\nただ、これ便利なんですが、気を許すと全社員宛のリクエストを飛ばすことになりかねなかったりするので、指定できるメアドにはホワイトリスト方式を採用しています。マジでここだけ注意な。\n一応設定ファイルで正規表現指定できるけど、仲間内のメアドだけリストで指定しておくのが安全です。ews-javascript-api使って自分の部門だけに制限するとかも出来る…のかな？\n草生やす サーバー側でnunchucks テンプレートにスケジュール情報を流し込み、SVG作ってOSSのS3互換オブジェクトストレージであるMinioに投げてます。 ここで生成した草画像はMattermostのMessage Attachmentsのimage_urlに指定して表示させてます。\n最初はsvg2png使って画像ファイル化してたけど、Message Attachmentsで指定したURLはimgタグで読み込んでるようなので、SVGのままでも行けるじゃん、と後で気づきました。\nMinio 生成したSVGは、上述のようにMinioに格納してURL指定で取得できるようにしています。 スラッシュコマンドを実行するごとにshortidでユニークIDらしき物を作って、そのIDをファイル名としてSVGを保存してます。\nSVGはローカルファイルとして格納しても良いかとも思ったのですが、なんとなくMinioを使ってみたかったので。 一定時間経ったSVGは削除するソリューションも欲しくなってます。\nMinioだと少しヘビーな気がするのと、ランダム文字列とはいえ誰でも見えるところに調整結果の画像を置くのは少し忍びない気もしていますが、まぁとりあえず。\nテストは？ まだ無い\nコード品質は？ 嘲笑するならパッチくれ\n問題 実用に向けた最大の課題は、ews-javascript-api使うために指定したアカウントからしか会議出席依頼を飛ばせないところ。みんなで使うと私のスケジュールが凄いことになりそう。 Bot社員が求められている。\nあと細々した改善点もたくさん。\n 30分間の予定しか想定されてない 現在から1週間後までの間しか調べてない(日時指定できるようにするとコマンドが複雑になるのがアレ) メアド毎回入力するのが面倒 (Mattermostの@channel使うとチャンネル内全員対象にする、とか出来ると理想)  などなど。 今回用のネタとして開発したものなので突き詰めるつもりもないですが(たぶん)\nMattermostについて 最近、UberがSlack/HipChatを諦めてMattermostベースのコミュニケーションプラットフォームであるuChauというのを作り始めているというニュースがあり。まだまだユーザー数を伸ばしていきそうな感じがします。 The Road to uChat: Building Uber’s Internal Chat Solution\n機能的にも、この記事でも取り扱ったInteractive Message Buttonや、Plugins機能なんかも追加されてきているので、まだまだいろいろ遊べるようになっていく予感。\n開発も活発なのでこれからも期待しています。\nおわりに お仕事ではみんなで大草原回避しましょう。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-4.3/","title":"Mattermost4.3の新機能","section":"post","date":"2017.10.23","body":"はじめに 2017/10/15にMattermost 4.3.0がリリースされたので、追加された機能などについて簡単に紹介します。\n詳細については公式のリリースを確認ください。 Mattermost 4.3: Tablet support, E20 data retention. Plus: join us for Hacktoberfest! - Mattermost Mattermost Changelog — Mattermost 4.3 documentation\nセキュリティアップデート Mattermost Changelog — Mattermost 4.3 documentation Mattermost v4.3.0は複数のセキュリティアップデートを含んでいるため、早期のアップデートを推奨しています。 Mattermostのポリシーに基づき、脆弱性の内容についてはリリースから14日後に Security Updates - Mattermost で公開されるそうです。\nTeam Edition (Team EditionはOSS版のことです)\nモバイルアプリ v1.3 の改善点 タブレット向け横向き画面 タブレットデバイスに適した横向きのビューが追加されました（ベータ版）\n手元のiPhone7 Plusで試したところ、こんな感じになりました。 リンクプレビュー 画像やGIF、YouTubeのプレビュー表示が追加されました\n通知 Androidユーザーは通知に関するライト、振動、サウンドの設定ができるようになりました。 また、最新の通知が一番最初に表示されるよう改善が行われました。\nEnterprise Edition (E20) データ保持期間設定の追加 Mattermost上のメッセージやファイルを保持する期間を設定できるようになりました。 Data Retention Policy Beta (E20) — Mattermost 4.3 documentation\nまた、次のバージョン(v4.4.0)では、メッセージを削除する前にサードパーティのアーカイブシステム向けにエクスポートする機能が追加される予定だそうです。 これにより、監査のためにメッセージを保存しておくこともできるとのことです。\nタイムアウト設定の追加 ユーザーが指定した時間(分単位)、システムを利用していない場合に自動でログアウトさせることができるようになりました。\nNew Community Integrations Spotify-Deezer Kaylleur/mattermost-integration-deezer-spotify-link SpotifyとDeezer上のミュージックトラックへのリンクをMattermostへ投稿するBotアプリのようです。\nHacktoberfest 毎年恒例になってきた「10月中にGitHub上でコントリビュート行うとTシャツがもらえるイベント」の紹介です。 Hacktoberfest 2017 - DigitalOcean\nMattermostではHacktoberfest向けに、HelpWanted的なIssueにHacktoberfestのラベルを付けて参加を奨励しています。 Hacktoberfest 2017 - DigitalOcean\n昨年はこんな感じのTシャツがもらえました。 おわりに 次回のv4.4.0のリリースは2017/11/16を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-4.2/","title":"Mattermost4.2の新機能","section":"post","date":"2017.09.23","body":"はじめに 前回の更新(v3.8)からだいぶバージョンが飛んでしまいましたが、2017/9/15にMattermost v4.2.0がリリースされたので、追加された機能などについて簡単に紹介します。\n詳細については公式のリリースを確認ください。\nMattermost 4.2: Interactive message buttons, AppConfig for Mobile App - Mattermost Mattermost Changelog — Mattermost 4.3 documentation\nインタラクティブメッセージボタン Mattermostの統合機能を通じて、ユーザーが選択可能なボタンを付けた投稿を行えるようになりました。 この機能に関するドキュメントを見るに、ボタン毎に異なるHTTPリクエストを送信するもののようです。\nこの機能を利用した例として、投票機能に関するアプリが紹介されています。 mattermost/mattermost-interactive-post-demo: Interactive post demo for Mattermost\n(Mattemost上での投票機能については、拙作となりますが絵文字リアクションを利用したGoアプリを以前から公開しています。ご参考まで。 kaakaa/matterpoll-emoji: Poll server for Mattermost )\nカスタムスラッシュコマンドによるワークフローの改善 こちらは新機能ではないですが、スラッシュコマンドの使いやすさの紹介です。\nSlash Commands — Mattermost 4.3 documentation\nカスタムスラッシュコマンドを作成・実行すると、任意のエンドポイントにリクエストを送信できるため、AWS API Gateway / AWS Lambdaと組み合わせることで効果を発揮します。 ここでは、Standupミーティングの状態をハッシュタグ付きで書き込んでくれるスラッシュコマンドの例が紹介されています。 Custom Slash Commands in Mattermost with AWS Lambda and API Gateway · Grundleborg\u0026rsquo;s Cave\nモバイルアプリのAppconfig対応 MattermostのモバイルアプリがEMMのAppconfigに対応しました。\nAppConfig for EMM Solutions with Mattermost Mobile Apps — Mattermost 4.3 documentation\n私はAppconfigを利用したことがないので知識があまりないですが、エンタープライズでのモバイルアプリを利用する際の初期設定やセキュリティの管理などを行なってくれるサービス?のようです。\nコミュニティによる連携アプリ Listen for Webhooks and Post Them to Your Mattermost Server PromoFaux/Matterhook.NET\nDiscourseやGitHub,DockerHubのWebHookを受け取り、整形してMattermostのIncoming Webhook経由で投稿を行なってくれるアプリのようです。C#。\nReport TeamCity Build Progress JetBrains社のCIサーバーであるTeamCityのビルド結果を通知してくれる連携機能のようです。 他にもBitBucket、Sentryと連携できるようです。 CGenie/mattermost-openresty: Bridge between Mattermost and various services using the Openresty platform\n上記は\u001eOpenRestyに対応しており、OpenRestyとはngx_luaを含んだ形で提供されているnginxのディストリビュート?のようです。\n参考\n OpenResty® - Official Site ３つのnginxをうまく使い分けよう〜nginx、OpenResty、Tengine〜 - Mercari Engineering Blog  Unsplash – Inspire a Colleague! ストックフォトサイト(写真画像共有サイト?)Unsplashと連携するアプリのようです。\nMarkus Busche / image_quote_to_mattermost · GitLab\nLogback Appender JavaのロギングライブラリであるLogbackと連携し、Incoming Webhookを通じてログ情報をMattermostへ送信する\u0008LogBack拡張のようです。\nelexis-server/bundles/at.medevit.logback.mattermost at master · elexis/elexis-server\nその他の更新 その他、更新していなかった間に追加されたトピックについて、ピックアップして紹介します。\nPersonal Access Token Mattermost APIを利用する際の認証に使用できるアクセストークンが発行できるようになりました。(v4.1 ~) Personal Access Tokens — Mattermost 4.3 documentation\nNew Mobile App β版だった新しいモバイルアプリが正式版としてiTunesStore、Google Playからダウンロードできるようになりました。(v4.0〜) Mattermost on the App Store\nMattermost - Google Play の Android アプリ\nリポジトリの分割 今までMattermostアプリは mattermost/platform 上で開発が行われていましたが、先月あたりからサーバーサイド(mattermost/mattermost-server)とフロントエンド(mattermost/mattermost-webapp)にリポジトリが分割されました。\nmattermost/mattermost-server: Open source Slack-alternative in Golang and React - Mattermost mattermost/mattermost-webapp: Webapp of Mattermost server\nその他 Uber Mattermostでは新バージョンのリリース毎に最も大きな貢献をしてくれたコントリビュータをMVPとして表彰していますが、今回のMVPにはUberの開発チームが選ばれていました。\nUberでは社内のコミュニケーションツールとして、Slack/HipChatなどを利用していましたが、スケーラビリティやセキュリティの面で折り合いがつかず、現在ではMattermostをベースとしたuChatというコミュニケーションプラットフォームを開発しているそうです。\nWhy Uber switched from Slack to Mattermost for enterprise collaboration - Mattermost The Road to uChat: Building Uber’s Internal Chat Solution\nDeprecated Mattermot API v3 過去に利用されていたMattermost API v3は2018/1/16に削除される予定です。\n API v3 endpoints are supported until January 16, 2018. To learn more about migrating to APIv4 endpoints, see https://api.mattermost.com/.\n おわりに 次回のv\u00084.3.0のリリースは2017/10/16を予定しています。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-3.8/","title":"Mattermost3.8の新機能","section":"post","date":"2017.04.19","body":"はじめに 2017/4/16にMattermost 3.8.0がリリースされましたので、追加された機能などについて簡単に紹介します。 (現在、v3.8.1のリリースを検討しているようなので、安定稼働を求める方はもう少し待ったほうが良いかもしれません)\n今回のリリースから隔月リリースから毎月16日のリリースサイクルに戻したようです。 (2016年9月から隔月リリースに変更していました) Mattermost moves to monthly releases\n詳細については公式のリリースを確認ください。 Mattermost 3.8: Deploy with next generation iOS and Android Apps in Beta – Now Faster than Ever Mattermost Changelog - Release v3.8.0\niOS/Android アプリ ReactNativeで開発されたiOS/Androidアプリのベータ版がリリースされています。 Android版はGoogle Play Storeから、iOSの場合は下記Sign upでのユーザー登録とTestFlightのインストールが必要です。\n To test on Android: Search for “Mattermost 2017 – Beta” in the Google Play store, or opt-in here. To test on iOS: Sign up to become a beta tester.\n 3.8 New End User Features Emoji機能の拡充 - Emoji Picker 絵文字選択機能がプリリリースされました。 今までのバージョンでは :emoji: の形式でしかEmoji入力入力・リアクションの付与ができませんでしたが、3.8からは画面上で入力できるようになります。\n絵文字選択機能を使用するにはアカウント設定 \u0026gt; 詳細 \u0026gt; プリリリース機能をプレビューする から行うことができます。\n上記の設定を有効にすると、メッセージ入力ボックスに絵文字選択ボタンが出現します。 また、絵文字リアクションを付与する際にも絵文字選択機能を使用することができるようになっています。 Pinned Post チャンネルごとにピン止めされた投稿を設定することができるようになりました。 投稿の横にある[...]メニューからチャンネルにピン止めするを選択することで、ピン止めすることができます。\nピン止めされた投稿は画面上部の :pushpin: アイコンをクリックすることで確認できます。\n3.8 New System Admin Tools システムコンソールのユーザーリスト/チーム管理 今までのバージョンでは、ユーザー一覧はチームごとにしか確認できませんでしたが、システムコンソールで全てのユーザーの一覧を確認・管理できるようになりました。 また、新しくチーム統計画面が追加されています。\nチームの統計画面 ユーザーリスト画面 クラウド自動デプロイがよりシンプルに 様々な環境でMattermostを動作させるため、設定情報を環境変数から指定できるようになりました。 config.jsonに書かれた設定情報を環境変数によって上書きすることができるため、多様なクラウド環境へのデプロイ設定が容易になります。\n例えばconfig.json内で.ServiceSetting.ListenAddressをキーとする設定は、環境変数MM_SERVICESETTINGS_LISTENADDRESSによって上書きすることができます。\nCommunity Integration Siba Bot Integration チャットボットツールであるSibaのMattermostアダプターです。 SibaのDocumentationページはまだ準備中らしく、Sibaがどのようなものかは分かりませんでした。\nConduct a Quick Emoji Poll v3.6から追加されたリアクション機能を利用した投票メッセージの作成を簡単にするサーバーアプリを作りました。 詳細はMattermostで投票機能もどきに書いています。\nSimple CLI Utility for Posting Text in PHP Mattermostの内向きのウェブフックを利用して、コマンドラインからメッセージを投稿できるPHPツールです。 joho1968/mattermostsendphp\nSimple Mattermost /slash Service Dispatcher and Responder in PHP PHP製のスラッシュコマンドのディスパッチャです。 joho1968/mmsrvdispatch\nRemoved and Deprecated Features  v3.5以前に使われていた古いCLIツールが削除されました 下記のAPIが削除されました  GET at /channels/more (replaced by /channels/more/{offset}/{limit}) POST at /channels/update_last_viewed_at (replaced by /channels/view) POST at /channels/set_last_viewed_at (replaced by /channels/view) POST at /users/status/set_active_channel (replaced by /channels/view)    Removed and deprecated features for Mattermost\nおわりに 次回のv3.9.0のリリースは2017/5/16を予定しています。\nv3.9.0向けに現在開発中の機能として下記が挙げられています。\n チャンネルのアーカイブとアーカイブからの復元 公開/非公開チャンネルの切り替え 参加/脱退システムメッセージの結合  Roadmap - Mattermost\n Coming Soon (In Progress by Community)\nCommunity members are currently working on the features listed below. They are not scheduled for a specific release, but will be added to the product when work is complete.\n Unarchive channels Converting public channels to private Combining consecutive join/leave messages   "},{"ref":"https://blog.kaakaa.dev/post/mattermost%E3%81%A7%E6%8A%95%E7%A5%A8%E6%A9%9F%E8%83%BD%E3%82%82%E3%81%A9%E3%81%8D/","title":"Mattermostで投票機能もどき","section":"post","date":"2017.04.02","body":"(2017/4/4 Golang Driverについての記述を追加しました)\nはじめに Mattermostのスラッシュコマンドで簡単に投票メッセージを作成できるアプリを作りました。 kaakaa/matterpoll-emoji: Poll server for Mattermost\nMattermostでpollというスラッシュコマンドを作り、下記のようにコマンドを実行\n/poll `What do you gys wanna grab for lunch?` :pizza: :sushi: :fried_shrimp: :spaghetti: :apple: すると、下記のような投票メッセージを投稿してくれます。 べんり。\nBotに定期的に出欠確認メッセージを呟かせるなどすると良いかと思います。 Mattermost v3.7で動作確認しています。\n使い方  git cloneする config.jsonを書く matterpoll-emojiを起動する Mattermostでカスタムスラッシュコマンドを作成する スラッシュコマンドを実行する  です。 詳細はREADMEを参照ください。\n問題  Mattermostでは0票のReactionを付けられないため、必ず最初に一票は入った状態になってしまう  Botアカウント作成推奨です   Mattermost API Version4未対応  API v4はまだβバージョンなので、API v3で作っています。2017/9月にAPI v3が使えなくなるので、それまでにAPI v4に対応する必要があります。    スラッシュコマンドについて Marrermostで/で始まる投稿はスラッシュコマンドだと解釈されます。 Mattermostの投稿画面で/を入力すると、内臓スラッシュコマンドの一覧が表示されます。\nカスタムスラッシュコマンド ユーザー独自のスラッシュコマンドを作成することもできます。 システムコンソールでカスタムスラッシュコマンドを有効にし、統合機能からスラッシュコマンドを作成できます。\nリクエスパラメータ Mattermostのスラッシュコマンド実行時に送られるリクエストパラメーターは下記になります。\nCreating Integrations with Commands\n  Your integration should have a function for receiving HTTP POSTs or GETs from Mattermost that look like this example:   Content-Length: 244 User-Agent: Go 1.1 package http Host: localhost:5000 Accept: application/json Content-Type: application/x-www-form-urlencoded\n channel_id=cniah6qa73bjjjan6mzn11f4ie\u0026amp; channel_name=town-square\u0026amp; command=/somecommand\u0026amp; response_url=not+supported+yet\u0026amp; team_domain=someteam\u0026amp; team_id=rdc9bgriktyx9p4kowh3dmgqyc\u0026amp; text=hello+world\u0026amp; token=xr3j5x3p4pfk7kk6ck7b4e6ghh\u0026amp; user_id=c3a4cqe3dfy6dgopqt8ai3hydh\u0026amp; user_name=somename\n  --- BodyがURLパラメータ形式で送られてくるので、今回作った`matterpoll-emoji`ではダミーのURLのURLパラメータとして結合し、Goの`url`パッケージで解析する方法を取っています。 [poll_request.go#18](https://github.com/kaakaa/matterpoll-emoji/blob/master/poll/poll_request.go#L18) ### レスポンスパラメータ [Creating Integrations with Commands](https://docs.mattermost.com/developer/slash-commands.html#creating-integrations-with-commands) リクエストを受け取ったサーバーは、下記のような`application/json`形式の情報を返す必要があります。 \u0026gt; 3 . If you want your integration to post a message back to the same channel, it can respond to the HTTP POST request from Mattermost with a JSON response body similar to this example: \u0026gt; \u0026gt; ``` { \u0026quot;response_type\u0026quot;: \u0026quot;in_channel\u0026quot;, \u0026quot;text\u0026quot;: \u0026quot;This is some response text.\u0026quot;, \u0026quot;username\u0026quot;: \u0026quot;robot\u0026quot;, \u0026quot;icon_url\u0026quot;: \u0026quot;https://www.mattermost.org/wp-content/uploads/2016/04/icon.png\u0026quot; } response_typeがin_channelの場合、普通の投稿と同じように投稿が作成されます。ephemeralを設定した場合はシステムメッセージのような、スラッシュコマンドを実行した人にしか見えない投稿が作られます。\ntextにはMattermostに投稿するメッセージテキストを指定しますが、Mattermostでの投稿と同じようにMarkdownやEmojiを利用することができます。\nusernameとicon_urlは投稿のユーザー名とアイコンを上書きするオプション情報です。\nGolang Driver 本来、スラッシュコマンドからリクエストされるサーバーの処理は、上記のレスポンスパラメータを返す形になりますが、それでは投稿にReactionを付けることなどができないためmatterpoll-emojiではGolang Driverを利用して投稿の作成・Reactionの付与をしています。\nmodel.NewClientによって生成されるclientオブジェクトに投稿、ユーザー、チャンネルなどに対する操作が定義されています。\nmatterpoll-emojiではGolang Driverのログイン、投稿、リアクションの操作を利用しています。\n開発の背景 弊社では週に一回ゆるい感じで勉強会を行っているのですが、人数があまり多くないため、聴講者が０人の日があるかもしれないという恐怖に常にさらされています。MattermostやWikiなどで出席・欠席などを報告できる場はあるのです、毎週の報告など面倒であるため報告機能がうまく回っているとは言えず。「ちゃんと出欠入力しましょう」なんて言うのも野暮。\nそんな時、Mattermost v3.6でEmoji リアクションの機能が追加され、Slackのように投稿に絵文字でのリアクションを付けることができるようになりました。これを使って、毎週勉強会の日にBotに出欠確認メッセージを投稿させれば出欠登録も確認も楽になるのではないか、というのがきっかけです。\nまた、投票機能はMattermostのFeature Ideaでも人気の高い機能であるため、なるべくにいろいろな用途で使えるようにしました。Polls (like doodle or for decision making) – Mattermost Feature Proposal Forum\n結果 前回の勉強会出席者は一人でした。 0人回避。やったね。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-3.7/","title":"Mattermost3.7の新機能","section":"post","date":"2017.03.30","body":"はじめに 2017/03/16にMattermost 3.7.0がリリースされました。 リリースから２週間ほど経ってしまいましたが、追加された機能などについて簡単に紹介します。 現在、セキュリティfixなどを含んだ v3.7.3 が最新バージョンとなっています\n詳細については公式のリリースを確認ください。 Mattermost 3.7: Auto-deploy to cloud, multi-person direct messaging and much more\nその他、細かい変更や修正は下記にまとめられています。 Mattermost Changelog\n変更点 Cloud Platform Auto-deploy Deployment Solutions Programsが公開されています。 (Mattermostのデプロイメントを体系的にしたもの？）\nまた、Bitnami Mattermost Team Edition StackによってMattermostのTeam Edition(OSS版のこと)の主要パプリッククラウドサービスへのデプロイが容易になりました。 AzureのプライベートクラウドプラットフォームであるAzure Goverment Cloudにも適用できるようです。\nBitnamiからAzureへMattermostをデプロイし、Slackからデータをインポートする手順についての動画が公開されています。\nGroup Messaging for Quick, Direct Chats 素早く複数人でのメッセージングを行う グループメッセージ の機能が追加されました。 ダイレクトメッセージ の機能拡張のようなものです。\n以前のダイレクトメッセージ機能では１対１の会話のみが可能でしたが、グループメッセージでは最大8人での会話が可能です。 8人を超える場合は 非公開グループ の作成が推奨されています。\nMore Flexibility API Version 4 (early beta release) Mattermost APIの新バージョンのベータリリースです。 Mattermost API Reference (v4.0.0)\n現在のAPI v3は 2017/9/16 までサポートされます。\nNew Website Link Previews Website Linkを投稿すると、リンク先の内容を表示するようになります。 v3.6までのプレビュー機能では日本語が文字化けしていましたが、v3.7からは文字化けしていないようです。\nプレビュー機能を有効にするには、システムコンソールでプレビュー機能を有効にした上で、各アカウントごとに設定します。\nChannel Push Notification Preferences モバイルプッシュ通知の設定をチャンネルごとに行えるようになりました。 (モバイルプッシュ通知の設定が行われている場合のみ)\nスケーラビリティの改善 Faster Server-side Processing サーバーサイドのパフォーマンス改善が行われました。\nキャッシュ・クエリ最適化によるCPU/DBのボトルネック低減や、不要なWebSocketの呼び出しを削除したとのことです。 詳しい改善内容はMattermost Changelog - Performanceにまとめられています。\nまた、パフォーマンス改善について、動画 Mattermost Developer Brown Bag - Performanceで語られています。\nSimplified Import of Bulk Data 他のシステムからチーム、チャンネル、ユーザー、投稿をインポートするツールが使えるようになりました。 明示的なリンクはないのですが、おそらくBulk Loading Dataの事だと思います。\nセキュリティ関係の新機能 New “Channel Administrator” Role (Enterprise Edition E10 \u0026amp; E20) チャンネル名の変更とチャンネルの削除を行うことができるチャンネル管理者のロールが追加されました。 Enterprise版(E10,E20)のみの機能となります。\nOneLogin Support (Enterprise Edition E20) v3.6まではOktaかMicrosoft ADFSを利用したSAML SSOを利用できましたが、v3.7からOneLoginを使用したSAML SSOも行うことが可能になりました。 Enterprise版(E20)のみの機能になります。\nSecond Generation Mobile Apps: Beta Release in March React Native製のiOS/Androidアプリのβ版が今月中にリリースされるそうです。 3/29にリリースされました。 =\u0026gt; A Native Mobile Experience – Second Generation Mobile Apps Released in Beta\nAndroid版、iOS版それぞれβ版を試してみることができます。 (iOS版はTestFlightアプリのインストールが必要でした)\n開発はmattermost/mattermost-mobileで行われています。\n新しいコミュニティ連携 Mattermost-Tuleap Bot Plug-in OSSの開発サポートツールであるTuleapとの連携機能です。 TuleapへのGitプッシュとScrumレポートのLattermostへの通知を行えるようです。 Mattermost connectors for Tuleap Scrum reports and Git now available\nNew Simple GitHub Integration Haskell製のGithub連携ツールです。 UlfS/ghmm\npython/flask製のGithub連携ツール softdevteam/mattermost-github-integration のメンテも継続されています。\nおわりに 次のバージョンであるMattermost v3.8.0は2017/4/17リリースを予定しています。 Pinned PostやEmoji Picker,Reaction Pickerなどの機能が追加される予定です。 Core Team向けMattermostでは、すでに利用可能です。\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost/releases-3.6/","title":"Mattermost 3.6の新機能","section":"post","date":"2017.01.31","body":"はじめに 2017/01/16にMattermost 3.6.0がリリースされましたので、追加された機能などについて簡単に紹介します。 (その後1/19にアップグレードにまつわる問題などを改善したv3.6.1がリリースされています) (その後2/3にTeamEdition, EnterpriseEdition向けのセキュリティアップデートを含んだv3.6.2がリリースされています)\n詳細については公式のリリースを確認ください。 Mattermost 3.6 improves multi-team deployment, performance, emoji reactions, CLI and much more – Mattermost\nchangelog チームサイドバー 複数のチームに所属している場合に、画面左端にチームサイドバーが表示されるようになりました。 他のチームでの新しい投稿やメンションの有無が、一画面で確認しやすくなります。 Emoji リアクション 投稿に対してEmojiでのリアクションを付けられるようになりました。 チャンネルの最新の投稿、もしくは返信スレッドの末尾の投稿に対してリアクションすることができます。 投稿欄に+:thumbsup:のように絵文字コマンドの前に+をつけて投稿することでEmojiリアクションとなります。Emojiにはカスタム絵文字を指定することも可能です。 他のユーザーがEmojiリアクションをクリックすることでリアクション数をカウントアップできるため、投票機能としても利用することができます。\nv3.6時点でEmojiリアクションはチャンネルまたは返信スレッドの最新の投稿にしか付与できず、Slackのように任意の投稿を選んでリアクションをつけることはまだできないようです。\nコマンドラインインタフェースの改善 今まではplatformコマンドのオプションとして実行するコマンドを指定していましたが、v3.6からは用途ごとのサブコマンドを指定する形式になりました。 Command Line Tools — Mattermost 3.6 documentation\nグローバル対応 CJK(Chinese, Japanese and Korean)を含む英数字以外のユニコード文字でのハッシュタグに対応しました。 また、各言語へのローカライゼーションも引き続き行われています。 日本語のローカライゼーションに興味のある方はいつでもご参加ください。 Localization — Mattermost 3.6 documentation MattermostのLocalizationフロー - Qiita\n(Enterprise Edition E20) パフォーマンスモニタリング 有償版限定ですが、PrometheusやGrafanaと統合されたパフォーマンスモニタリング機能が付いたようです。\n私はTeamEditionしか使っていないので詳細は分かりません。\nNew Integrations 公式ページでも紹介されている統合機能は引き続き追加されています。 Share your Mattermost projects | Mattermost\nGitLab Auto Deploy with Mattermost GitLab 8.15で追加されたAuto Deploy機能をMattermostのスラッシュコマンドから起動する手順の紹介です。 Mattermost slash commands - GitLab Documentation\nAWS AMI with Mattermost, Gitlab and Kanboard Mattermost, Gitlab, Kanboard全部入りのAMIの紹介です。 AWS Marketplace: Best Project Management Package\nMicrosoft System Center Operations Manager Alerts via Mattermost Microsoft SCOM（やSolarWinds, OMS, datadogなど）の監視ツールからの通知をMattermostへ送信する機能の紹介です。\nSCOM Alerts to Microsoft Teams and Mattermost | adatum\nPHP Driver for Mattermost 内向きのウェブフックを通じてMattermostを操作できるPHP製ドライバーの紹介です。 GitHub - ThibaudDauce/mattermost-php: Mattermost PHP driver to send incoming webhooks\nComing Soon 次世代Mobile Apps 現在のWebViewベースのモバイルアプリからReact Nativeベースのアプリに移行する予定です。 Q1でのEarly Releaseを予定しています。\nDesktop App 3.6 Windows, Linux, Mac向けのデスクトップアプリのリリースも予定しています。\n inline spell checker team sidebar performance improvements (Enterprise Edition) SAML OneLogin / Google authentication  おわりに Mattermostは隔月16日リリースを行っているため、次回のv3.7のリリースは2017/3/16を予定しています。 Roadmap – Mattermost\n"},{"ref":"https://blog.kaakaa.dev/post/mattermost%E3%81%AE%E9%96%8B%E7%99%BA%E3%81%AB%E5%8F%82%E5%8A%A0%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F%E8%A8%98%E9%8C%B2/","title":"Mattermostの開発に参加してみた記録","section":"post","date":"2016.12.16","body":"この記事はFujitsu extended Advent Calendar 2016 16日目の記事です。\n※この記事に描かれていることは個人の見解であり、所属する組織の公式見解ではありません。` 個人的な活動の経験から得た知見の共有を目的としています。\nはじめに SI企業で働く傍ら社外のプログラミング関係の勉強会にも参加しており、その中で語られるOSS的な開発プロセスがどんなものであるか、実際に参加して体験してみたいと常々思っていました。 今年の夏ごろからMattermostというSlackクローンのOSSチャットツールの開発に参加し始めているので、Mattermost開発の進め方などを紹介したいと思います。 他の組織の開発を体験することで、日頃の開発の改善点が見つかるのでは無いかというのが参加のモチベーションです。\nMattermostを選んだ理由としては、今年の初め頃から日常的にMattermostを利用しており、Eat Your Own Dogfoodの精神で「より良くしたい」という意識を持ちやすいことです。 また、MattermostはサーバーサイドのGo言語、フロントエンドのReact.jsを始めとし、DockerfileやiOS,Androidアプリ(最近react-nativeで書き直し中)、Electron製のデスクトップアプリなど、新し目の技術を取り入れているため、普段は使わない技術に触れられるところが魅力でした。\n開発に参加してると言っても、枝葉のIssue対応ぐらいしかしていないので、もちろんMattermostチームを代表しての記事ではありません。 誤っている部分がありましたら、報告いただけると幸いです。\nチャットツール Mattermost MatermostはPalo AltoにあるMattermost, Inc.が開発しているオープンソースのチャットツールです。 公式サイトにもあるようにOpen source, self-hosted Slack-alternativeを謳っています。。 名前の由来はachieve what matters most(最も重要なことを達成する)だそうです。\n機能的にはSlackに追従することを目的としつつ、オンプレミスで動作可能であることやオープンな場で開発されていることを強みとしています。 また、Slackにはない多言語対応や、Enterprise版ではAD/LDAP認証を利用できるなど独自の機能も追加しています。 Pricing – Mattermost\n隔月の定期リリースを行っており、次回のv3.6のリリースは2017/1/16に予定されています。\nその他のチャットツール Mattermost以外にもChatツールはプロプライエタリ・OSS含め様々あります。\n   名前 公式サイト Github スター数 言語     Slack Slack: Be less busy SaaSのみ - PHP   HipChat HipChat - Atlassian SaaSのみ - ?   Mattermost Mattermost github  go,js   RocketChat Rocket.Chat github  js,coffee   Zulip Zulip github  python,js   Actor Messanger Actor Messenger github  java,scala,swift   Let\u0026rsquo;s Chat Let\u0026rsquo;s Chat github  js   Kandan KandanApp github  js,coffee,ruby    参考：Kickball/awesome-selfhosted\n基本無料かつサーバーのお守りの必要のないSaaSであるSlackがチャットツールの定番かと思いますが、やはり組織内で利用するには外部サービスということで利用に慎重になってしまう部分があったため、何も心配せず使えるOSSを選択していました。\n私はOSSとしてはKandan, Let\u0026rsquo;s Chat, Mattermostしか使ったことがないですが、Rocket.chatとZulipも開発が活発なため、OSSのチャットツールを検討する場合は候補となるかと思います。 Kandanは機能的に物足りなく、Let\u0026rsquo;s Chatは快適に利用できてはいましたが最近ほとんどメンテナンスされていないため、Mattermostへ乗り換え、今でもコミュニケーションツールとして利用しています。\nMattermost開発ツール Mattermostチームは多くのサービスを使って開発されており、そのほとんどが誰でも閲覧できるところに公開されています。（各サービスのアカウントを作成する必要はありますが）\nMattermost Mattermost開発におけるコミュニケーションの多くはMattermost上で行われています。 バグのトリアージからPull RequestやGithu Issueへの更新の通知、ユーザーフォーラムの質問への回答依頼など、Mattermost本体に関わることから、ドキュメンテーション、ローカライズなどなど開発に関することが日頃から議論されています。 ほぼすべて英語です。\n「どこどこのチャンネルに属さなくてはいけない」という指定は無いと思いますが、開発に参加する場合はContributorsと、開発対象のチャンネル(Documentation、i18n - localizationなど)の動向はチェックしておいても良いかと思います。\n開発チャットとして使われているMattermostは最新のコードから作成された環境のため、新機能をいち早く試すことができます。 最近ではSlackにあるような、投稿に対するReactionの機能などが追加されています。\n最初にログインした時にデフォルトで参加することになるチャンネルであるReceptionの参加者数は1184名(2016/12/12時点)となっています。 Github Githubではソースコード、Issue、Pull Requestなどが管理されています。 最近追加されたGithubの新機能であるProjectsやReviewers指定なども積極的に採用しています。\nまた、Mattermost本体のソースコードだけでなく、Mattermostのorganizationではドキュメント(Sphinx製)やDockerfile、デスクトップ・Android・iOSアプリなどのソースコードも公開されています。\n最近ではReact Nativeによるスマホアプリの開発も始まっているようです。\nJIRA Cloud JIRAでもIssueの管理が行われています。 GithubのIssue管理と被る部分もありそうですが、おそらくJIRAがメインのIssue Trackerで使用されており、GithubはGithubに慣れている人へのIssue報告の場やHelp Wanted Issue置き場として利用しているように思います。\nJenkins CIサーバーとしてJenkinsを利用しています。 PullRequestが作成されると、テストとチェックスタイルが実行され、CIの結果はPullRequestへ通知されます。\nMattermost Peer-to-Peer Forum ユーザーによるPeer-to-Peerのフォーラムも用意されています。 回答の必要があるトピックについては、定期的に開発者チャットの方でキャッチアップされているのため、回答がつかないということはあまり無いようです。\nMattermost Translation Server 翻訳作業用のPootleサーバーです。 翻訳については、別エントリに詳しく書いています。 MattermostのLocalizationフロー - Qiita\nCode Contribution コードを送る際に必要なプロセスは、公式のDevelopment Processにまとめてあるので、詳細についてはこちらを参照ください。 もちろん上記のドキュメントについてもオープンソースとして公開されており、PullRequestも受け付けています。https://github.com/mattermost/docs\nここでは、メインリポジトリであるmattermost/platformへのコントリビューションのざっくりとした流れを紹介します。 （GithubでのPullRequestの作り方などの基本的なことには触れません）\nチケット選択 まず、対応するチケットを下記から選びます。\n Help Wanted Issues - Github  2016/12/8〜2017/1/8まで、4つプルリクを送るとTシャツ(デザイン違うかも)が貰えるMattermost Holiday Hackfestが開催中 2016年10月のHacktoberfest以降、GithubにHelp Wanted Issueが作成されるようになった   Accepted Pull Request - JIRA  Good First Contribution - JIRAというのもあります。が、最近あまり追加はされてないようです。    CLA 対応するチケットが決まったらMattermost Contributor Agreementを結んでおきます。 これをやらずにPullRequestを送ると、Mattermostチームの方からPull Requestのコメントとして上記CLAを結ぶよう言われます。\nDeveloper Machine Setup 修正したソースコードの動作を確認するために、ローカルでMattermostを起動するための環境を作ります。 Developer Machine Setupを参考に。(DockerやGo環境が必要です)\nコーディング MattermostはGithub Flowを採用していると思われます。 PullRequest用の作業をする際は、masterから開発用ブランチを作成し、開発が終わったらmasterに対してPullRequestを作成します。\nブランチ名はJIRAチケットならplt-394のようにJIRAのチケット番号を使用します。 JIRAチケットがなく、Github Issueのみある場合はgh-555のようにIssue番号を使用しています。\n 実際のコードの修正部分ですが、リポジトリ内のファイル構造の概要はRepository Structureに書かれています。 個人的な感想としては、サーバーサイドのGoの部分はディレクトリ構造から責務が理解しやすいですが、フロントエンドのReact Component入れ子を読み解くのが難儀でした。\n 動作確認は、先のDeveloper Machine Setupを済ませた環境であれば、ルートディレクトリでmake runを実行することで、http://localhost:8065にMattermostが立ち上がるので、そちらで実機確認が出来ます。 また、Pull Requestを作成する前にmake test、make check-styleでエラーがないか確認しておきます。(私のMacBookAir 2011モデルでテスト完了まで10分程度かかるのが難点・・)\nPull Requestのテンプレートは下記のようになっているので指示通りに書き直します。\nPlease make sure you've read the [pull request](http://docs.mattermost.com/developer/contribution-guide.html#preparing-a-pull-request) section of our [code contribution guidelines](http://docs.mattermost.com/developer/contribution-guide.html). When filling in a section please remove the help text and the above text. #### Summary [A brief description of what this pull request does.] #### Ticket Link [Please link the GitHub issue or Jira ticket this PR addresses.] #### Checklist [Place an '[x]' (no spaces) in all applicable fields. Please remove unrelated fields.] - [ ] Added or updated unit tests (required for all new features) - [ ] Added API documentation (required for all new APIs) - [ ] All new/modified APIs include changes to the drivers - [ ] Has enterprise changes (please link) - [ ] Has UI changes - [ ] Includes text changes and localization file ([.../i18n/en.json](https://github.com/mattermost/platform/blob/master/i18n/en.json) and [.../webapp/i18n/en.json](https://github.com/mattermost/platform/tree/master/webapp/i18n/en.json)) updates - [ ] Touches critical sections of the codebase (auth, upgrade, etc.) この辺りの詳細についてはWorkflowに記述があります。\nレビュー Pull Requestを作成後、mergeされるためにはPMによるレビューと二人以上ののDeveloperによるレビューを通す必要があります。 PullRequestのレビューステータスはGithub上のラベル1: PM Review、2: PM Reviewなどで表現されています。\nまた、Setup Test Serverのラベルが貼られると、自動でPull Requestのコードを含んだMattermostを立ち上げ、その環境のURLをPull Requestにコメントしてくれる機能があるようです。 これらラベルの操作はコアチームしか操作できません。\nレビュー完了までにConflictが発生するとrebaseを求められるので、対応します。 私はこちらのエントリを参考にしながら対応しています。\n 上記がCode Contributionの流れです。\n所感 今回、大きめと思われるオープンソースへのコントリビューションを体験してみましたが、基本的には一般的に良いと言われているプラクティスをしっかり遂行しているという感じで、大きな驚きはありませんでした。 ツールを選べば社内でも遂行できますし、実際に社内でもWebベースのレビューツールやチャット、Jenkinsを利用したCIなども行っていたこともあるため、キーワードだけ見れば同じ開発スタイルを遂行できると思います。\nただ、開発に参加するときは事務作業など考えず、コードだけをに集中できるため気が楽でした。社内との一番の違いはそこかと思います。\nまた、Mattermostチームはコントリビューターに対してとても親切だと感じました。PullRequestに対する対応も(リリース前後でなければ)基本的には早いですし、「Issue対応したいんだけど、どこから手をつけたらいい？」というような初歩的な質問にも丁寧に回答してくれます。 きちんと組織立ったOSSであるMattermostに参加できたことは、OSSに参加する上での不安や躊躇いを払拭する意味で有意義だったと感じます。\nおわりに 二日目の高橋さんのエントリにもあったように\n 自分たちの体験こそが知見ノウハウであり、お客様のビジネスをよりよくするための糧になると私は考えています。（個人の見解です） ということだと思っています。\n また、こちらの前半部分については個人的にとても同意できます。\n「OSSはコストで採用するのではない。自立\u0026gt;社員の成長\u0026gt;事業の成長につながるものだ。」\nわかる。「責任取りたくないから ORACLE」ってシステムが近所にいくつかあるけど、そういうベンダーが作ったシステムは DB 以外もメタクソ。エンドユーザが苦労している。 #elasticon\n\u0026mdash; Toshihiko Nozaki (@bukaz54) 2016年12月15日  OSSを選択・OSSに参加するかどうかは個人個人考え方は違うでしょうが、他の組織の開発にも気軽に参加出来る時代なので、いろいろ見て回っていきたいです。\n"},{"ref":"https://blog.kaakaa.dev/post/java%E3%81%A7https%E3%81%AE%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AB%E8%AA%8D%E8%A8%BC%E4%BB%98%E3%81%8D%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7%E7%B5%8C%E7%94%B1%E3%81%A7%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%97%E3%82%88%E3%81%86%E3%81%A8%E3%81%99%E3%82%8B%E3%81%A8407%E3%82%A8%E3%83%A9%E3%83%BC/","title":"JavaでHTTPSのサイトに認証付きプロキシ経由でアクセスしようとすると407エラー","section":"post","date":"2016.12.14","body":"はじめに Java 8 Update 111からjava.netパッケージのHTTPS接続の際のトンネリングにBasic認証を使用できない設定がデフォルトになったようです。 回避するにはjdk.http.auth.tunneling.disabledSchemesに空文字列を設定する必要があるそうです。\n事象 背景 Javaのjava.net.HttpURLConnectionを利用して、認証付きプロキシ内の環境からhttpsのサイトにアクセスしようとした時に、どんな方法でプロキシの認証情報を付与しても407 Proxy Authentication Requiredエラーを解消できなかった。\nimport java.util.*; import java.net.*; public class Sample { private static String PROXY_HOST = \u0026#34;example.proxy.com\u0026#34;; private static String PROXY_PORT = \u0026#34;8080\u0026#34;; private static String PROXY_USER = \u0026#34;user\u0026#34;; private static String PROXY_PASSWORD = \u0026#34;password\u0026#34;; public static void main(String[] args) throws Exception { String url = \u0026#34;https://news.google.com\u0026#34;; System.setProperty(\u0026#34;proxySet\u0026#34;, \u0026#34;true\u0026#34;); System.setProperty(\u0026#34;proxyHost\u0026#34;, PROXY_HOST); System.setProperty(\u0026#34;proxyPort\u0026#34;, PROXY_PORT); Authenticator.setDefault(new Authenticator() { @Override protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(PROXY_USER, PROXY_PASSWORD.toCharArray()); } }); HttpURLConnection urlconn = (HttpURLConnection) new URL(url).openConnection(); urlconn.setRequestMethod(\u0026#34;GET\u0026#34;); urlconn.connect(); } } 現象 上記のJavaコードを実行すると下記のエラーが発生する。\n$ java Sample Exception in thread \u0026#34;main\u0026#34; java.io.IOException: Unable to tunnel through proxy. Proxy returns \u0026#34;HTTP/1.1 407 Proxy Authentication Required\u0026#34; at sun.net.www.protocol.http.HttpURLConnection.doTunneling(HttpURLConnection.java:2124) at sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:183) at sun.net.www.protocol.https.HttpsURLConnectionImpl.connect(HttpsURLConnectionImpl.java:153) at Sample.main(Sample.java:25) コード内での認証プロキシ設定だけでなく、下記も試しましたが結果はかわらず。\n Java起動オプションにproxyの設定をする   例: java -Dhttp.proxyHost=\u0026quot;example.proxy.com\u0026quot; -Dhttp.proxyPort=8080 -Dhttp.proxyUser=user -Dhttp.proxyPassword=password (httpsに関しても同様に設定) Sample  Systemデフォルトを参照するよう設定   例: java -Djava.net.useSystemProxies=true Sample  環境 OSはUbuntu 16.04、Javaのバージョンは下記です。\n$ java -version java version \u0026quot;1.8.0_111\u0026quot; Java(TM) SE Runtime Environment (build 1.8.0_111-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode) 結論 2016/10にリリースされた8u111以降から、デフォルトの設定としてHTTPS接続する際のトンネリングにBasic認証を利用することができなくなりました。\nJava 8リリースの変更\n HTTPSトンネリングのBasic認証の無効化 一部の環境で、HTTPSプロキシ時に特定の認証スキームが不適切である場合があります。そのため、Basic認証スキームは、デフォルトではOracle Java Runtimeでjdk.http.auth.tunneling.disabledSchemesネットワーク・プロパティにBasicを追加することで非アクティブ化されています。HTTPSのトンネルの設定時にBasic認証を必要とするプロキシは、デフォルトでは成功しないようになりました。必要な場合、jdk.http.auth.tunneling.disabledSchemesネットワーク・プロパティからBasicを削除するか、コマンド行で同じ名前のシステム・プロパティを\u0026quot;\u0026quot; (空)に設定することで、この認証スキームを再度アクティブ化できます。また、jdk.http.auth.tunneling.disabledSchemesおよびjdk.http.auth.proxying.disabledSchemesネットワーク・プロパティと同じ名前のシステム・プロパティは、それぞれHTTPSのトンネルの設定時またはプレーンなHTTPのプロキシ時に、アクティブ化されている可能性があるその他の認証スキームを無効化するために使用できます。JDK-8160838 (非公開)\n 英語版のリリースノートを見ると、core-libs/java.netと書いてあるので、java.netパッケージ内のクラスの機能を使ってHTTPS接続する際のデフォルトの挙動の変更だと思われます。\n回避方法  JVMオプションjdk.http.auth.tunneling.disabledSchemes=\u0026quot;\u0026quot;を設定する。   実行時: java -Djdk.http.auth.tunneling.disabledSchemes=\u0026quot;\u0026quot; Sample コード内: System.setProperty(\u0026quot;jdk.http.auth.tunneling.disabledSchemes\u0026quot;, \u0026quot;\u0026quot;);  他のライブラリを使う   ApacheのHTTPClientなど  補足 System.getProperty(\u0026quot;jdk.http.auth.tunneling.disabledSchemes\u0026quot;)をsysoutしてみましたが、結果はnullでした。\n"},{"ref":"https://blog.kaakaa.dev/post/chatgops%E3%81%A7%E6%9C%AC%E7%89%A9%E3%81%AEgopher%E3%82%92%E3%81%99%E3%81%90%E3%81%9D%E3%81%B0%E3%81%AB.../","title":"ChatGopsで本物のGopherを、すぐそばに...","section":"post","date":"2016.08.29","body":"ChatOps DevOpsの流れで、開発・運用における情報共有やビルド実行・通知などをコミュニケーションツールであるチャットから行うChatOpsというブームが起こりました。ChatOpsを採用することで開発チームと運用チームのリアルタイムな連携や、ビルド・デプロイの失敗に対する迅速な対応が可能となり、開発スピードの向上を図ることができるようになります。\nその中核をなすのが、チャットに書き込まれたメッセージによる処理実行やチャットへの通知を管理するBotツールです。 ChatOpsの流行り始めはGithub社のHubotがデファクトスタンダートでしたが、昨今ではSlackのBotkitやMicrosoft Bot Framework、またLINEまでもBotを提供するなど、Bot / ChatOpsはシステム開発における一つの定番プラクティスとなってきました。\nでも、何かが・・・何かが足りない・・\nChatGops そう、Gopherくんが足りない。\nkaakaa/bopher\n本物の golang を... 本物の Gopher を、お見せしますよ。 - Qiitaを全面的に利用しています。 （そのためWindows Onlyです）\n必要なもの  Mattermost 3.3～ mattn/gopherをビルドしたgopher.exe kaakaa/bopher: Bot + Gopher = Bopher  手順  Mattermost(v3.3以降)を立てる mattn/gophereをビルドする bopher.exeをダウンロードする bopher/config.jsonに設定を書いて、bopher.exeと同じディレクトリに置く bopher.exeを起動する  注意  Core i7, メモリ24GBを積んだマシンでもGopherくんを5,60人同時に発生させたところ操作が効かなくなりました。設定ファイルでGopherくんの最大数を設定できるようにしてあります。用法・容量を守って正しく服用ください。  きっかけ  Mattermost3.3から、GoでBotを書けるようになったので、なんか作ってみようと思いました  mattermost/mattermost-bot-sample-golang    "},{"ref":"https://blog.kaakaa.dev/post/mattermost%E3%81%AElocalization%E3%83%95%E3%83%AD%E3%83%BC/","title":"MattermostのLocalizationフロー","section":"post","date":"2016.08.29","body":"社内勉強会用に作成した資料だったものに手を加えて公開。\nはじめに Mattermostのローカライズに協力し始めたので、そのフローの記録(2016/12月現在)\nMattermost開発参加の背景 チャットツールとの出会い 外部の勉強会にはよく参加しており、DevOps/ChatOpsなんかの言葉も認識していました。 少し前のHubotによるChatOpsブームの際に、お試しとして社内のLinuxサーバにKandanを入れたのがChatツールとの出会いです。\nその後、一緒にチャットを使ってくれる方々を巻き込みつつ、Kandanは機能が足りないのでLet\u0026rsquo;s chatへ、Let\u0026rsquo;s Chatの開発滞ってきたところに同期がDockerでMattermost立ててくれたので移行したり。 そんな感じでMattermostを使い始めてからは、機能的に不満もないためバージョンアップを繰り返しながら、そろそろ１年使い続けています。\n最近ようやくSlackを使い始めたのですが、Mattermostに体が慣れすぎて違和感を感じ、プロキシという壁に阻まれた生活を続けたことで身体がガラパゴス化しているのを痛感しています。\nローカライズ参加までの流れ 元々、リモートワーク的な開発を経験するために、そこそこ大きなOSSにコントリビュートしてみたいと思っていました。参加するなら、やはり日常的に使うツールの方が良いと思っており、また、MattermostはサーバサイドGo言語・フロントエンドReact.jsと、まさに興味ピンポイントな技術を採用していたため非常に興味を持っていました。\nそんな中、普通にMattermostを使う中で誤翻訳を一つ発見。\n良い機会なので、公式サイトのLocalizationガイドを見ながら開発チームのチャット（Mattermost）に参加し、翻訳のサジェスションを行ってみました。（翻訳を確定するには権限が必要。権限のないユーザはサジェスションまでしか行えない） その時、未翻訳だと思われるメッセージが残っていたため、併せて翻訳作業を続けていました。\nそうこうしている内に、新しいバージョンのリリースが近づいたようで翻訳サーバーに翻訳対象メッセージ大量投入されました。が、その当時の公式レビュワーの方が多忙で連絡つかないようで、開発チームのチャットの方でコアメンバーから個別に日本語公式レビュワーにならないかと打診され、本格的に日本語への翻訳を開始することになりました。\n  jason 「他に日本語翻訳してるひといないから公式レビュワーならない？」 kaakaa 「( ﾟдﾟ )ﾎﾟｶｰﾝ..Okay!!」  Mattermostローカライズの進め方 ここからは、実際の翻訳作業について記述します。\nローカライズ対象 Mattermostのローカライズ対象メッセージはサーバー/クライアントそれぞれ別ファイルで管理されています。\nサーバーサイドはGo言語で書かれており、utils.TもしくはContext.Tを呼び出している部分で言語ごとのメッセージに変換しています。\nfunc NewServer() { l4g.Info(utils.T(\u0026#34;api.server.new_server.init.info\u0026#34;)) Srv = \u0026amp;Server{} } platform/server.go at master · mattermost/platform\n引数のメッセージIDに対応するメッセージはJSON形式でi18n/{lang}.jsonに存在します。\nMattermost Developer Brown Bag - Localization - YouTube\n クライアントサイドはReact.jsで書かれており、下記関数を使って言語の変換を行っています。\n react-intoのFormattedMessage, FormattedTime, FormattedDate loclizeMessage関数  \u0026lt;FormattedMessage id=\u0026#39;help.learnMore\u0026#39; defaultMessage=\u0026#39;Learn more about:\u0026#39; /\u0026gt; platform/messaging.jsx・mattermost/platform\n引数のメッセージIDに対応するメッセージはwebapp/i18n/{lang}.jsonに存在します。\nMattermost Developer Brown Bag - Localization - YouTube\n 各言語メッセージがかかれている{lang}.jsonファイルのうち、実際にPullRequestなどで編集されるのはen.jsonだけで、その他の言語ファイルについては後述の翻訳サーバーにより生成されます。\nPootle ローカライズ作業はPootleを利用して行っています。\n Welcome | Mattermost Translation Server  日本語翻訳についてのコミュニケーションは開発者チャット上のi18n - Japaneseやi18n - Localizationあたりで行われています。 開発者チャットではRelease DiscussionやDevelopersなどの開発上のコミュニケーションなども行われているため、開発に参加する場合はアカウントを作成しておいたほうが良いです。\nPootleとは?  Pootle - Wikipedia  Pootle は翻訳画面を備えたオンラインの翻訳支援ツールである。ツールは Python で書かれたフリーソフトウェアであり、2004年から Translate.org.za において開発、リリースされている。 Pootle はフリーの翻訳支援ソフトウェアからの利用を想定しているが、それに限定されてはいない。また、文書の翻訳よりもソフトウェア・アプリケーションの GUI の国際化を行うことを目的として開発されている。 Pootle は、翻訳作業の様々な局面で利用することができる。もっとも単純には、サーバーにある翻訳文の統計データを表示することができる。これにより他のユーザーに修正案を示したり、翻訳を修正してレビューに回したりでき、一種のバグ・レポート管理システムとして使うことができる。また多数の翻訳者に担当を割り当てることができ、さらにオフラインで行われた翻訳をまとめ、翻訳作業全体のワークフローを管理することができる。 Pootle は OpenOffice.org[1]、OLPCプロジェクト[2]、その他[3]で利用されている。また Mozilla プロジェクトの翻訳インフラを構築しているVerbatim project でも基盤として採用されている。    ローカライズフロー 実際の開発でen.json内のメッセージが追加・変更されると、毎日0:00(GMT)に自動でPootleサーバーへ翻訳対象のメッセージの追加が行われます。 また、Pootleサーバー上で翻訳が完了したメッセージは、毎週月曜の22:00(GMT)に本体へPull Requestが作成され、それがマージされることにより翻訳作業が完了します。 translations PR 20161208 by enahum · Pull Request #4740 · mattermost/platform\nMattermost Developer Brown Bag - Localization - YouTube\nPootleサーバーでの実際の作業 全ての言語のローカライズがここで行われている  メッセージはサーバー用とフロントエンド用に分かれている  翻訳対象メッセージのステータスはTranslated(翻訳済み)、Fuzzy(機械翻訳)、Untranslated(未翻訳)に分類される。  Fuzzy(機械翻訳)は、翻訳大将メッセージがサーバに投入されると同時にPootleシステムが自動で翻訳を行ってくれたメッセージ。 レビュワーによる承認作業が必要。  翻訳作業は１メッセージごとに行う  翻訳を行うとこのように見える。レビュワーがReject(拒否)/Submit(承認)を判断する。 自分で翻訳ファイルを適用する場合 翻訳ファイルは毎週masterにマージされ、最新版が含まれた状態でリリースされるため、基本的に自分で動作しているMattermostに最新の翻訳を適用することは無いと思いますが、緊急で特定のメッセージを翻訳しなきゃいけない場合のために。\nPootleサーバーにて翻訳済みのメッセージはPootle画面からダウンロードできます。 Pootleサーバからダウンロードできるファイルは.poというファイルなのですが、実際のシステムで使用するためには.poファイルを.json形式に変換する必要があります。 変換にはrodrigocorsi2/mattermosti18nを使用するようです。\nなんとなく、TravisCIで.jsonファイルまで生成できるリポジトリkaakaa/mattermosti18nを作ってみましたが、最新の翻訳データを使いたいと思ったことが無いので使っていません。 （英語なら英語のままで良いやと思ってしまう）\n翻訳する時に気をつけていること  可能な限り既存の訳し方を踏襲する  自分の中で言葉が見つかっても、まずは同じ英単語で訳を検索して同じかを確認 なるべく同じ概念を違う言葉で表現することが無いように（難しい。。。）   ソースコードを検索して、そのメッセージがどこで利用されているかを確認する  パッと見た時に訳し方を悩む場合はソースコードを確認して、近くで出現するメッセージを確認する 設定画面で使われるのか・注意書きとして使われるか\u0026hellip;など    気をつけてはいますが、なかなか統一できないことも多々。。\nローカライズに参加してみて 成果  MattermostのTシャツもらえた  ポロシャツとかパーカーとかいっぱいある（デザイン同じ）Knights of Mattermost Shirt (Black)   公式サイトに名前が載った  Localization — Mattermost documentation   Pootle使った翻訳手法を知れた チャット上での英語でのコミュニケーションもなんとかなることが分かった（返信に時間かかるけど）  感想  開発プラットフォームが分散してる(Github/JIRA/チャットなど)ので慣れるまでは大変そう  コアメンバによるバグfixなどは結構スピーディーなので、コード修正とかに参加するのはちょっと壁がある感   コアメンバはチャットへの返信も早くて親切  どんな質問にも答えてくれるけど、英語はやっぱり必要   Mattermostチームは楽しそうに開発してるなーという印象を受けました  "},{"ref":"https://blog.kaakaa.dev/post/%E6%89%8B%E8%BB%BD%E3%81%ABgradle%E3%83%93%E3%83%AB%E3%83%89%E3%82%92%E9%AB%98%E9%80%9F%E5%8C%96%E3%81%99%E3%82%8B10%E3%81%AE%E6%96%B9%E6%B3%95/","title":"手軽にGradleビルドを高速化する10の方法","section":"post","date":"2016.07.05","body":"はじめに Gradleのビルドを高速化する方法について、下記エントリを参考に調べてみました。 10 Tips to Improve Your Gradle Build Time — Medium\n記事の冒頭でも書かれている通り、上記のエントリはAndroidプロジェクト向けに書かれていますが、AndroidプロジェクトでなくてもGradleプロジェクトならば適用できる方法ばかりです。 （一つAndroid限定のものもありますが） 特にマルチプロジェクト構成の際に効果が高いものばかりなので、大規模なGradleプロジェクトを構築する際の参考になりそうです。\nただ、最後のまとめにも書きましたが、ビルド時間の大半を占めるのがテスト実行時間であることが多いため、劇的にビルドが早くなるという訳では無いかと思いました。\n0. ドキュメント Gradleのコマンドラインオプションと実行時オプションを利用する方法が多いため、公式ドキュメントを載せておきます。\nAppendix D. Gradle Command Line The Build Environment - Gradle User Guide Version 2.14\n1. デーモン化 これは昔から推奨されてましたね。 Gradleプロセスを常駐化させることで、JVMの起動や必須ライブラリの読み込みを毎回行わなくて済むようにする方法。\nThe Gradle Daemon - Gradle User Guide Version 2.14\n指定方法 org.gradle.daemon=true or\n./gradlew　--daemon # 一度起動するとそのまま常駐します ./gradlew build 2. 並列ビルド (incubating) マルチプロジェクトビルド限定です。 互いに参照しあっていないプロジェクト(Decoupled Project)のビルドを並列実行できます。\n指定方法 org.gradle.parallel=true org.gradle.workers.max=4 # 並列の最大数(デフォルトではプロセッサの数) or\n./gradlew build --parallel --max-workers=4 ./gradlew build --parallel --parallel-threads=4 --max-workersと--parallel-threadはどちらもorg.gradle.workers.maxと同じく、並列の最大数を指定するオプションです。 同時に指定された場合、--parallel-threadが優先されるそうです。\n3. オンデマンドConfigure (incubating) Multi-project Builds - Gradle User Guide Version 2.14\nGradleビルドのConfigure Phaseを必要なときだけ行うということですかね。 ちょっとここらへん理解が浅いです。\n指定方法 org.gradle.configureondemand=true or\n./gradlew build --configure-on-demand 4. グローバル設定 今まで紹介した手法と趣向が異なります。\n1-3でも登場したgradle.properteisファイルは、下記のいずれかの場所に置くことでビルド時に読み込まれます。\n Gradleプロジェクトのトップディレクトリ $USER_HOME/.gradle/gradle.properties $GRADLE_USER_HOME/gradle.properties  1-3に挙げているようなオプションは、プロジェクト関係なく有効な手法なのでユーザ設定にしてしてしまっても良さそうです。\nThe Build Environment - Gradle User Guide Version 2.14\n5. 最小化 ビルド実行時のコマンドラインオプションで実行しないタスクを指定できます。 Using the Gradle Command-Line - Gradle User Guide Version 2.14\n指定方法 ./gradlew build -x test ./gradlew build --exclude-task test 6. minSdkVersionを設定してARTのみを対象に Androidプロジェクト限定です。 Android SDKの最低バージョンを23に設定することでDalvik向けのdexing?をしないようにするみたいです。\nAndroid Studioのドキュメントでも紹介されているやり方のようで。 Configure Apps with Over 64K Methods | Android Studio\n指定方法 ... def minSdk = hasProperty(\u0026#39;minSdk\u0026#39;) ? minSdk : 16 android { compileSdkVersion 23 buildToolsVersion \u0026#34;23.0.2\u0026#34; dexOptions { javaMaxHeapSize \u0026#34;4g\u0026#34; jumboMode true } defaultConfig { applicationid \u0026#34;com.myapplication.app\u0026#34; minSdkVersion minSdk targetSdkVersion 23 ... ./gradlew assembleDebug -PminSdk=23 Android Studioでの指定方法については下記を参考に。 How to make faster Android build without sacrificing new api lint check\n7. オフライン実行 Gradleがネットワークリソースへアクセスするのを抑止するオプションのようです。 一度、ビルドに必要な資産をダウンロードすれば、以降はオフラインでも良さそう。\n指定方法 ./gradlew build --offline 8. Gradleのバージョンを2.4まで上げる 公式ブログでもアナウンスがあったように、Gradle2.4では2.3の時よりconfiguration timeが34%も削減されているそうで。 Gradle 2.4: The fastest yet - Gradle\n現在、Gradle2.14までリリースされているので、2.3以下を使っている場合はちょっと古すぎるので上げておくべきかと。\n9. jCenterの利用 MavenCentralよりjCenterを利用しましょうということらしいです。 確かにGradleのbuild-init pluginを使って生成したbuild.gradleでも、jCenterを利用するよう設定されています。\n理由については、下記のエントリが紹介されています。\n Android Studio – Migration from Maven Central to JCenter | Blog @Bintray Issue 72061 - android - The Maven index is huge! - Android Open Source Project - Issue Tracker - Google Project Hosting Feel secure with SSL? Think again. | Blog @Bintray  10. Profile! ちゃんとプロファイリングして、自分たちのビルドの内容を把握しておこうということですね。 --profileオプションを付けてビルドを実行すると、ビルドプロファイリングのHTMLファイルが出力されます。\nUsing the Gradle Command-Line - Gradle User Guide Version 2.14\nまた、Gradle Inc.はGradle Build Scansというサービスを開始しているので、コレを利用するのも良いかもしれません。 このサービスについては、私のブログで少し紹介しています。 Gradleがビルド結果解析サービス Gradle.com を開始していた - kaakaa Blog\n指定方法 ./gradlew build --profile さいごに いくつかの高速化手法について、Netflix/Hystrixを対象にビルド所要時間を測定してみましたが、やはりビルドで一番時間がかかるのはテスト実行のため、ほぼ高速化を体感できませんでした。 ただし、並列ビルドについてはサブプロジェクトのテストが並列に実行されるため、とても効果がありました。\n"},{"ref":"https://blog.kaakaa.dev/post/opencv%E3%81%A7%E6%96%87%E5%AD%97%E5%88%97%E8%AA%8D%E8%AD%98%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEdocker%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%E3%82%92%E4%BD%9C%E3%81%A3%E3%81%9F/","title":"OpenCVで文字列認識するためのDockerイメージを作った","section":"post","date":"2016.07.02","body":"作ったもの https://hub.docker.com/r/kaakaa/opencv-contrib-python3/\nOpenCVで文字列認識 画像処理ライブラリのOpenCVで文字列認識をする場合、OpenCV ContoribItseez/opencv_contribのtextモジュールを通じてtesseract-ocrを利用するのが定番のようです。 opencvで文字認識その１　Tesseractラッパ - whoopsidaisies\u0026rsquo;s diary\nOpenCVの機能で画像中の文字列の存在する位置を特定し、その特定したそれぞれの位置に対してTesseract-ocrの文字列認識を実行する模様。\n日本語を認識する場合、Tesseractで用意されている日本語トレーニングデータが使えそうです（まだ使ったことは無い）。 tesseract-ocr の言語データ(jpn.traineddata)について（その1） - 古都のIT職人Blog\n日本語文字列認識ならNHocrというのもあるらしい。 日本語OCRライブラリNHocrを利用してみる - Qiita\nOpenCV Contrib付きDockerイメージ OpenCV自体は公式でプリビルドバイナリが配布されていたりするので、環境構築自体はすぐにできる。\nただ、Contribのモジュールを使用する場合、公式ではバイナリが配布されておらず、さらに文字列認識を利用する場合はTesseractをインストールする必要があったりするので、自分でソースからビルドする必要がありそう。\nそこら辺の手順が面倒なので、OpenCV + OpenCV Contrib + Tesseract + Python3環境付きのDockerイメージを作りました。\nhttps://hub.docker.com/r/kaakaa/opencv-contrib-python3/ kaakaa/docker-opencv-contrib-python3: Dockerfile for OpenCV, OpenCV contrib and Python 3.5\n元々、こちらのDockerイメージaustriker/docker-opencv-contrib-python3を使おうとしましたが、Tesseractが入ってなかったので、そのあたりを修正しました。\n試しに実行 docker-opencv-contrib-python3/compose-sample at master · kaakaa/docker-opencv-contrib-python3の方に、文字列認識用のWebアプリが立ち上がるdocker-composeを用意しました。 （Webアプリとしても文字列認識としても、まだまだ使い物レベルにはならないですが）\n実際に実行してみた結果が下記画面。\n下の画像のピンクで囲まれた部分が、OpenCVによって特定された文字列位置なのですが、画像全体として認識されてしまっているよう。 一行一行認識してほしいのですが。\nそこらへんはいろいろチューニングしていく必要がありそうです。\n"},{"ref":"https://blog.kaakaa.dev/post/%E6%84%8F%E8%AD%98%E3%81%AE%E4%BD%8E%E3%81%84gradle%E3%81%AE%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E3%82%A2%E3%83%83%E3%83%97/","title":"意識の低いGradleのバージョンアップ","section":"post","date":"2016.06.07","body":"※Gradle 2.4以下の場合は正規の形で再インストールすることが推奨されています Gradle 2.4: The fastest yet - Gradle\n0.背景 Gradleは便利ですが2,3ヶ月ごとにバージョンアップするので、付いて行くのが大変です。\n$ gradle -v ------------------------------------------------------------ Gradle 2.5 ------------------------------------------------------------ Build time: 2015-07-08 07:38:37 UTC Build number: none Revision: 093765bccd3ee722ed5310583e5ed140688a8c2b Groovy: 2.3.10 Ant: Apache Ant(TM) version 1.9.3 compiled on December 23 2013 JVM: 1.8.0_45 (Oracle Corporation 25.45-b02) OS: Windows 8.1 6.3 amd64 よくあります。 （2016/6/7時点で最新はv2.13。v2.14-rc4も出てるのでもうすぐバージョンアップしそう）\nここからgradleのバージョンアップをするには下記手順が必要です。\n ブラウザを開く gradleでググる Gradleのサイトへ行く ダウンロードボタンを探す ダウンロードする ダウンロードしたファイルを解凍する 解凍したフォルダを所定の場所へ移動する 必要ならばPATHを書き換える PATHを書き換えた、かつWindowsならばコマンドプロンプトを再起動する  絶望だ。\n意識が低い時は Gradle Wrapper を使うと便利です。\n第62章 Gradleラッパー （最新ドキュメントではChapter 5に昇格している模様 Chapter 5. The Gradle Wrapper）\n1. build.gradleを書こう wrapperを作るためbuild.gradleを書きます。\ntask wrapper(type: Wrapper) { gradleVersion = \u0026#39;2.12\u0026#39; } 意識が低くてもコレだけは覚えておきましょう。\n2. wrapperタスクを実行する gradle wrapper これでwrapperファイルが生成されます。\n3. gradlewを実行する ダウンロードに時間がかかる。\n$ gradlew.bat -v Downloading https://services.gradle.org/distributions/gradle-2.12-bin.zip ............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................ Unzipping C:\\Users\\kaakaa_hoe\\.gradle\\wrapper\\dists\\gradle-2.12-bin\\avhnk0p45wmm16bas931at19r\\gradle-2.12-bin.zip to C:\\Users\\kaakaa_hoe\\.gradle\\wrapper\\dists\\gradle-2.12-bin\\avhnk0p45wmm16bas931at19r ------------------------------------------------------------ Gradle 2.12 ------------------------------------------------------------ Build time: 2016-03-14 08:32:03 UTC Build number: none Revision: b29fbb64ad6b068cb3f05f7e40dc670472129bc0 Groovy: 2.4.4 Ant: Apache Ant(TM) version 1.9.3 compiled on December 23 2013 JVM: 1.8.0_45 (Oracle Corporation 25.45-b02) OS: Windows 8.1 6.3 amd64 （最新がv2.13なのに、上の表示がv2.12なのは意識が低いからです）\n注意点  バージョンアップ時にGradle wrapperの最適化がされることもある 毎回、build.gradleの記述の労力とwrapperによるダウンロード時間がかかる  最新版をちゃんとダウンロードして使うのが健全ですが、意識が低い時のための手段として。 Gradle Wrapperのファイルだけをコミットしたリポジトリを作っておけば、バージョン部分だけを書き換えて使えるので、その方法も良いかと思います。\n"},{"ref":"https://blog.kaakaa.dev/post/line-bot%E3%81%A7%E4%BD%95%E3%82%84%E3%81%A3%E3%81%A6%E8%89%AF%E3%81%84%E3%81%8B%E5%88%86%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%AE%E3%81%A7%E3%81%A8%E3%82%8A%E3%81%82%E3%81%88%E3%81%9Aifttt%E3%81%AB%E9%A3%9B%E3%81%B0%E3%81%97%E3%81%A6%E3%81%BF%E3%82%8B/","title":"LINE BOTで何やって良いか分からないのでとりあえずiftttに飛ばしてみる","section":"post","date":"2016.04.13","body":"LINE BOTを始めBot界隈が盛り上がってきてますが、BotKit公開されても何すれば良いか分からない人間なので、とりあえずiftttへのパス作っとけば夢は広がるだろうというアレです。\n下記の情報の組み合わせでできました。\nLINE BOT をとりあえずタダで Heroku で動かす - Qiita AWS LambdaとIFTTTでお手軽にpush通知を実現する - Qiita\n\n動かすには下記が必要\n LINE BOT API のトライアルアカウン iftttのMakerチャンネルのSecretKey   流れとしてはLINE BOTからHerokuへCallbackし、HerokuからiftttのMakerチャンネルへリクエストを飛ばしてます。 Connect Maker to hundreds of apps - IFTTT\nMakerチャンネルへリクエストを飛ばすとCongratulations! You've ～ という定型文が返されるので、それをまたLINEへつぶやくようにしています。 （リクエストがiftttへ届いたことを表しているだけで、レシピがエラーとなったかどうかは判別できなそうです）\nMakerチャンネルはiftttのレシピ毎にEventNameを指定できるため、LINEでのメッセージの先頭でそのEventNameを指定できるようにしており、Herokuにアプリ一つ立てておくだけで、iftttの複数のレシピに対応できるはずです。\nLINE上でifttt-test hogehogeとつぶやけば、EventNameがifttt-testのレシピが実行されるはずです。\n# Mostly taken from http://qiita.com/masuidrive/items/1042d93740a7a72242a3 # And https://github.com/yuya-takeyama/line-echo require \u0026#39;sinatra/base\u0026#39; require \u0026#39;json\u0026#39; require \u0026#39;rest-client\u0026#39; class App \u0026lt; Sinatra::Base SECRET_KEY = ENV[\u0026#39;MAKER_SECRET_KEY\u0026#39;] # Maker channel\u0026#39;s secret key EVENT_NAME_DEFAULT = ENV[\u0026#39;MAKER_EVENT_NAME_DEFAULT\u0026#39;] # Maker channel\u0026#39;s default event name post \u0026#39;/linebot/callback\u0026#39; do params = JSON.parse(request.body.read) RestClient.proxy = ENV[\u0026#39;FIXIE_URL\u0026#39;] if ENV[\u0026#39;FIXIE_URL\u0026#39;] params[\u0026#39;result\u0026#39;].each do |msg| event, message = msg[\u0026#39;content\u0026#39;][\u0026#39;text\u0026#39;].split(\u0026#39; \u0026#39;, 2) response = request_to_ifttt(event, message) request_to_line([msg[\u0026#39;content\u0026#39;][\u0026#39;from\u0026#39;]], response) end \u0026#34;OK\u0026#34; end helpers do def request_to_ifttt(event = EVENT_NAME, message) # Maker channel\u0026#39;s extra data request_content = { value1: message, value2: \u0026#39;from\u0026#39;, value3: \u0026#39;Line Bot\u0026#39; } endpoint_uri = \u0026#34;https://maker.ifttt.com/trigger/#{event}/with/key/#{SECRET_KEY}\u0026#34; content_json = request_content.to_json response = RestClient.post(endpoint_uri, content_json, { \u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#39;application/json; charset=UTF-8\u0026#39;, \u0026#39;Content-Length\u0026#39; =\u0026gt; content_json.length }) end def request_to_line(send_to, message) request_content = { to: send_to, toChannel: 1383378250, # Fixed value eventType: \u0026#34;138311608800106203\u0026#34;, # Fixed value content: { \u0026#34;contentType\u0026#34;: 1, # Text type message \u0026#34;toType\u0026#34;: 1, \u0026#34;text\u0026#34;: message } } endpoint_uri = \u0026#39;https://trialbot-api.line.me/v1/events\u0026#39; content_json = request_content.to_json RestClient.post(endpoint_uri, content_json, { \u0026#39;Content-Type\u0026#39; =\u0026gt; \u0026#39;application/json; charset=UTF-8\u0026#39;, \u0026#39;X-Line-ChannelID\u0026#39; =\u0026gt; ENV[\u0026#34;LINE_CHANNEL_ID\u0026#34;], \u0026#39;X-Line-ChannelSecret\u0026#39; =\u0026gt; ENV[\u0026#34;LINE_CHANNEL_SECRET\u0026#34;], \u0026#39;X-Line-Trusted-User-With-ACL\u0026#39; =\u0026gt; ENV[\u0026#34;LINE_CHANNEL_MID\u0026#34;], }) end end end  Makerチャンネルのリクエストにはパラメータを３つ（Value1, Value2, Value3）まで指定できます。 EventNameはそのままの意味、OccurredAtはリクエストを受け付けた日時になります。\nifttt上で指定する場合はValue1のように先頭を大文字のVにしないとエラーになりますが、リクエストパラメータでは先頭小文字のvalue1でないとダメみたいです。\n# Maker channel\u0026#39;s extra data request_content = { value1: message, value2: \u0026#39;from\u0026#39;, value3: \u0026#39;Line Bot\u0026#39; }  ソースは下記に置いてます。 (masuidrive さんに怒られたら消す) kaakaa/line-ifttt\nとりあえず作ったもののやりたいことがない。\n"},{"ref":"https://blog.kaakaa.dev/post/docker-compose-1%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%A7%E7%AB%8B%E3%81%A6%E3%82%89%E3%82%8C%E3%82%8B%E3%82%BB%E3%83%AB%E3%83%95%E3%83%9B%E3%82%B9%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0powerpoint%E3%82%A2%E3%83%83%E3%83%97%E3%83%AD%E3%83%BC%E3%83%80/","title":"docker-compose 1コマンドで立てられるセルフホスティングPowerPointアップローダ","section":"post","date":"2016.04.06","body":"これは何？ kaakaa/ppt-museum: ppt/pptx file uploader\ndocker-compose up -dだけで起動するPowerPoint資料アップローダを作っています。\nトップ画面 スライド画面 使い方 必須環境  docker docker-compose  実行コマンド $ git clone https://github.com/kaakaa/ppt-museum.git $ cd ppt-museum // docker v1.10.0+ / docker-compose v1.6.0+ の場合 $ docker-compose up -d // 上記のバージョン以外の場合 $ docker-compose -f docker-compose-v1.yml up -d http://localhost:4567/ にアクセスするとトップページが表示されます。\n内部構造 アーキテクチャ 4つのDockerコンテナを起動しています。\n nginx mongo jodconverter  =\u0026gt; kaakaa/jodconverter-container: Dockerfile for JODConverter PowerPointファイルをPDFファイルに変換するコンテナ   ppt-museum-web  =\u0026gt; kaakaa/ppt-museum-webapp: Webapp for ppt-museum Javaのマイクロフレームワーク Spark Framework - A tiny Java web framework ベースのWebアプリコンテナ    既知の問題  DB構造が変わったときのマイグレーションパスを用意していない  アップロード資産をZipダウンロードして、kaakaa/ppt-batchでアップロードし直すという最底辺の人力運用でカバーの現状   UI周りが要改善  フロントエンド力が圧倒的に足りない   テストコードを全然書いていない  他にもたくさんありますが。。。\n背景 以降は蛇足ですが、これを作ろうと思った背景について。\n 社内勉強会の資料をアップロードするために作りました。\n社内勉強会の資料には、社外NGの話が含まれていたり、「外に公開するほどの…」という方もいたりするので、そういう資料を個人で貯めこむことの無いようにと作りました。また、勉強会開始当初は勉強会用に立ててるWikiに資料を添付するという運用を取っていましたが、Wikiに添付された資料をわざわざダウンロードして開くことなんて無いので、閲覧機会の損失を防ぎたかったという想いもあります。\n その昔にkaakaa/pptgalleryを作って今まで運用していました。 しかし、コレには\n LibreOffice / ImageMagick などのミドルに依存しており、二度と環境が作れる気がしない ruby / jsを手探りで組んでいたのでメンテできる気がしない  などの辛い面が多くあったため、匙を投げることにしました。 そして作りなおしたのが kaakaa/ppt-museum です。\nkaakaa/pptgalleryの反省から\n 環境はどこでも立てられるようにdocker-composeを使う ruby/jsに夢を見るのをやめて、メンテする気になれるよう一番慣れているJavaで書く  という方針で作っています。\n また、作りなおそうと思ったきっかけとなったのが、azu/pdf.js-controllerを見つけたことでした。スライド表示部分ではazu/pdf.js-controllerをそのまま使っています。\nPPTGalleryの頃にも、PowerPointファイルをJODConverter | Art of SolvingでPDFファイルに変換することはできていましたが、そのPDFファイルをスライド形式で表示する方法が分からず、ImageMagickを使って画像ファイルに変換したものを表示するという茨の道を選択してしまいました。\nazu/pdf.js-controllerにより、PowerPointファイルをPDFファイルに変換するところまでを考えれば良くなったため、Javascript方面へ深く足を踏み入れなくて済みました。\nおわりに dockerを使って開発してみるのは初めてでしたが、一度動かせればインフラを簡単に立て たり壊したりできるので、アプリを書くことに集中できるようになっていると思います。\n これを作る時に試した、Gradleを使ったnpm/gruntビルドや、Dockerイメージの作成について、下記にまとめています。 Gradleでbowerを利用したフロントエンドのビルドまでを行う方法 (1/6) - Qiita\n"}]